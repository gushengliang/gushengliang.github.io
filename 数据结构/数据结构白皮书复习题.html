<!doctype html><html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta><title>数据结构白皮书复习题 - lvjie&#039;blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="lvjie&#039;blog"><meta name="msapplication-TileImage" content="https://wkphoto.cdn.bcebos.com/4ec2d5628535e5ddc0adc1bc66c6a7efcf1b62cb.jpg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="lvjie&#039;blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="时间复杂度 下面程序的时间复杂度是 —— O(m*n)"><meta property="og:type" content="blog"><meta property="og:title" content="顾笙凉"><meta property="og:url" content="http://gushengliang.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BD%E7%9A%AE%E4%B9%A6%E5%A4%8D%E4%B9%A0%E9%A2%98.html"><meta property="og:site_name" content="顾笙凉"><meta property="og:description" content="时间复杂度 下面程序的时间复杂度是 —— O(m*n)"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://wkphoto.cdn.bcebos.com/0df431adcbef76095843fdfc3edda3cc7cd99e0c.jpg"><meta property="article:published_time" content="2022-01-19T10:23:17.000Z"><meta property="article:modified_time" content="2022-02-10T07:26:41.921Z"><meta property="article:author" content="lvjie"><meta property="article:tag" content="试题"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://wkphoto.cdn.bcebos.com/0df431adcbef76095843fdfc3edda3cc7cd99e0c.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://gushengliang.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BD%E7%9A%AE%E4%B9%A6%E5%A4%8D%E4%B9%A0%E9%A2%98.html"},"headline":"lvjie'blog","image":["https://wkphoto.cdn.bcebos.com/0df431adcbef76095843fdfc3edda3cc7cd99e0c.jpg"],"datePublished":"2022-01-19T10:23:17.000Z","dateModified":"2022-02-10T07:26:41.921Z","author":{"@type":"Person","name":"lvjie"},"description":"时间复杂度 下面程序的时间复杂度是 —— O(m*n)"}</script><link rel="canonical" href="http://gushengliang.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BD%E7%9A%AE%E4%B9%A6%E5%A4%8D%E4%B9%A0%E9%A2%98.html"><link rel="icon" href="https://wkphoto.cdn.bcebos.com/4ec2d5628535e5ddc0adc1bc66c6a7efcf1b62cb.jpg"><meta name="referrer" content="no-referrer-when-downgrade"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css?family=Ubuntu:400,600|Source+Code+Pro|Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Microsoft YaHei:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&amp;amp;subset=latin,latin-ext|Inconsolata|Itim|Lobster.css"><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="/js/globalUtils.js"></script><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><link rel="stylesheet" href="/live2d/waifu.css"><script async src="/live2d/autoload.js"></script><meta name="generator" content="Hexo 5.4.1"></head><body class="is-3-column has-navbar-fixed-top"><nav class="navbar navbar-main is-fixed-top"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="https://wkphoto.cdn.bcebos.com/96dda144ad345982bfec81f11cf431adcbef846a.jpg" alt="lvjie&#039;blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/archives">归档</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/gushengliang/gushengliang.github.io"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a><a class="navbar-item" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a></div></div></div></nav><script src="/js/theme-setting.js"></script><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="https://wkphoto.cdn.bcebos.com/0df431adcbef76095843fdfc3edda3cc7cd99e0c.jpg" alt="数据结构白皮书复习题"></span></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2022-01-19  <span class="level-item"><i class="far fa-clock"> </i>39 分钟  <i class="fas fa-pencil-alt"> </i>5.9 k</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">数据结构白皮书复习题</h1><div class="content"><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><ol><li>下面程序的时间复杂度是 —— O(m*n)<span id="more"></span></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">	<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">		a[i][j] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><ol start="2"><li>下面程序的时间复杂度是 —— O(n)</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">	s = s * i;</span><br></pre></td></tr></table></figure><ol start="3"><li>下面程序的时间复杂度是 —— O(n2)</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">		s += a[i][j];</span><br></pre></td></tr></table></figure><ol start="4"><li>下面程序的时间复杂度是 —— O(log3n)</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt;= n)</span><br><span class="line">	i = i * <span class="number">3</span>;</span><br></pre></td></tr></table></figure><h2 id="逻辑图和逻辑结构"><a href="#逻辑图和逻辑结构" class="headerlink" title="逻辑图和逻辑结构"></a>逻辑图和逻辑结构</h2><p><img src="https://wkphoto.cdn.bcebos.com/728da9773912b31b18c6a94a9618367adab4e12f.jpg"><br><img src="http://inews.gtimg.com/newsapp_ls/0/14438689477/0"></p><p><img src="https://wkphoto.cdn.bcebos.com/a8773912b31bb051518ed74b267adab44aede02f.jpg"><br>B = (K, R)<br>K = {k1, k2, k3, k4, k5, k6, k7, k8, k9}<br>R = {&lt;k1, k2&gt;, &lt;k1, k3&gt;, &lt;k3, k6&gt;, &lt;k3, k4&gt;, &lt;k4, k5&gt;, &lt;k6, k8&gt;, &lt;k6, k7&gt;, &lt;k8, k9&gt;}</p><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p><img src="https://wkphoto.cdn.bcebos.com/b21bb051f81986189ded8be75aed2e738bd4e62f.jpg"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DeleteSame</span><span class="params">(SqList &amp;L)</span></span>&#123;<span class="comment">//从线性表L中删除值相同的多余元素 </span></span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">while</span>(i &lt;= ListLength(L) - <span class="number">1</span>)&#123;</span><br><span class="line">		GetElem(L, i, e1);<span class="comment">//获取第i位元素e1 </span></span><br><span class="line">		GetElem(L, i+<span class="number">1</span>, e2);<span class="comment">//获取第i+1位元素e2 </span></span><br><span class="line">		<span class="keyword">if</span>(e1 != e2)<span class="comment">//元素不相同，进行下一个 </span></span><br><span class="line">			i++;</span><br><span class="line">		<span class="keyword">else</span><span class="comment">//元素相同，删除一个 </span></span><br><span class="line">			ListDelete(L, i+<span class="number">1</span>, e);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://wkphoto.cdn.bcebos.com/a2cc7cd98d1001e92374706ca80e7bec54e7970c.jpg"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DeleteK</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> i, <span class="keyword">int</span> k)</span></span>&#123;<span class="comment">//在线性表L中删除第i个元素起的k个元素 </span></span><br><span class="line">	<span class="keyword">if</span>(i&lt;<span class="number">0</span> || k&lt;<span class="number">0</span> || i+k<span class="number">-1</span>&gt;L.length)<span class="comment">//i为逻辑位序 </span></span><br><span class="line">		<span class="keyword">return</span> INFEASIBLE;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=i+k<span class="number">-1</span>; j&lt;=L.length<span class="number">-1</span>; j++)<span class="comment">//将i+k-1起的所有元素依次移到i-1起的对应位置上 </span></span><br><span class="line">		L.elem[j-k] = L.elem[j];</span><br><span class="line">	L.length = L.length - k;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><img src="https://wkphoto.cdn.bcebos.com/00e93901213fb80e66b105b426d12f2eb9389474.jpg"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Compare_SqList</span><span class="params">(SqList LA, SqList LB)</span></span>&#123;</span><br><span class="line">	<span class="comment">//比较字符表LA和LB，并用返回表示结果</span></span><br><span class="line">	<span class="comment">//值为正，表示LA&gt;LB</span></span><br><span class="line">	<span class="comment">//值为负，表示LA&lt;LB</span></span><br><span class="line">	<span class="comment">//值为零，表示LA=LB</span></span><br><span class="line">	<span class="comment">//设LA和LB中表长以后存储的字符均为空 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; LA.elem[i]||LB.elem[i]; i++)</span><br><span class="line">		<span class="keyword">if</span>(LA.elem[i] != LB.elem[i])<span class="comment">//出现字符不相同，则可以区分大小 </span></span><br><span class="line">			<span class="keyword">return</span> LA.elem[i] - LB.elem[i];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://wkphoto.cdn.bcebos.com/32fa828ba61ea8d3aca11067870a304e241f58d5.jpg"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Delete_Between</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> mink, <span class="keyword">int</span> maxk)</span></span>&#123;</span><br><span class="line">	<span class="comment">//删除链表L中值大于mink且小于maxk的所有元素 </span></span><br><span class="line">	LinkList p = L, p;</span><br><span class="line">	<span class="keyword">while</span>(p-&gt;next-&gt;data &lt;= mink)</span><br><span class="line">		p = p-&gt;next;<span class="comment">//p是最后一个不大于mink的元素 </span></span><br><span class="line">	<span class="keyword">if</span>(p-&gt;next)&#123;<span class="comment">//如果还有比mink更大的元素 </span></span><br><span class="line">		q = p-&gt;next;</span><br><span class="line">		<span class="keyword">while</span>(q-&gt;data &lt; maxk)&#123;</span><br><span class="line">			p-&gt;next = q-&gt;next;<span class="comment">//q的第一个不小于maxk的元素 </span></span><br><span class="line">			<span class="built_in">free</span>(q);</span><br><span class="line">			q = p-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://wkphoto.cdn.bcebos.com/00e93901213fb80e669905b426d12f2eb938940c.jpg"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListMergeOppose_L</span><span class="params">(LinkList &amp;La, LinkList &amp;Lb, LinkList &amp;Lc)</span></span>&#123;</span><br><span class="line">	LinkList pa = La-&gt;next;</span><br><span class="line">	LinkList pb = Lb-&gt;next;<span class="comment">//pa和pb分别指向A，B的当前元素 </span></span><br><span class="line">	Lc = La;</span><br><span class="line">	Lc-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">while</span>(pa &amp;&amp; pb)&#123;</span><br><span class="line">		<span class="keyword">if</span>(pa-&gt;data &lt;= pb-&gt;data)&#123;</span><br><span class="line">			p = pa-&gt;next;</span><br><span class="line">			pa-&gt;next = Lc-&gt;next;</span><br><span class="line">			Lc-&gt;next = pa;<span class="comment">//将La的元素插入新表的表头 </span></span><br><span class="line">			pa = p;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			p = pb-&gt;next;</span><br><span class="line">			pb-&gt;next = Lc-&gt;next;</span><br><span class="line">			Lc-&gt;next = pb;<span class="comment">//将Lb的元素插入新表的表头 </span></span><br><span class="line">			pb = p;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(pa)&#123;</span><br><span class="line">		p = pa-&gt;next;</span><br><span class="line">		pa-&gt;next = Lc-&gt;next;</span><br><span class="line">		Lc-&gt;next = pa;<span class="comment">//将La的剩余元素插入新表的表头 </span></span><br><span class="line">		pa = p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(pb)&#123;</span><br><span class="line">		p = pb-&gt;next;</span><br><span class="line">		pb-&gt;next = Lc-&gt;next;</span><br><span class="line">		Lc-&gt;next = pb;<span class="comment">//将Lb的剩余元素插入新表的表头 </span></span><br><span class="line">		pb = p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(Lb);</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://wkphoto.cdn.bcebos.com/a71ea8d3fd1f4134c4b4611d351f95cad0c85ed5.jpg"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Divide_LinkedPoly</span><span class="params">(LinkedPoly &amp;L, LinkedPoly &amp;La, LinkedPoly &amp;Lb)</span></span>&#123;</span><br><span class="line">	<span class="comment">//将单向循环链表存储的稀疏多项式L拆成只含奇次项的La和只含偶次项的Lb </span></span><br><span class="line">	La = L;</span><br><span class="line">	Lb = (LinkedPoly)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(PolyNode));</span><br><span class="line">	LinkedPoly p = L-&gt;next;</span><br><span class="line">	LinkedPoly pa = La;</span><br><span class="line">	LinkedPoly pb = Lb;</span><br><span class="line">	<span class="keyword">while</span>(p != L)&#123;</span><br><span class="line">		<span class="keyword">if</span>(p-&gt;data.<span class="built_in">exp</span> % <span class="number">2</span>)&#123;<span class="comment">//奇次项 </span></span><br><span class="line">			pa-&gt;next = p;</span><br><span class="line">			pa = p;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;<span class="comment">//偶次项 </span></span><br><span class="line">			pb-&gt;next = p;</span><br><span class="line">			pb = p;</span><br><span class="line">		&#125;</span><br><span class="line">		p = p-&gt;next;<span class="comment">//下一个多项式 </span></span><br><span class="line">	&#125;</span><br><span class="line">	pa-&gt;next = La;<span class="comment">//将La首尾相连，成循环链表 </span></span><br><span class="line">	pb-&gt;next = Lb;<span class="comment">//将Lb首尾相连，成循环链表 </span></span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><p><img src="https://wkphoto.cdn.bcebos.com/b90e7bec54e736d10f73e86b8b504fc2d5626974.jpg"><br>ABCD、ABDC、ACBD、ACDB、BACD、ADCB、BADC、BCAD、BCDA、BDCA、CBAD、CBDA、CDBA、DCBA</p><p><img src="https://wkphoto.cdn.bcebos.com/2f738bd4b31c8701131cd685377f9e2f0708ff2f.jpg"><br>队列Q采用顺序存储结构，设队头指针front指向队列头元素位置，队尾指针rear指向队列尾元素的下一个位置，队列的容量(即存储的空间大小)为MAXQSIZE。入队时，若Q.rear==MAXQSIZE，则会发生队列的上溢现象，即使队列中尚余有足够的空间，但元素却不能入队，出现了“假溢出”现象。<br>一般地，可用以下方法解决：<br>  (1)采用移动元素的方法。假定空余空间足够，每当有一个新元素入队，就将队列中已有的元素向队头移动一个位置。<br>  (2)每当删去一个队头元素，则可依次移动队列中的元素总是使front指针指向队列中的第一个位置。<br>  (3)采用循环队列方式。将队头、队尾看作是一个首尾相接的循环队列，此时队首仍在队尾之前，作插入和删除运算时仍遵循“先进先出”的原则。</p><p><img src="https://wkphoto.cdn.bcebos.com/55e736d12f2eb938b9251e91c5628535e5dd6f0c.jpg"><br>Stack</p><p><img src="https://wkphoto.cdn.bcebos.com/2e2eb9389b504fc2f13fd466f5dde71190ef6d74.jpg"><br><img src="https://wkphoto.cdn.bcebos.com/37d12f2eb9389b506cb784319535e5dde7116e0c.jpg"></p><p><img src="https://wkphoto.cdn.bcebos.com/8601a18b87d6277f2bb8565b38381f30e924fc2f.jpg"><br>char</p><p><img src="https://wkphoto.cdn.bcebos.com/a08b87d6277f9e2fb19f796b0f30e924b899f32f.jpg"><br>队列逆置</p><p><img src="https://wkphoto.cdn.bcebos.com/86d6277f9e2f07089faf4e63f924b899a901f22f.jpg"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitCircleQueue</span><span class="params">(LinkQueue &amp;Q)</span></span>&#123;</span><br><span class="line">	<span class="comment">//初始化循环链表表示的队列Q </span></span><br><span class="line">	Q.rear = (QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line">	<span class="keyword">if</span>(!Q.rear)</span><br><span class="line">		<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">	Q.rear-&gt;next = Q.rear;<span class="comment">//连成循环 </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">EnCircleQueue</span><span class="params">(LinkQueue &amp;Q, QElemType e)</span></span>&#123;</span><br><span class="line">	<span class="comment">//把元素e插入循环链表表示的队列Q </span></span><br><span class="line">	p = (QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line">	<span class="keyword">if</span>(!p)</span><br><span class="line">		<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">	p-&gt;data = e;</span><br><span class="line">	p-&gt;next = Q.rear-&gt;next;<span class="comment">//直接把p加在Q.rear的后面 </span></span><br><span class="line">	Q.rear-&gt;next = p;</span><br><span class="line">	Q.rear = p;<span class="comment">//修改尾指针 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DeCircleQueue</span><span class="params">(LinkQueue &amp;Q, QElemType &amp;e)</span></span>&#123;</span><br><span class="line">	<span class="comment">//从循环链表表示的队列Q头部删除元素e </span></span><br><span class="line">	<span class="keyword">if</span>(Q.rear-&gt;next == Q.rear)</span><br><span class="line">		<span class="keyword">return</span> INFEASIBLE;<span class="comment">//队列已空 </span></span><br><span class="line">	p = Q.rear-&gt;next-&gt;next;</span><br><span class="line">	e = p-&gt;data;</span><br><span class="line">	Q.rear-&gt;next-&gt;next = p-&gt;next;</span><br><span class="line">	<span class="keyword">if</span>(Q.rear == p)</span><br><span class="line">		Q.rear = p-&gt;next;</span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><img src="https://wkphoto.cdn.bcebos.com/9a504fc2d5628535c3a8b64280ef76c6a7ef630c.jpg"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Palindrome_Test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//判别字符串是否回文序列，是则返回1，否则返回0 </span></span><br><span class="line">	InitStack(S);<span class="comment">//初始化栈 </span></span><br><span class="line">	InitQueue(Q);<span class="comment">//初始化队列 </span></span><br><span class="line">	<span class="keyword">while</span>((c=getchar()) != <span class="string">&#x27;@&#x27;</span>)&#123;</span><br><span class="line">		Push(S, c);<span class="comment">//进栈 </span></span><br><span class="line">		EnQueue(Q, c);<span class="comment">//进队列 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(!StackEmpty(S))&#123;<span class="comment">//利用栈：后进先出；队列：先进先出的特点进行比较 </span></span><br><span class="line">		Pop(S, a);</span><br><span class="line">		DeQueue(Q, b);</span><br><span class="line">		<span class="keyword">if</span>(a != b)</span><br><span class="line">			<span class="keyword">return</span> ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p><img src="https://wkphoto.cdn.bcebos.com/d4628535e5dde711b89a2795b7efce1b9d16610c.jpg"><br>（1）按行优先存储：<br>A[0][0][0][0]，A[0][0][0][1]，A[0][0][1][0]，A[0][0][1][1]，<br>A[0][1][0][0]，A[0][1][0][1]，A[0][1][1][0]，A[0][1][1][1]，<br>A[1][0][0][0]，A[1][0][0][1]，A[1][0][1][0]，A[1][0][1][1]，<br>A[1][1][0][0]，A[1][1][0][1]，A[1][1][1][0]，A[1][1][1][1]。<br>（2)按列优先存储：<br>A[0][0][0][0]，A[1][0][0][0]，A[0][1][0][0]，A[1][1][0][0]，<br>A[0][0][1][0]，A[1][0][1][0]，A[0][1][1][0]，A[1][1][1][0]，<br>A[0][0][0][1]，A[1][0][0][1]，A[0][1][0][1]，A[1][1][0][1]，<br>A[0][0][1][1]，A[1][0][1][1]，A[0][1][1][1]，A[1][1][1][1]。<br><img src="https://wkphoto.cdn.bcebos.com/060828381f30e924020ef8525c086e061d95f72f.jpg"></p><p><img src="https://wkphoto.cdn.bcebos.com/d000baa1cd11728b22aee841d8fcc3cec2fd2cd5.jpg"><br><img src="https://wkphoto.cdn.bcebos.com/fcfaaf51f3deb48fbd21c5bde01f3a292df5780c.jpg"></p><p><img src="https://wkphoto.cdn.bcebos.com/ae51f3deb48f8c54a69ba14c2a292df5e0fe7f0c.jpg"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EMove_k</span><span class="params">(<span class="keyword">int</span> A[n], <span class="keyword">int</span> k)</span></span>&#123;<span class="comment">//把数组A的元素循环右移k位，只用一个辅助空间 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">		<span class="keyword">if</span>(n%i==<span class="number">0</span> &amp;&amp; k%i==<span class="number">0</span>)<span class="comment">//求n和k的最大公约数p </span></span><br><span class="line">			p = i;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;p;i++)&#123;</span><br><span class="line">		j = i;</span><br><span class="line">		m = (i+k)%n;</span><br><span class="line">		temp = A[i];</span><br><span class="line">		<span class="keyword">while</span>(m != i)&#123;<span class="comment">//循环右移一步 </span></span><br><span class="line">			A[j] = temp;</span><br><span class="line">			temp = A[m];</span><br><span class="line">			A[m] = A[j];</span><br><span class="line">			j = m;</span><br><span class="line">			m = (j+k)%n;</span><br><span class="line">		&#125;</span><br><span class="line">		A[i] = temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://wkphoto.cdn.bcebos.com/738b4710b912c8fcab7092aeec039245d78821d5.jpg"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 算法1：依题意，先求出每行的最小值元素，放入 min[m] 之中，再求出每列的最大值元素，放入 max[n] 之中，若某元素既在 min[i] 中，又在 max[j] 中，则该元素 A[i][j] 便是马鞍点，找出所有这样的元素，即找到了所有马鞍点。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Get_Saddle1</span><span class="params">(<span class="keyword">int</span> A[m][n])</span></span>&#123;</span><br><span class="line">	have = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;<span class="comment">//计算每行的最小值元素，放入min[m]</span></span><br><span class="line">		min[i] = A[i][<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">			<span class="keyword">if</span>(A[i][j] &lt; min[i])</span><br><span class="line">				min[i] = A[i][j];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;<span class="comment">//计算每列的最大值元素，放入max[m] </span></span><br><span class="line">		max[j] = A[<span class="number">0</span>][j];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)</span><br><span class="line">			<span class="keyword">if</span>(A[i][j] &gt; max[j])</span><br><span class="line">				max[j] = A[i][j];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">			<span class="keyword">if</span>(min[i] == max[j])&#123;<span class="comment">//判定是否为马鞍点 </span></span><br><span class="line">				print(A[i][j]);<span class="comment">//显示马鞍点 </span></span><br><span class="line">				have = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">	<span class="keyword">if</span>(!have)</span><br><span class="line">		print(<span class="string">&quot;没有鞍点\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 算法2：依题意，先求出某行的最小值元素 min，再判断该 min 是否是其所在列的最大值元素，如果是，则该元素便是马鞍点，找出每一行中所有这样的元素，即找到了所有马鞍点。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Get_Saddle2</span><span class="params">(<span class="keyword">int</span> A[m][n])</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(min=A[i][<span class="number">0</span>],j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">			<span class="keyword">if</span>(A[i][j] &lt; min)<span class="comment">//求一行中的最小值 </span></span><br><span class="line">				min = A[i][j];</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">			<span class="keyword">if</span>(A[i][j] == min)&#123;<span class="comment">//判断该最小值是否为马鞍点 </span></span><br><span class="line">				<span class="keyword">for</span>(flag=<span class="number">1</span>,k=<span class="number">0</span>;k&gt;m;k++)</span><br><span class="line">					<span class="keyword">if</span>(min &lt; A[k][j])</span><br><span class="line">						flag = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">if</span>(flag)</span><br><span class="line">					print(A[i][j]);<span class="comment">//显示马鞍点 </span></span><br><span class="line">			&#125;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://wkphoto.cdn.bcebos.com/0b7b02087bf40ad1a14ea380472c11dfa9ecce2f.jpg"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//稀疏矩阵的三元组顺序表存储表示</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 12500 <span class="comment">//假设非零元素个数的最大值为12500 </span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> i,j;<span class="comment">//该非零元的行下标和列下标 </span></span><br><span class="line">	ElemType v;<span class="comment">//非零元值 </span></span><br><span class="line">&#125;Teiple;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	Triple data[MAXSIZE + <span class="number">1</span>];<span class="comment">//非零元三元组，data[0]未用 </span></span><br><span class="line">	<span class="keyword">int</span> mu, nu, tu;<span class="comment">//矩阵的行数、列数和非零元个数 </span></span><br><span class="line">&#125;TSMatrix;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TSMatrix_Add</span><span class="params">(TSMatrix A, TSMatrix B, TSMatrix &amp;C)</span></span>&#123;<span class="comment">//三元组顺序表表示的稀疏矩阵加法 </span></span><br><span class="line">	C.mu = A.mu;</span><br><span class="line">	C.nu = A.nu;</span><br><span class="line">	C.tu = <span class="number">0</span>;</span><br><span class="line">	pa = <span class="number">1</span>;</span><br><span class="line">	pb = <span class="number">1</span>;</span><br><span class="line">	pc = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(row=<span class="number">1</span>;row&lt;=A.mu;row++)&#123;<span class="comment">//对居中的每一行进行相加 </span></span><br><span class="line">		<span class="keyword">while</span>(A.data[pa].i &lt; row &amp;&amp; pa &lt;= A.tu)</span><br><span class="line">			pa++;</span><br><span class="line">		<span class="keyword">while</span>(B.data[pb].i &lt; row &amp;&amp; pb &lt;= B.tu)</span><br><span class="line">			pb++;</span><br><span class="line">		<span class="keyword">while</span>(A.data[pa].i == row &amp;&amp; B.data[pb].i == row &amp;&amp; pa &lt;= A.tu &amp;&amp; pb &lt;= B.tu)&#123;<span class="comment">//行列相等的元素 </span></span><br><span class="line">			<span class="keyword">if</span>(A.data[pa].j == B.data[pb].j)&#123;</span><br><span class="line">				ce = A.data[pa].e + B.data[pb].e;</span><br><span class="line">				<span class="keyword">if</span>(ce)&#123;<span class="comment">//和不为0 </span></span><br><span class="line">					C.data[pc].i = row;</span><br><span class="line">					C.data[pc].j = A.data[pa].j;</span><br><span class="line">					C.data[pc].e = ce;</span><br><span class="line">					pa++;</span><br><span class="line">					pb++;</span><br><span class="line">					pc++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(A.data[pa].j &gt; B.data[pb].j)&#123;</span><br><span class="line">				C.data[pc].i = row;</span><br><span class="line">				C.data[pc].j = B.data[pb].j;</span><br><span class="line">				C.data[pc].e = B.data[pb].e;</span><br><span class="line">				pb++;</span><br><span class="line">				pc++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				C.data[pc].i = row;</span><br><span class="line">				C.data[pc].j = A.data[pa].j;</span><br><span class="line">				C.data[pc].e = A.data[pa].e;</span><br><span class="line">				pa++;</span><br><span class="line">				pc++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(A.data[pa]==row &amp;&amp; pa&lt;=A.tu)&#123;<span class="comment">//插入A中剩余的元素（第row行） </span></span><br><span class="line">			C.data[pc].i = row;</span><br><span class="line">			C.data[pc].j = A.data[pa].j;</span><br><span class="line">			C.data[pc].e = A.data[pa].e;</span><br><span class="line">			pa++;</span><br><span class="line">			pc++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(B.data[pb]==row &amp;&amp; pb&lt;=B.tu)&#123;<span class="comment">//插入B中剩余的元素（第row行） </span></span><br><span class="line">			C.data[pc].i = row;</span><br><span class="line">			C.data[pc].j = B.data[pb].j;</span><br><span class="line">			C.data[pc].e = B.data[pb].e;</span><br><span class="line">			pb++;</span><br><span class="line">			pc++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	C.tu = pc;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="串"><a href="#串" class="headerlink" title="串"></a>串</h2><p><img src="https://wkphoto.cdn.bcebos.com/c2cec3fdfc039245ba36856c9794a4c27c1e25d5.jpg"><br><a target="_blank" rel="noopener" href="https://blog.lvjie.tk/%E7%AE%97%E6%B3%95/KMP%E7%AE%97%E6%B3%95.html">KMP算法详解</a><img src="https://wkphoto.cdn.bcebos.com/9825bc315c6034a86582dce2db13495409237674.jpg"></p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p><img src="https://wkphoto.cdn.bcebos.com/9825bc315c6034a865aadce2db1349540923760c.jpg"><br>可以把排序算法的输出解释为对一个待排序的下标求一种排列，使得序列中的元素按照升序排序。例如，待排序序列是 (a1, a2, … , an)，则输出是这些元素的一个排序。因此，对于一个任意的 n 个元素的序列排序后，可能的输出有 n! 个，即有 n! 个不同的比较路径。在排序过程中，每次比较会有两种情况出现，若整个排序需要进行 t 次比较，则会出现 2t 种情况，于是有：22 ≥ n!，即 t ≥ log2(n!)。当待排序元素个数 n 非常大时，有 t ≥ log2(n!) ≈ nlog2n。</p><p><img src="https://wkphoto.cdn.bcebos.com/35a85edf8db1cb1377215870cd54564e92584b0c.jpg"><br>（1）直接插入排序<br>初始关键字：[503] 017 512 061 908 170 897 275 653 426 154<br>i=2：（017）[017 503] 512 061 908 170 897 275 653 426 154<br>i=3：（512）[017 503 512] 061 908 170 897 275 653 426 154<br>i=4：（061）[017 061 503 512] 908 170 897 275 653 426 154<br>i=5：（908）[017 061 503 512 908] 170 897 275 653 426 154<br>i=6：（170）[017 061 170 503 512 908] 897 275 653 426 154<br>i=7：（897）[017 061 170 503 512 897 908] 275 653 426 154<br>i=8：（275）[017 061 170 275 503 512 897 908] 653 426 154<br>i=9：（653）[017 061 170 275 503 512 653 897 908] 426 154<br>i=10：（426）[017 061 170 275 426 503 512 653 897 908] 154<br>i=11：（154)[017 061 154 170 275 426 503 512 653 897 908]</p><p>（2）希尔排序（增量 d[1]=5 ）<br> 初始关键字：503 017 512 061 908 170 897 275 653 426 154<br>一趟排序结果：154 017 275 061 426 170 897 512 653 908 503<br>二趟排序结果：154 017 275 061 426 170 503 512 653 908 897<br>三趟排序结果：017 061 154 170 275 426 503 512 653 897 908</p><p>（3）快速排序<br> 初始关键字： 503   017   512   061   908   170   897   275   653   426   154<br>一次划分结果： 154   017   426   061   275   170  [503]  897   653   908   512<br>分别快排结果： 061   017  [154]  426   275   170  [503]  897   653   908   512<br>       [017] [061] [154]  426   275   170  [503]  897   653   908   512<br>       [017] [061] [154]  170   275  [426] [503]  897   653   908   512<br>       [017] [061] [154] [170] [275] [426] [503]  897   653   908   512<br>       [017] [061] [154] [170] [275] [426] [503]  512   653  [897] [908]<br>  排序结果：[017] [061] [154] [170] [275] [426] [503] [512] [653] [897] [908]</p><p>（4）堆排序<br> 初始关键字：503 017 512 061 908 170 897 275 653 426  154<br>   初始堆：908 653 897 503 426 170 512 275 061 017  154<br>输出堆顶 908：154 653 897 503 426 170 512 275 061 017 [908]<br>调整后的新堆：897 653 512 503 426 170 154 275 061 017 [908]<br>输出堆顶 897：017 653 512 503 426 170 154 275 061 [897 908]<br>调整后的新堆：653 503 512 275 426 170 154 017 061 [897 908]<br>输出堆顶 653：061 503 512 275 426 170 154 017 [653 897 908]<br>调整后的新堆：512 503 170 275 426 061 154 017 [653 897 908]<br>输出堆顶 512：017 503 170 275 426 061 154 [512 653 897 908]<br>调整后的新堆：503 426 170 275 017 061 154 [512 653 897 908]<br>输出堆顶 503：154 426 170 275 017 061 [503 512 653 897 908]<br>调整后的新堆：426 275 170 154 017 061 [503 512 653 897 908]<br>输出堆顶 426：061 275 170 154 017 [426 503 512 653 897 908]<br>调整后的新堆：275 154 170 061 017 [426 503 512 653 897 908]<br>输出堆顶 275：017 154 170 061 [275 426 503 512 653 897 908]<br>调整后的新堆：170 154 017 061 [275 426 503 512 653 897 908]<br>输出堆顶 170：061 154 017 [170 275 426 503 512 653 897 908]<br>调整后的新堆：154 061 017 [170 275 426 503 512 653 897 908]<br>输出堆顶 154：017 061 [154 170 275 426 503 512 653 897 908]<br>调整后的新堆：061 017 [154 170 275 426 503 512 653 897 908]<br>输出堆顶 061：017 [061 154 170 275 426 503 512 653 897 908]<br>  排序结果：[017 061 154 170 275 426 503 512 653 897 908]</p><p>（5）归并排序<br> 初始关键字：[503] [017] [512] [061] [908] [170] [897] [275] [653] [426] [154]<br>一趟归并之后：[017   503] [061   512] [170   908] [275   897] [426   653] [154]<br>二趟归并之后：[017   061   503   512] [170   275   897   908] [154   426   653]<br>三趟归并之后：[017   061   170   275   503   512   897   908] [154   426   653]<br>四趟归并之后：[017   061   154   170   275   426   503   512   653   897   908]</p><p>（6）基数排序<br>初始关键字： 503 017 512 061 908 170 897 275 653 426 154<br>第一趟分配：Q[0] Q[1] Q[2] Q[3] Q[4] Q[5] Q[6] Q[7] Q[8] Q[9]<br>第一趟分配：170  061  512  503  154  275  426  017  908<br>                 653          897<br>第一趟收集：170 061 512 503 653 154 275 426 017 897 908<br>第二趟分配：Q[0] Q[1] Q[2] Q[3] Q[4] Q[5] Q[6] Q[7] Q[8] Q[9]<br>第二趟分配：503  512  426       653  061  170  897<br>      908  017          154     275<br>第二趟收集：503 908 512 017 426 653 154 061 170 275 897<br>第三趟分配：Q[0] Q[1] Q[2] Q[3] Q[4] Q[5] Q[6] Q[7] Q[8] Q[9]<br>      017  154  275    426  503  653    897  908<br>      061  170          512<br>第三趟收集：017 061 154 170 275 426 503 512 653 897 908</p><p><img src="https://wkphoto.cdn.bcebos.com/f603918fa0ec08fa9eaa77c449ee3d6d55fbda2f.jpg"><br>采用基数排序方法时间复杂度最佳。因为这里英文单词的长度相等，且英文单词是由 26 个字母组成的，满足进行基数排序的条件，同时，依题意，m&lt;&lt;n，基数排序的时间复杂性由 O(m(n+rm)) 变成 O(n)，因此时间复杂性最佳。</p><p><img src="https://wkphoto.cdn.bcebos.com/09fa513d269759eeeffa04a8a2fb43166d22df2f.jpg"><br>（1）当每个记录本身的信息量很大时，应尽量减少记录的移动,直接插入、冒泡和简单选择排序的平均时间复杂度为 O(n2)，但简单选择排序中记录移动的次数最少，所以采用简单选择排序为佳。</p><p>（2）在直接插入、冒泡和简单选择排序中，直接插入和冒泡排序是稳定的，且两者在关键码呈基本正序时都居于最好时间复 O(n)，因此可从中任选一个方法。</p><p>（3）就平均时间性能而言,基于比较和移动的排序方法中快速排序最佳。</p><p>（4）快速排序在最坏情况的时间复杂度为 O(n2)，而堆排序和二路归并排序最坏情况的时间复杂度为 O(nlog2n)，其中堆排序不稳定，所以应选择二路归并排序。</p><p>（5）按照关键码的结构，采用基数排序为好。</p><p><img src="https://wkphoto.cdn.bcebos.com/ca1349540923dd54173bc30bc109b3de9c82480c.jpg"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_INIT_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LISTINCREMENT 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	ElemType *elem;<span class="comment">//存储空间基址 </span></span><br><span class="line">	<span class="keyword">int</span> length;<span class="comment">//当前长度 </span></span><br><span class="line">	<span class="keyword">int</span> listsize;<span class="comment">//当前分配的存储容量以一数据元素存储长度为单位 </span></span><br><span class="line">&#125;SqList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">partition</span><span class="params">(SqList &amp;L)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">1</span>, j = L.length - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">		<span class="keyword">while</span>(i&lt;j &amp;&amp; L.elem[i]%<span class="number">2</span>!=<span class="number">0</span>)</span><br><span class="line">			i++;</span><br><span class="line">		<span class="keyword">while</span>(i&lt;j &amp;&amp; L.elem[j]%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">			j--;</span><br><span class="line">		<span class="keyword">if</span>(i &lt; j)</span><br><span class="line">			L.elem[i]&lt;--&gt;L.elem[j];</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><img src="https://wkphoto.cdn.bcebos.com/ca1349540923dd541713c30bc109b3de9c824874.jpg"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Divide</span><span class="params">(<span class="keyword">int</span> L[], <span class="keyword">int</span> n)</span></span>&#123;<span class="comment">//将L中值为负的记录调到非负的记录之前 </span></span><br><span class="line">	low = <span class="number">0</span>;</span><br><span class="line">	high = n - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">		<span class="keyword">while</span>(low&lt;high &amp;&amp; L[high]&gt;=<span class="number">0</span>)<span class="comment">//以0作为虚拟枢轴 </span></span><br><span class="line">			high--;</span><br><span class="line">		L[low]&lt;--&gt;L[high];</span><br><span class="line">		<span class="keyword">while</span>(low&lt;high &amp;&amp; L[low]&lt;<span class="number">0</span>)</span><br><span class="line">			low++;</span><br><span class="line">		L[low]&lt;--&gt;L[high];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://wkphoto.cdn.bcebos.com/8694a4c27d1ed21b7c4a4a86bd6eddc450da3fd5.jpg"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 设立三个指针 i、j、k，其中：j 表示当前元素，i 以前的元素全部为红色，k 以后的元素全部为蓝色。可以根据 j 的颜色，把其交换到序列的前部或后部。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span>RED, WHITE, BLUE&#125; color;<span class="comment">//三种颜色 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Flag_Arrange</span><span class="params">(color a[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="comment">//把由三种颜色组成的序列重排为按照红、白、蓝的顺序排列</span></span><br><span class="line">	i = <span class="number">0</span>;</span><br><span class="line">	j = <span class="number">0</span>;</span><br><span class="line">	k = n - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(j &lt;= k)&#123;</span><br><span class="line">		<span class="keyword">switch</span>(a[j])&#123;</span><br><span class="line">			<span class="keyword">case</span> RED:</span><br><span class="line">				a[i]&lt;--&gt;a[j];</span><br><span class="line">				i++;</span><br><span class="line">				j++;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> WHITE:</span><br><span class="line">				j++;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> BLUE:</span><br><span class="line">				a[j]&lt;--&gt;a[k];</span><br><span class="line">				k--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; 	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p><img src="https://wkphoto.cdn.bcebos.com/3c6d55fbb2fb4316bbb51e1930a4462309f7d32f.jpg"><br><img src="https://wkphoto.cdn.bcebos.com/574e9258d109b3ded9f7800bdcbf6c81800a4c0c.jpg"></p><p><img src="https://wkphoto.cdn.bcebos.com/d31b0ef41bd5ad6ea87a008991cb39dbb7fd3cd5.jpg"><br><img src="https://wkphoto.cdn.bcebos.com/b3fb43166d224f4af833177019f790529822d12f.jpg"></p><p><img src="https://wkphoto.cdn.bcebos.com/9d82d158ccbf6c81c957488bac3eb13533fa4074.jpg"><br><img src="https://wkphoto.cdn.bcebos.com/ac6eddc451da81cb4165e7ae4266d016082431d5.jpg"></p><p><img src="https://wkphoto.cdn.bcebos.com/472309f790529822af995da0c7ca7bcb0a46d42f.jpg"><br><img src="https://wkphoto.cdn.bcebos.com/50da81cb39dbb6fd28d881451924ab18962b37d5.jpg"></p><p><img src="https://wkphoto.cdn.bcebos.com/d6ca7bcb0a46f21f5d9e3a30e6246b600c33ae2f.jpg"><br><img src="http://inews.gtimg.com/newsapp_ls/0/14439742526/0"></p><p><img src="https://wkphoto.cdn.bcebos.com/80cb39dbb6fd5266aba85877bb18972bd50736d5.jpg"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span></span><br><span class="line">	TElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span><span class="comment">//左右孩子指针 </span></span><br><span class="line">&#125;BiTNode, *BiTree; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> last = <span class="number">0</span>, flag = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Is_BSTree</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">	<span class="comment">//判断二叉树T是否二叉排序树，是则返回1，否则返回0 </span></span><br><span class="line">	<span class="keyword">if</span>(T-&gt;lchild &amp;&amp; flag)</span><br><span class="line">		Is_BSTree(T-&gt;lchild);</span><br><span class="line">	<span class="keyword">if</span>(T-&gt;data &lt; last)<span class="comment">//与其中序前驱相比较 </span></span><br><span class="line">		flag = <span class="number">0</span>;</span><br><span class="line">	last = T-&gt;data;</span><br><span class="line">	<span class="keyword">if</span>(T-&gt;rchild &amp;&amp; flag)</span><br><span class="line">		Is_BSTree(T-&gt;rchild);</span><br><span class="line">	<span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://wkphoto.cdn.bcebos.com/d0c8a786c9177f3e3c54986e60cf3bc79f3d5674.jpg"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span></span><br><span class="line">	TElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span><span class="comment">//左右孩子指针 </span></span><br><span class="line">&#125;BiTNode, *BiTree; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print_NLT</span><span class="params">(BiTree T, <span class="keyword">int</span> x)</span></span>&#123;<span class="comment">//从大到小输出二叉排序树T中所有不小于x的元素 </span></span><br><span class="line">	<span class="keyword">if</span>(T-&gt;lchild)</span><br><span class="line">		Print_NLT(T-&gt;lchild);</span><br><span class="line">	<span class="keyword">if</span>(T-&gt;data &lt; x)<span class="comment">//当遇到小于x的元素时立即结束运行 </span></span><br><span class="line">		<span class="built_in">exit</span>();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, T-&gt;data);</span><br><span class="line">	<span class="keyword">if</span>(T-&gt;rchild)</span><br><span class="line">		Print_NLT(T-&gt;rchild);<span class="comment">//先有后左的中序遍历 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p><img src="https://wkphoto.cdn.bcebos.com/810a19d8bc3eb1357e8fd3d8b61ea8d3fd1f440c.jpg"><br><img src="https://wkphoto.cdn.bcebos.com/6a63f6246b600c336fd3baab0a4c510fd9f9a12f.jpg"></p><p><img src="https://wkphoto.cdn.bcebos.com/d1160924ab18972babb964a9f6cd7b899f510ad5.jpg"></p><p>​ 当 n=2 时，要使其成为最优二叉树，必须使两个结点都成为叶子结点。<br>​ 设 n=k 时成立，则当 n=k+1 时，要使其成为最优，必须用 k 个结点的哈夫曼树与第 k+1 个结点组成一个新的最优二叉树，所以 n=k+1 时也成立。</p><p><img src="https://wkphoto.cdn.bcebos.com/bd3eb13533fa828be96bf980ed1f4134970a5a0c.jpg"><br><img src="https://wkphoto.cdn.bcebos.com/b03533fa828ba61ef8a6ac4c5134970a304e590c.jpg"></p><p><img src="https://wkphoto.cdn.bcebos.com/6609c93d70cf3bc7c060a98fc100baa1cd112a74.jpg"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TREE_SIZE 100	<span class="comment">//二叉树的最大结点数 </span></span></span><br><span class="line"><span class="keyword">typedef</span> TElemType SqBiTree[MAX_TREE_SIZE];<span class="comment">//1号单元存储根结点 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder_Sq</span><span class="params">(SqBiTree BT)</span></span>&#123;<span class="comment">//先序遍历二叉树BT </span></span><br><span class="line">	InitStack(S);</span><br><span class="line">	p = <span class="number">1</span>;<span class="comment">//p指示当前结点的位置 </span></span><br><span class="line">	<span class="keyword">while</span>(p&lt;=n &amp;&amp; !StackEmpty(S))&#123;</span><br><span class="line">		<span class="keyword">while</span>(p &lt;= n)&#123;</span><br><span class="line">			Visit(BT[p]);</span><br><span class="line">			Push(S, p);</span><br><span class="line">			p = <span class="number">2</span> * p;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!StackEmpty(S))&#123;<span class="comment">//栈非空，遍历右子树 </span></span><br><span class="line">			Pop(S, p);</span><br><span class="line">			p = p * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder_Sq_Recursion</span><span class="params">(SqBiTree BT, <span class="keyword">int</span> t, <span class="keyword">int</span> n)</span></span>&#123;<span class="comment">//先序遍历二叉树（递归） </span></span><br><span class="line">	<span class="keyword">if</span>(t &lt;= n)&#123;</span><br><span class="line">		Visit[BT[t]];</span><br><span class="line">		PreOrder_Sq_Recursion(BT, t*<span class="number">2</span>, n);</span><br><span class="line">		PreOrder_Sq_Recursion(BT, t*<span class="number">2</span>+<span class="number">1</span>, n);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://wkphoto.cdn.bcebos.com/a71ea8d3fd1f4134c47f611d351f95cad1c85e0c.jpg"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span></span><br><span class="line">	TElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span><span class="comment">//左右孩子指针 </span></span><br><span class="line">&#125;BiTNode, *BiTree; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LeadCount_BiTree</span><span class="params">(BiTree T)</span></span>&#123;<span class="comment">//求二叉树中叶子结点的数目 </span></span><br><span class="line">	<span class="keyword">if</span>(!T)<span class="comment">//空树，没有叶子 </span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">if</span>(!T-&gt;lchild &amp;&amp; !T-&gt;rchild)<span class="comment">//叶子结点 </span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span><span class="comment">//左、右子树的叶子数相加 </span></span><br><span class="line">			<span class="keyword">return</span> LeadCount_BiTree(T-&gt;lchild) + LeadCount_BiTree(T-&gt;rchild);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><img src="https://wkphoto.cdn.bcebos.com/1b4c510fd9f9d72a8ece747ec42a2834349bbb2f.jpg"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span></span><br><span class="line">	TElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span><span class="comment">//左右孩子指针 </span></span><br><span class="line">&#125;BiTNode, *BiTree; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NodeCount_BiTree</span><span class="params">(BiTree T)</span></span>&#123;<span class="comment">//求二叉树中所有结点的数目 </span></span><br><span class="line">	<span class="keyword">if</span>(!T)<span class="comment">//空树，没有叶子 </span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> num1 = NodeCount_BiTree(T-&gt;lchild);</span><br><span class="line">		<span class="keyword">int</span> num2 = NodeCount_BiTree(T-&gt;rchild);</span><br><span class="line">		<span class="keyword">return</span> num1 + num2 + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><img src="https://wkphoto.cdn.bcebos.com/e7cd7b899e510fb38a9a13f4c933c895d0430cd5.jpg"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span></span><br><span class="line">	TElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span><span class="comment">//左右孩子指针 </span></span><br><span class="line">&#125;BiTNode, *BiTree; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BranchCount_BiTree</span><span class="params">(BiTree T)</span></span>&#123;<span class="comment">//求二叉树中所有单分支结点数目 </span></span><br><span class="line">	<span class="keyword">if</span>(!T)<span class="comment">//空树，没有叶子 </span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> num1 = NodeCount_BiTree(T-&gt;lchild);</span><br><span class="line">		<span class="keyword">int</span> num2 = NodeCount_BiTree(T-&gt;rchild);</span><br><span class="line">		<span class="keyword">if</span>((!T-&gt;lchild &amp;&amp; T-&gt;rchild) || (T-&gt;lchild &amp;&amp; !T-&gt;rchild))</span><br><span class="line">			<span class="keyword">return</span> num1 + num2 + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> num1 + num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><img src="https://wkphoto.cdn.bcebos.com/314e251f95cad1c8fff398446f3e6709c93d510c.jpg"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span></span><br><span class="line">	TElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span><span class="comment">//左右孩子指针 </span></span><br><span class="line">&#125;BiTNode, *BiTree; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Revolute_BiTree</span><span class="params">(BiTree T)</span></span>&#123;<span class="comment">//交换所有结点的左右子树 </span></span><br><span class="line">	Swap(T-&gt;lchild, T-&gt;rchild);<span class="comment">//交换左右子树 </span></span><br><span class="line">	<span class="keyword">if</span>(T-&gt;lchild)</span><br><span class="line">		Revolute_BiTree(T-&gt;lchild);<span class="comment">//左子树交换自己的左右子树 </span></span><br><span class="line">	<span class="keyword">if</span>(T-&gt;rchild)</span><br><span class="line">		Revolute_BiTree(T-&gt;rchild);<span class="comment">//右子树交换自己的左右子树 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://wkphoto.cdn.bcebos.com/738b4710b912c8fcab9392aeec039245d6882174.jpg"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span></span><br><span class="line">	TElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span><span class="comment">//左右孩子指针 </span></span><br><span class="line">&#125;BiTNode, *BiTree; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Get_Sub_Depth</span><span class="params">(BiTree T, <span class="keyword">int</span> x)</span></span>&#123;<span class="comment">//求二叉树中以值为x的结点为根的子树深度 </span></span><br><span class="line">	<span class="keyword">if</span>(T-&gt;data == x)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(Get_Depth(T));<span class="comment">//找到了值为x的结点，求其深度 </span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(T-&gt;lchild)<span class="comment">//在左子树中继续寻找 </span></span><br><span class="line">			Get_Sub_Depth(T-&gt;lchild, x);</span><br><span class="line">		<span class="keyword">if</span>(T-&gt;rchild)<span class="comment">//在右子树中继续寻找 </span></span><br><span class="line">			Get_Sub_Depth(T-&gt;rchild, x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Get_Depth</span><span class="params">(BiTree T)</span></span>&#123;<span class="comment">//求子树深度的递归算法 </span></span><br><span class="line">	<span class="keyword">if</span>(!T)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		m = Get_Depth(T-&gt;lchild);</span><br><span class="line">		n = Get_Depth(T-&gt;rchild);</span><br><span class="line">		<span class="keyword">return</span> (m&gt;n?m:n) + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://wkphoto.cdn.bcebos.com/d01373f082025aaf2bb11aa8ebedab64024f1ad5.jpg"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span></span><br><span class="line">	TElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span><span class="comment">//左右孩子指针 </span></span><br><span class="line">&#125;BiTNode, *BiTree; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NR_PreOrder</span><span class="params">(BiTree bt)</span></span>&#123;<span class="comment">//非递归先序遍历二叉树 </span></span><br><span class="line">	InitStack(S);</span><br><span class="line">	<span class="keyword">if</span>(!bt)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	p = bt;</span><br><span class="line">	<span class="keyword">while</span>(p || !StackEmpty(S))&#123;</span><br><span class="line">		<span class="keyword">while</span>(p)&#123;<span class="comment">//到达最左边的结点 </span></span><br><span class="line">			Visit(p-&gt;data);<span class="comment">//访问结点的数据域 </span></span><br><span class="line">			Push(S, p);<span class="comment">//将当前指针p压栈 </span></span><br><span class="line">			p = p-&gt;lchild;<span class="comment">//指针指向p的左孩子 </span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!StackEmpty(S))&#123;</span><br><span class="line">			Pop(S, p);<span class="comment">//从栈中弹出栈顶元素 </span></span><br><span class="line">			p = p-&gt;rchild;<span class="comment">//指针指向p的右孩子结点 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://wkphoto.cdn.bcebos.com/37d3d539b6003af3c110b803252ac65c1038b62f.jpg"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateBiTree2</span><span class="params">(BiTree &amp;T,<span class="keyword">char</span> str[])</span></span>&#123;<span class="comment">//建立二叉树链表(非递归)广义表 </span></span><br><span class="line">	</span><br><span class="line">	BiTree S[<span class="number">1000</span>];<span class="comment">//存放父节点 </span></span><br><span class="line">	<span class="keyword">int</span> flag = <span class="number">0</span>;<span class="comment">//存入为左孩子还是右孩子，1为左孩子，2为右孩子 </span></span><br><span class="line">	<span class="keyword">int</span> k = <span class="number">0</span>;<span class="comment">//记入前一个父节点的存放位置 </span></span><br><span class="line">	BiTree p;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	p = (BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));<span class="comment">//申请根节点的空间 </span></span><br><span class="line">	p-&gt;data = str[<span class="number">0</span>];</span><br><span class="line">	p-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">	p-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;str[i] != <span class="string">&#x27;#&#x27;</span>;i++)&#123;</span><br><span class="line">		<span class="comment">//printf(&quot;1\n&quot;);</span></span><br><span class="line">		<span class="keyword">if</span>(str[i] == <span class="string">&#x27;(&#x27;</span>)&#123;<span class="comment">//将父节点存放入数组中，并且下一个存放左孩子 </span></span><br><span class="line">			flag = <span class="number">1</span>;</span><br><span class="line">			S[k++] = p;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">&#x27;,&#x27;</span>)&#123;<span class="comment">//下一个为存放右孩子 </span></span><br><span class="line">			flag = <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">&#x27;)&#x27;</span>)&#123;<span class="comment">//将一个父节点出数组 </span></span><br><span class="line">			k--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			</span><br><span class="line">			p = (BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));<span class="comment">//申请一个孩子的空间 </span></span><br><span class="line">			p-&gt;data = str[i];</span><br><span class="line">			p-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">			p-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">			<span class="keyword">if</span>(flag == <span class="number">1</span>)&#123;<span class="comment">//左孩子 </span></span><br><span class="line">				S[k<span class="number">-1</span>]-&gt;lchild = p;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(flag == <span class="number">2</span>)&#123;<span class="comment">//右孩子 </span></span><br><span class="line">				S[k<span class="number">-1</span>]-&gt;rchild = p;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	T = S[<span class="number">0</span>];<span class="comment">//将根返回 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Level_Order</span><span class="params">(BiTree BT)</span></span>&#123;<span class="comment">//按层次、非递归遍历二叉树 </span></span><br><span class="line">	<span class="keyword">if</span>(!BT)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	InitQueue(Q);</span><br><span class="line">	p = BT;<span class="comment">//初始化 </span></span><br><span class="line">	EnQueue(Q, p);<span class="comment">//访问根结点，并将根结点入队 </span></span><br><span class="line">	<span class="keyword">while</span>(!QueueEmpty(Q))&#123;<span class="comment">//当队非空时重复执行下列操作 </span></span><br><span class="line">		DeQueue(Q, p);<span class="comment">//出队 </span></span><br><span class="line">		Visit(p);</span><br><span class="line">		<span class="keyword">if</span>(!p-&gt;lchild)</span><br><span class="line">			EnQueue(Q, p-&gt;lchild);<span class="comment">//处理左孩子 </span></span><br><span class="line">		<span class="keyword">if</span>(!p-&gt;rchild)</span><br><span class="line">			EnQueue(Q, p-&gt;rchild);<span class="comment">//处理右孩子 </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://wkphoto.cdn.bcebos.com/a686c9177f3e67099548219c2bc79f3df8dc550c.jpg"><br>假设此二叉树总结点数为 n，度为 0 的结点数为 n0，度为 1 的结点数为 n1，度为 2 的结点数为 n2，则：n = n0 + n1 + n2（1）<br>在二叉树中，除了根结点外，其余结点都有一个分支进入，设 B 为分支总数，则：n = B + 1，由于这些分支是由度为 1 或度为 2 的结点射出的，所以有：B = n1 + 2n2，于是有：n = n1 + 2n2 + 1（2）<br>由（1）和（2)可得：n0 = n2 + 1<br>证毕。</p><p><img src="https://wkphoto.cdn.bcebos.com/c8177f3e6709c93d2dba6a948f3df8dcd100540c.jpg"><br>假设此二叉树的深度为 k，根据二叉树性质 2 及完全二叉树的定义得到：2k-1-1&lt;n≤2k-1，即 2k-1≤n&lt;2k<br>于是 k-1≤log2n&lt;k<br>即 k = ⌊log2n⌋ + 1。</p><p><img src="https://wkphoto.cdn.bcebos.com/c83d70cf3bc79f3d98a98053aaa1cd11728b290c.jpg"><br>（1）第 H 层上的结点数目为 k^H-1^。<br>（2）如果 p 是其双亲的最小的孩子（右孩子），则 p 减去根结点的一个结点，应是 k 的整数倍，该整数即为所在的组数，每一组为一棵满 k 叉树，正好应为双亲结点的编号。如果 p 是其双亲的最大的孩子（左孩子），则 p+k-1 为其最小的弟弟，再减去一个根结点，除以 k，即为其双亲结点的编号。<br>综合来说，对于 p 是左孩子的情况，i=(p+k-1)/k；对于 p 是右孩子的情况，i=(p-1)/k，如果左孩子的编号为 p，则其右孩子编号必为 p+k-1 ，所以，其双亲结点的编号为 i=⌊(p+k-2)/k⌋，向下取整。<br>（3）结点 p 的右孩子的编号为 kp+1，左孩子的编号为 kp+1-k+1=k(p-1)+2，第 i 个孩子的编号为 k(p-1)+2+i-1=kp-k+i+1。<br>（4）当(p-1)%k != 0时，结点 p 有右兄弟，其右兄弟的编号为 p+1。</p><p><img src="https://wkphoto.cdn.bcebos.com/eac4b74543a9822651424f449a82b9014b90ebd6.jpg"><br>根据树的定义，在一棵树中，除树根结点外，每个结点有且仅有一个前驱结点，也就是说，每个结点与指向它的一个分支一一对应，所以除树根结点之外的结点树等于所有结点的分支数，即度数，从而可得树中的结点数等于所有结点的度数加 1。总结点数为：1+n1+2n2+3n3+…+knk<br>度为 0 的结点数应为总结点数减去度不为 0 的结点数的总和，即<br>n0 = 1+n1+2n2+3n3+…+knk-(n1+n2+n3+…+nk)</p><p><img src="https://wkphoto.cdn.bcebos.com/8326cffc1e178a8218bf1bc3e603738da877e8d6.jpg"><br><img src="https://wkphoto.cdn.bcebos.com/b3b7d0a20cf431adda77275a5b36acaf2edd982f.jpg"></p><p><img src="https://wkphoto.cdn.bcebos.com/cb8065380cd791239e45f017bd345982b2b7802f.jpg"><br><img src="https://wkphoto.cdn.bcebos.com/fd039245d688d43fe9e1f5916d1ed21b0ef43b0c.jpg"></p><p><img src="https://wkphoto.cdn.bcebos.com/1e30e924b899a901f0b63f550d950a7b0308f5d6.jpg"><br><img src="https://wkphoto.cdn.bcebos.com/03087bf40ad162d9366d067f01dfa9ec8b13cdd6.jpg"></p><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><p><img src="https://wkphoto.cdn.bcebos.com/0eb30f2442a7d93340e08010bd4bd11373f0010c.jpg"><br><img src="https://wkphoto.cdn.bcebos.com/d01373f082025aaf2b7a1aa8ebedab64034f1a0c.jpg"></p><p><img src="https://wkphoto.cdn.bcebos.com/f703738da97739121446e102e8198618367ae275.jpg"><br><img src="https://wkphoto.cdn.bcebos.com/54fbb2fb43166d2298f471f7562309f79152d2d6.jpg"></p><p><img src="https://wkphoto.cdn.bcebos.com/9825bc315c6034a86547dce2db1349540923762f.jpg"><br>数学归纳法<br>  当 n=2 时，图G连通只需一条边，命题成立。<br>  设 n=k(k&gt;2) 时命题成立，即当 n=k 时，图G至少有 k-1 条边。<br>  当 n=k+1(k2) 时，由上述假设可知，图G中已有 k 个顶点是连通的，且至少有 k-1 条边。现增加一个顶点 p 后，若 p 与图中已有的 k 个顶点没有边，显然 p 与图 G 不连通。若要求 k+1 个顶点组成的图是连通图，p 必须与图 G 原有的 k 个顶点中的任何一个顶点有边相连，即 k 条边就可使图连通。因此，当 n=k+1 时，图 G 至少有 k 条边，命题成立。证毕。</p><p><img src="https://wkphoto.cdn.bcebos.com/35a85edf8db1cb1377cc5870cd54564e92584b2f.jpg"><br><img src="https://wkphoto.cdn.bcebos.com/6a600c338744ebf8f0f2005cc9f9d72a6159a7d6.jpg"><br><img src="https://wkphoto.cdn.bcebos.com/9358d109b3de9c8297c09dec7c81800a19d8432f.jpg"></p><p><img src="https://wkphoto.cdn.bcebos.com/a8773912b31bb051516cd74b267adab44aede00d.jpg"></p><p><img src="https://wkphoto.cdn.bcebos.com/3bf33a87e950352a38e2416b4343fbf2b3118bd6.jpg"></p><p><img src="https://wkphoto.cdn.bcebos.com/4bed2e738bd4b31c3674f0d897d6277f9e2ff80d.jpg"><br>关键路径只有一条：（α，G，H，K，J，E，ω)<br><img src="https://wkphoto.cdn.bcebos.com/241f95cad1c8a786908f2e6d7709c93d70cf502f.jpg"></p><p><img src="https://wkphoto.cdn.bcebos.com/94cad1c8a786c91725a6365ad93d70cf3bc7572f.jpg"></p></div><div class="article-licensing box"><div class="licensing-title"><p>数据结构白皮书复习题</p><p><a href="http://gushengliang.github.io/数据结构/数据结构白皮书复习题.html">http://gushengliang.github.io/数据结构/数据结构白皮书复习题.html</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><a href="http://gushengliang.github.io"><p>lvjie</p></a></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2022-01-19</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2022-02-10</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="recommend-area"><div class="recommend-post"><span class="is-size-6 has-text-grey has-mr-7"># 相关文章</span><br><span>  1.<a class="is-size-6" href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91.html" target="_blank">红黑树</a><br></span><span>  2.<a class="is-size-6" href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E8%BD%AC%E7%BD%AE%E7%AE%97%E6%B3%95.html" target="_blank">稀疏矩阵转置算法</a><br></span><span>  3.<a class="is-size-6" href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5%E4%B8%8E%E5%88%A0%E9%99%A4.html" target="_blank">二叉排序树的插入与删除</a><br></span><span>  4.<a class="is-size-6" href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84.html" target="_blank">关键路径</a><br></span><span>  5.<a class="is-size-6" href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8E%86%E5%B9%B4%E8%AF%95%E9%A2%98.html" target="_blank">数据结构历年试题</a><br></span><span>  6.<a class="is-size-6" href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3.html" target="_blank">结构体和指针详解</a><br></span><span>  7.<a class="is-size-6" href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A4%B4%E6%8F%92%E6%B3%95%E5%92%8C%E5%B0%BE%E6%8F%92%E6%B3%95%E5%BB%BA%E7%AB%8B%E5%8D%95%E9%93%BE%E8%A1%A8.html" target="_blank">头插法和尾插法建立单链表</a><br></span></div><div class="recommend-post"><span class="is-size-6 has-text-grey has-mr-7"># 推荐文章</span><br><span>  1.<a class="is-size-6" href="/git/Git%E5%91%BD%E4%BB%A4%E6%B8%85%E5%8D%95.html" target="_blank">Git命令清单</a><br></span><span>  2.<a class="is-size-6" href="/git/%E8%A7%A3%E5%86%B3Git%E6%8F%90%E4%BA%A4%E6%B2%A1%E6%9C%89%E6%9D%83%E9%99%90.html" target="_blank">解决Git提交没有权限</a><br></span><span>  3.<a class="is-size-6" href="/math/%E4%BA%8C%E9%98%B6%E5%B8%B8%E7%B3%BB%E6%95%B0%E7%BA%BF%E6%80%A7%E9%9D%9E%E9%BD%90%E6%AC%A1%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E7%9A%84%E9%80%9A%E8%A7%A3%E5%92%8C%E7%89%B9%E8%A7%A3.html" target="_blank">二阶常系数线性非齐次微分方程的通解和特解</a><br></span><span>  4.<a class="is-size-6" href="/node/node%E5%92%8Cnpm%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE.html" target="_blank">node和npm安装配置</a><br></span><span>  5.<a class="is-size-6" href="/themes/github-Issue-%E4%BD%9C%E4%B8%BA%E5%8D%9A%E5%AE%A2%E5%BE%AE%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%BA%94%E7%94%A8.html" target="_blank">github Issue 作为博客微型数据库的应用</a><br></span><span>  6.<a class="is-size-6" href="/themes/%E4%BD%BF%E7%94%A8Github%20Action%E5%AE%9E%E7%8E%B0%E5%85%A8%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.html" target="_blank">使用Github Action实现全自动部署</a><br></span></div></div><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/social-share.js/1.0.16/css/share.min.css"><div class="social-share"></div><script src="https://cdnjs.loli.net/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="https://wkphoto.cdn.bcebos.com/fcfaaf51f3deb48fbde8c5bde01f3a292cf578cb.jpg" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="https://wkphoto.cdn.bcebos.com/e61190ef76c6a7efe568cc45edfaaf51f3de6602.jpg" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5%E4%B8%8E%E5%88%A0%E9%99%A4.html"><i class="level-item fas fa-chevron-left"></i><span class="level-item">二叉排序树的插入与删除</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84.html"><span class="level-item">关键路径</span><i class="level-item fas fa-chevron-right"></i></a></div></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="is-flex is-mobile" href="#时间复杂度"><span>时间复杂度</span></a></li><li><a class="is-flex is-mobile" href="#逻辑图和逻辑结构"><span>逻辑图和逻辑结构</span></a></li><li><a class="is-flex is-mobile" href="#线性表"><span>线性表</span></a></li><li><a class="is-flex is-mobile" href="#栈和队列"><span>栈和队列</span></a></li><li><a class="is-flex is-mobile" href="#数组"><span>数组</span></a></li><li><a class="is-flex is-mobile" href="#串"><span>串</span></a></li><li><a class="is-flex is-mobile" href="#排序"><span>排序</span></a></li><li><a class="is-flex is-mobile" href="#查找"><span>查找</span></a></li><li><a class="is-flex is-mobile" href="#树"><span>树</span></a></li><li><a class="is-flex is-mobile" href="#图"><span>图</span></a></li></ul></div></div><style>.menu-list>li>a.is-active+.menu-list{display:block}.menu-list>li>a+.menu-list{display:none}</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://wkphoto.cdn.bcebos.com/f2deb48f8c5494eec36c6b7a3df5e0fe99257e02.jpg" alt="顾笙凉"></figure><p class="title is-size-4 is-block" style="line-height:inherit">顾笙凉</p><p class="is-size-6 is-block">尚未执佩剑，转眼即江湖</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>河南安阳</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">25</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">9</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">26</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://weibo.com/gushengliang" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/gushengliang/gushengliang.github.io"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Weibo" href="https://weibo.com/gushengliang"><i class="fab fa-weibo"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Email" href="mailto:lvjie@163.com"><i class="fa fa-envelope"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div><div><hr><p id="hitokoto">:D 一言句子获取中...</p><script defer>function getYiyan(){$.getJSON("https://v1.hitokoto.cn/",(function(o){o&&($("#hitokoto").html(""),$("#hitokoto").append("<strong style='color: #3273dc;'>"+o.hitokoto+"</strong><p>来源《"+o.from+"》</p><p>提供者-"+o.creator+"</p>"))}))}$((function(){getYiyan(),$("#hitokoto").click((function(){getYiyan()}))}))</script></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li><li><a class="level is-mobile" href="https://infernojs.org/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">inferno</span></span><span class="level-right"><span class="level-item tag">infernojs.org</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><figure class="media-left"><a class="image" href="/themes/%E4%BD%BF%E7%94%A8Github%20Action%E5%AE%9E%E7%8E%B0%E5%85%A8%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.html"><img src="https://wkphoto.cdn.bcebos.com/b3fb43166d224f4af879177019f790529922d1f5.jpg" alt="使用Github Action实现全自动部署"></a></figure><div class="media-content"><p class="date"><time datetime="2022-02-09T10:04:34.000Z">2022-02-09</time></p><p class="title"><a href="/themes/%E4%BD%BF%E7%94%A8Github%20Action%E5%AE%9E%E7%8E%B0%E5%85%A8%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.html">使用Github Action实现全自动部署</a></p><p class="categories"><a href="/categories/themes/">themes</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/git/Git%E5%91%BD%E4%BB%A4%E6%B8%85%E5%8D%95.html"><img src="https://wkphoto.cdn.bcebos.com/adaf2edda3cc7cd9954e50ba2901213fb80e9175.jpg" alt="Git命令清单"></a></figure><div class="media-content"><p class="date"><time datetime="2022-01-26T17:54:51.000Z">2022-01-26</time></p><p class="title"><a href="/git/Git%E5%91%BD%E4%BB%A4%E6%B8%85%E5%8D%95.html">Git命令清单</a></p><p class="categories"><a href="/categories/git/">git</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F.html"><img src="https://wkphoto.cdn.bcebos.com/500fd9f9d72a6059cab885793834349b033bba2d.jpg" alt="内网穿透"></a></figure><div class="media-content"><p class="date"><time datetime="2022-01-26T16:50:17.000Z">2022-01-26</time></p><p class="title"><a href="/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F.html">内网穿透</a></p><p class="categories"><a href="/categories/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/">内网穿透</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91.html"><img src="https://wkphoto.cdn.bcebos.com/f31fbe096b63f6248d3d5d609744ebf81a4ca375.jpg" alt="红黑树"></a></figure><div class="media-content"><p class="date"><time datetime="2022-01-20T16:15:18.000Z">2022-01-20</time></p><p class="title"><a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91.html">红黑树</a></p><p class="categories"><a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E8%BD%AC%E7%BD%AE%E7%AE%97%E6%B3%95.html"><img src="https://wkphoto.cdn.bcebos.com/71cf3bc79f3df8dcb098ebf2dd11728b4710282f.jpg" alt="稀疏矩阵转置算法"></a></figure><div class="media-content"><p class="date"><time datetime="2022-01-20T10:50:08.000Z">2022-01-20</time></p><p class="title"><a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E8%BD%AC%E7%BD%AE%E7%AE%97%E6%B3%95.html">稀疏矩阵转置算法</a></p><p class="categories"><a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/Math/"><span class="level-start"><span class="level-item">Math</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/git/"><span class="level-start"><span class="level-item">git</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/node/"><span class="level-start"><span class="level-item">node</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/themes/"><span class="level-start"><span class="level-item">themes</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/tools/"><span class="level-start"><span class="level-item">tools</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"><span class="level-start"><span class="level-item">内网穿透</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span class="level-start"><span class="level-item">数据结构</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">算法</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><span class="level-start"><span class="level-item">计算机网络</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2022/02/"><span class="level-start"><span class="level-item">二月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2022/01/"><span class="level-start"><span class="level-item">一月 2022</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2021/12/"><span class="level-start"><span class="level-item">十二月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2021/09/"><span class="level-start"><span class="level-item">九月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2021/08/"><span class="level-start"><span class="level-item">八月 2021</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><a class="level is-mobile is-marginless" href="/archives/"><span class="level-start"><span class="level-item">查看全部&gt;&gt;</span></span></a></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/themes/"><span class="tag">themes</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Chrome/"><span class="tag">Chrome</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/PicGo/"><span class="tag">PicGo</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Typora/"><span class="tag">Typora</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AF%95%E9%A2%98/"><span class="tag">试题</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/KMP/"><span class="tag">KMP</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/LeetCode/"><span class="tag">LeetCode</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/NAT/"><span class="tag">NAT</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/TCP/"><span class="tag">TCP</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/auto-deploy/"><span class="tag">auto deploy</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/git/"><span class="tag">git</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/git%E5%91%BD%E4%BB%A4/"><span class="tag">git命令</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/node/"><span class="tag">node</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/npm/"><span class="tag">npm</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%B8%89%E5%85%83%E7%BB%84/"><span class="tag">三元组</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/"><span class="tag">二叉排序树</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/"><span class="tag">关键路径</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E7%A7%AF%E5%88%86%E5%AD%A6/"><span class="tag">多元函数微积分学</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BF%AB%E9%80%9F%E8%BD%AC%E7%BD%AE/"><span class="tag">快速转置</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%8C%87%E9%92%88/"><span class="tag">指针</span><span class="tag is-grey-lightest">1</span></a></div></div><div class="field is-grouped is-grouped-multiline"><a class="tags has-addons" href="/tags/"><span class="tag">查看全部&gt;&gt;</span></a></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="https://wkphoto.cdn.bcebos.com/96dda144ad345982bfec81f11cf431adcbef846a.jpg" alt="lvjie&#039;blog" height="28"></a><p class="size-small"><span>&copy; 2022 lvjie</span>  Powered by <a href="https://bulma.io/" target="_blank">Bulma</a> &amp; <a href="https://infernojs.org/" target="_blank">Inferno</a><br><span>© 版权说明：[本网站所有内容均自己创作,<br>&nbsp;&nbsp;&nbsp;&nbsp;方便于网友与自己学习交流]<br></span><span><span id="statistic-times">loading...</span><script>function createTime(n){var t=new Date(n);now.setTime(now.getTime()+250),days=(now-t)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-t)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-t)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-t)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("statistic-times").innerHTML="❤️本站自 <strong>"+n.split(" ")[0].replace(/\//g,".")+"</strong> 已运行 <strong>"+dnum+"</strong> 天 <strong>"+hnum+"</strong> 小时 <strong>"+mnum+"</strong> 分 <strong>"+snum+"</strong> 秒！❤️"}var now=new Date;setInterval("createTime('2020/10/11 00:00:00')",250,"")</script><br></span></p><div class="size-small"><span>❤️感谢 <strong><span id="busuanzi_value_site_uv">99+</span></strong> 小伙伴的 <strong><span id="busuanzi_value_site_pv">99+</span></strong> 次光临！❤️</span></div><p></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/gushengliang/gushengliang.github.io"><i class="fab fa-github"></i></a></p></div><div class="sideMusic"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="/js/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script><meting-js style="width:auto;height:2000px" server="netease" type="playlist" id="2364053447" theme="#2980b9" loop autoplay order="list" storagename="aplayer-setting" lrctype="0" list-max-height="400px" fixed="true"></meting-js></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" async></script><script>moment.locale("zh-CN")</script><script>var IcarusThemeSettings={article:{highlight:{clipboard:!0,fold:"unfolded"}}}</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load",()=>{"function"==typeof $.fn.lightGallery&&$(".article").lightGallery({selector:".gallery-item"}),"function"==typeof $.fn.justifiedGallery&&($(".justified-gallery > p > .gallery-item").length&&$(".justified-gallery > p > .gallery-item").unwrap(),$(".justified-gallery").justifiedGallery())})</script><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener("DOMContentLoaded",(function(){loadInsight({contentUrl:"/content.json"},{hint:"想要查找什么...",untitled:"(无标题)",posts:"文章",pages:"页面",categories:"分类",tags:"标签"})}))</script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js"></script><script>var pjax=new Pjax({elements:"a",selectors:[".section","title"],cache:!0,cacheBust:!1});function loadBusuanzi(){$.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",(function(){}))}function loadMathJax(){$.getScript("//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML",(function(){MathJax.Hub.Config({tex2jax:{inlineMath:[["$","$"],["(",")"]]}});var n=document.getElementsByClassName("entry-content")[0];MathJax.Hub.Queue(["Typeset",MathJax.Hub,n])}))}document.addEventListener("pjax:send",(function(){})),document.addEventListener("pjax:complete",(function(){$(".section").css({opacity:1}),loadMainJs(jQuery,window.moment,window.ClipboardJS,window.IcarusThemeSettings),loadBackTop(),loadBusuanzi(),"function"==typeof loadBanner&&loadBanner()}))</script><script async>window.onload=function(){var e=document.createElement("script"),t=document.getElementsByTagName("script")[0];e.type="text/javascript",e.async=!0,e.src="/sw-register.js?v="+Date.now(),t.parentNode.insertBefore(e,t)}</script></body></html>