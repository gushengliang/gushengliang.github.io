{"pages":[],"posts":[{"title":"Git命令清单","text":"一般来说，日常使用只要记住下图6个命令，就可以了。 Workspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库 新建代码库12345678# 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url] 配置Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 123456789# 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name &quot;[name]&quot;$ git config [--global] user.email &quot;[email address]&quot; 增加/删除文件123456789101112131415161718192021# 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed] 代码提交123456789101112131415161718# 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 分支123456789101112131415161718192021222324252627282930313233343536373839404142# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 标签1234567891011121314151617181920212223242526# 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag] 查看信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat &quot;@{0 day ago}&quot;# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog 远程同步1234567891011121314151617181920212223# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all 撤销12345678910111213141516171819202122232425262728293031# 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]# 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop","link":"/git/Git%E5%91%BD%E4%BB%A4%E6%B8%85%E5%8D%95.html"},{"title":"解决Git提交没有权限","text":"第一次提交会出现Git提交没有权限： 解决方法首先在termital终端输入： 1ssh-keygen -t rsa -C &quot;username&quot; (注：username为你git上的用户名) 对于提示信息全部按下Enter键。 使用以下命令查看生成的SSH key : 1cat /User/username/.ssh/id_rsa.pub 把显示出来的SSH keys直接添加到github账户设置里边的SSH keys，ssh-rsa 也需要加进去。最后就可以正常执行git提交命令了。","link":"/git/%E8%A7%A3%E5%86%B3Git%E6%8F%90%E4%BA%A4%E6%B2%A1%E6%9C%89%E6%9D%83%E9%99%90.html"},{"title":"二阶常系数线性非齐次微分方程的通解和特解","text":"有二阶常系数线性非齐次微分方程 1. 如果 g(t) 里有指数函数，在特解里也要用相同的指数函数。 例: 先把方程设齐次： 然后解通解:通解:然后解特解：带入原方程：特解:最后: 2. 如果 g(t) 是多项式，在特解里要用通用相同次数的多项式。 例: 通解:然后解特解：代入原方程：化简，比较系数得：特解:最后: 3. 如果 g(t) 里含有cos或者sin函数，特解里要用cos和sin函数。 例: 通解:然后解特解：代入原方程:化简，比较系数得：特解:最后: 4. 如果 g(t) 是n个函数相加，那么要把方程拆分成n个部分，依次求特解。得：对以上的n个微分方程依次求特解。 例: 通解:然后解特解：特解:最后: 5. 列出预选的特解，一定要和通解进行比较。如果预选特解中和通解中出现重复项，那么要在特解上乘以t，直到不再出现重复项。 例： 通解：由于因此初选特解但是 yp 和 yc 中第一项相同，那么要在 yp 乘以 t ，得， 但是 yp 和 yc 中第二项也相同，那么再乘以 t ，得， 把特解和通解再比较，没有重复了。特解选好了。代入原方程得：特解：最后： 6. 如果 g(t) 是两个或两个以上函数相乘，那么特解中要用 g(t) 中每个函数对应的特解相乘来求解。 例： 通解：g(t)是由几个函数相乘再相加所得，先要把它拆分开来。是由二次多项式和sin函数相乘所得。特解中要用通用二次多项式、cos和sin函数。设特解和通解比较，发现 Ccos(3t)​ 和 Fsin(3t) 和通解有相同项。那么，要在 yp1基础上乘以 t ，得：即再比较，没有相同项了。然后， 是由指数函数和cosine函数相乘所得。特解中要用指数函数、cos和sin函数。设特解然后和通解 yc​ 比较，没有相同项。最后： 总结： 如果 g(t) 中出现指数函数 (e^at^)，在特解里也要用相同的指数函数。 如果 g(t) 是多项式，在特解里要用通用相同次数的多项式。 如果 g(t) 里出现任意一个cos或者sin函数，特解里要用cos和sin函数。 如果 g(t) 是n个函数相加， ，那么要把方程拆分成n个部分，依次求特解。 列出预选的特解，一定要和通解先进行比较。如果预选特解中和通解中出现重复项，那么要在特解上乘以 t ，直到不再出现重复项。 如果 g(t) 是两个或两个以上函数相乘，那么特解中要用 g(t) 中每个函数对应的特解相乘来求解。","link":"/math/%E4%BA%8C%E9%98%B6%E5%B8%B8%E7%B3%BB%E6%95%B0%E7%BA%BF%E6%80%A7%E9%9D%9E%E9%BD%90%E6%AC%A1%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E7%9A%84%E9%80%9A%E8%A7%A3%E5%92%8C%E7%89%B9%E8%A7%A3.html"},{"title":"数学一元函数和多元函数连续可导与可微关系","text":"数学一元函数和多元函数连续可导与可微关系","link":"/math/%E6%95%B0%E5%AD%A6%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0%E5%92%8C%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E8%BF%9E%E7%BB%AD%E5%8F%AF%E5%AF%BC%E4%B8%8E%E5%8F%AF%E5%BE%AE%E5%85%B3%E7%B3%BB.html"},{"title":"node和npm安装配置","text":"安装 下载地址：https://nodejs.org/zh-cn/download/ 下载之后是pkg，下载完成后，双击安装包，开始安装，一直点继续即可。安装路径默认为： 执行命令 node -v查看node版本，能看到版本号，说明安装成功，执行npm -v查看npm版本。 设置国内的镜像为默认镜像源加速npm npm config set registry=http://registry.npm.taobao.org 修改包路径： 默认情况下包的默认存放路径为： /usr/local/lib/node_modules，可以通过命令 npm root -g 查看。 不想让下载在默认目录下，再其他盘新建两个文件夹：/opt/modules/node/node_global 用于全局包下载存放/opt/modules/node/node_cache node缓存修改路径，执行以下两条命令： 12npm config set prefix &quot;/opt/modules/node/node_global&quot;npm config set cache &quot;/opt/modules/node/node_cache&quot; 查看npm配置信息： 1npm config list 清空npm缓存: 1npm cache clean -f 设置环境变量，由于 node_global 的路径改变了，所以要设置环境变量，查看npm全局包可执行文件路径: 1npm -g bin 显示(not in PATH env variable)表示没有在环境变量，需要添加到环境变量： 1vi ~/.bash_profile 在终端添加：PATH=$PATH:/opt/modules/node/node_global/bin 关闭终端再次使用npm -g bin命令检查发现已经添加成功。 以后下载全局包就会放在我们设置的目录中了。 卸载node在安装后无法实现使用命令行卸载，需要手动删除一些文件夹。 删除/usr/local/lib中的所有node和node_modules 删除/usr/local/lib中的所有node和node_modules的文件夹 如果是从brew安装的, 运行brew uninstall node 检查~/中所有的local, lib或者include文件夹, 删除里面所有node和node_module 在/usr/local/bin中, 删除所有node的可执行文件 最后运行以下代码: 1sudo rm /usr/local/bin/npm 1sudo rm /usr/local/share/man/man1/node.1 1sudo rm /usr/local/lib/dtrace/node.d 1sudo rm -rf ~/.npm 1sudo rm -rf ~/.node-gyp 1sudo rm /opt/local/bin/node 1sudo rm /opt/local/include/node 1sudo rm -rf /opt/local/lib/node_modules 1sudo rm /usr/local/${i} 1sudo rm -rf /usr/local/include/node /Users/$USER/.npm 1sudo rm -rf /var/db/receipts/org.nodejs.* 运行完毕后，重启终端，输入以下命令，查看是否卸载完毕 node npm","link":"/node/node%E5%92%8Cnpm%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE.html"},{"title":"Typora利用PicGo同步图片","text":"将 Typora 结合到 PicGo 上，就可以直接复制图片到 Typora 时，就会给你自动上传了。 配置好后，可以点击验证图片上传，这里有一个点需要注意：那就是上传使用的端口号36677要和软件的 PicGo 设置的是一致的，否则将无法成功。","link":"/tools/Typora%E5%88%A9%E7%94%A8PicGo%E5%90%8C%E6%AD%A5%E5%9B%BE%E7%89%87.html"},{"title":"chrome实验性功能","text":"Chrome 之所以被认为是「超级应用」，很大程度上在于起功能增添和更新上像极了操作系统，新功能会首先出现在 Dev 版、然后经过 Beta 测试后，最后推送到稳定通道中。而新开发的功能则被隐藏在 Chrome flags —— 作为新功能的试验田，通过开启特定的 flags 来在稳定版中尝鲜新功能，即可以尝鲜也避免了可能的不稳定风险，下面我挑选了一些稳定性尚可且比较实用的 flags。 并行下载开启方法： chrome://flags/#enable-parallel-downloading 找到 Parallel downloading 并启用来开启 Chrome 的并行下载功能。 标签页分组开启方法： chrome://flags/#tab-groups-save 找到含有 Tab Groups 的选项启用。 当你打开一堆标签页时，右击标签页会出现下图，点击向新群组中添加标签页即可创建分组。","link":"/tools/chrome%E5%AE%9E%E9%AA%8C%E6%80%A7%E5%8A%9F%E8%83%BD.html"},{"title":"图片上传picgo工具github配置使用","text":"摘要对于每一个写文章的人来说，图片是至关重要。这一路经历了多次图片的烦恼，之前选择了微博个人文章那里粘贴图片的方式上传，感觉也挺方便的。但是由于新浪的图片显示问题，如果header中不设置 标签就不能异步访问图片，导致图裂，那之恶心。然而设置之后又与网站访客统计的插件冲突，使之不能统计，真是神仙打架。无赖之下使用了PicGo工具，使用后感觉真香！ PicGo工具下载安装配置下载PicGo下载 github网站提供三个版本的下载，MacOs、linux、windows覆盖市面上90%系统，还是很给力了。 配置 PicGo配置(使用github图传，免费方便，同时配合github.io真是方便) 选上必填的就ok,一开始不知道token的设置，附赠token获取方法 图片上传相关的设置 链接格式：选择适合自己的，一般用户md文件中，选第一个，然后就可以疯狂使用了。 使用github图传，获取token在github-&gt;setting-&gt;developer settings 选择generate new token 勾选好之后生成就好了 使用 PicGo使用，简直方便 1).默认网页上直接右键复制图片 2).点击等待中的图片，开始上传 3).上传完之后有个提示，同时粘贴板也会自动粘贴上 4).直接粘贴到想要的地方 或者也可以直接截图，然后点击图片里的图片上传，很方便 PicGo上传动图gif 如果直接复制网页上的动图，去上传的话是截取的某帧，是静图。应该下载到本地，然后在拖进去上传就可以了。","link":"/tools/%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0picgo%E5%B7%A5%E5%85%B7github%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8.html"},{"title":"谷歌Chrome浏览器默认https加载导致图片不显示","text":"自Chrome83版本开始，Chrome浏览器默认阻止混合内容MixContent的下载加载等。（即https网站中的http协议加载的内容）最终导致很多未配置静态资源SSL证书的网站在加载图片等http内容时失败，最终导致图片加载不出来等问题。 图片如果是http格式的会被Chrome认为是不安全的内容，同时Chrome在网站设置中默认时屏蔽不安全内容的，最终导致http内容加载失败。用户可以通过更改设置，允许不安全内容，当然这样也有浏览器被攻击的风险。 切换以后图片可以正常显示。","link":"/tools/%E8%B0%B7%E6%AD%8CChrome%E6%B5%8F%E8%A7%88%E5%99%A8%E9%BB%98%E8%AE%A4https%E5%8A%A0%E8%BD%BD%E5%AF%BC%E8%87%B4%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA.html"},{"title":"内网穿透","text":"很多时候，我们在本地完成的一些项目是别人不可见的，开通内网穿透就可以在任何地方给客户展示，同时也免去了部署的麻烦，没准可以少加一会班儿呢！ 关于内网穿透 内网穿透,又叫NAT穿透，是计算机用语，翻译过来就是 你的电脑可以直接被你朋友访问。 通常实现内网穿透，是通过路由器上端口映射来实现的。但是路由器通常不是每个人都有权限可以访问和设置,而且可能存在多级路由器较为复杂的网络结构。 目前内网穿透的关于软件不少：frp,nps,ngrok，花生壳，向日葵，natapp等，但收费，不收费的不好用。于是就有钉钉开放平台团队在GitHub上开源了 钉钉内网穿透，免费，开源，支持自定义子域名。 钉钉内网穿透工具配置 clone git仓库 mac用户进入mac_64，windows用户进入windows_64，Linux用户进入linux。执行以下命令： 123./ding -config=./ding.cfg -subdomain=xxxx 8080#注意xxxx是你启动命令的subdomain参数有可能被别人占用，尽量不要用常用字符，可以用自己公司名的拼音，例如：alibaba、dingding等。#xxxx直接关系到你接下来的域名地址默认会生成xxxx.vaiwan.com 测试启动完客户端后，你访问http://xxxx.vaiwan.com/xx都会映射到 http://127.0.0.1:8080/xx","link":"/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F.html"},{"title":"二叉排序树的插入与删除","text":"二叉排序树的概念二叉排序树又被成为二叉搜索树、二叉查找树，简称 BST（Binary Search/Sort Tree）树。满足以下性质的二叉树就是二叉排序树： 若左子树不为空，则左子树上左右节点的值都小于根节点的值 若它的右子树不为空，则它的右子树上所有的节点的值都大于根节点的值 它的左右子树也要分别是二叉搜索树 二叉排序树的插入 如果二叉树为空，则直接插入。 如果要插入的元素已经存在，则不再进行插入。 如果能找到合适的位置，则插入成为叶子结点： 二叉排序树的删除 如果要删除的结点没有子结点，则直接删除。 如果要删除的结点只有一个子结点，则直接用孩子结点代替删除的结点。 如果要删除的结点有两个子结点： 1）中序遍历要删除的结点。 2）用前驱或后继直接替换掉要删除的结点。（前驱和后继都可以）","link":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5%E4%B8%8E%E5%88%A0%E9%99%A4.html"},{"title":"关键路径","text":"用顶点表示事件，弧表示活动，弧上的权值表示活动持续的时间的有向图叫AOE（Activity On Edge Network）网 。AOE网常用于估算工程完成时间。 关键路径求解：","link":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84.html"},{"title":"头插法和尾插法建立单链表","text":"线性表结点结构1234typedef struct LNode { //定义单链表结构类型 ElemType data; //数据域 struct LNode *next; //指针域}LNode, *LinkList; 头插法 核心：新结点的指针域指向头结点下一个结点的数据域。头结点的指针域指向新结点的数据域。 s-&gt;next = L-&gt;next; L-&gt;next = s; 算法如下： 12345678910111213141516LinkList List_HeadInsert(LinkList &amp;L){ LNode *s; int x; L = (LInkList)malloc(sizeof(LNode)); //创建头结点 L-&gt;next = NULL; //初始为空链表 scanf(&quot;%d&quot;, &amp;x); //输入结点的值 while(x != 9999) //输入9999表示结束 { s = (LNode*)malloc(sizeof(LNode)); //创建新结点 s-&gt;data = x; //新结点赋值 s-&gt;next = L-&gt;next; //将新结点指向头结点的下一个结点 L-&gt;next = s; //将新结点插入表中，L为头指针 scanf(&quot;%d&quot;, &amp;x); } //while结束 return L;} 尾插法 核心：尾结点的指针域指向新结点的数据域。尾结点指向新结点的数据域。尾结点（此时为新结点）的指针域指向空。 r-&gt;next = s; r = s; r-&gt;next = NULL; 算法如下： 1234567891011121314151617LinkList CreatList2(LinkList &amp;L){ int x; //设元素类型为整型 L = (LinlList)malloc(sizeof(LNode)); LNode *s, *r = L; //r为表尾指针 scanf(&quot;%d&quot;, &amp;x); //输入结点的值 while(x != 9999) //输入9999表示结束 { s = (LNode *)malloc(sizeof(LNode)); s-&gt;data = x; //新结点赋值 r-&gt;next = s; //将尾结点指向新结点 r = s; //将r指向新的表尾结点 scanf(&quot;%d&quot;, &amp;x); } r-&gt;next = NULL; //尾结点指针置空 return L;}","link":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A4%B4%E6%8F%92%E6%B3%95%E5%92%8C%E5%B0%BE%E6%8F%92%E6%B3%95%E5%BB%BA%E7%AB%8B%E5%8D%95%E9%93%BE%E8%A1%A8.html"},{"title":"稀疏矩阵转置算法","text":"三元组一般来说，对于稀疏矩阵，我们使用三元组来存储。也就是将矩阵的所有非零元素用三元组顺序表的形式表示。每个三元组包括的信息有： i非零元素的行下标，三元组的行标。j非零元素的列下标，三元组的列标。v元素值。mu矩阵的行数，三元组的最大行标。nu矩阵的列数，三元组的最大列标。tu矩阵非零元素的总个数，三元组的总行数。 三元组顺序表的定义： 123456789# define MAXSIZE 12500 // 最大的非零元素个数typedef struct{ int i,j; // 分别表示非零元素的行下标和列下标 ElemType v; // 元素值}Triple;typedef struct{ Triple data[MAXSIZE + 1]; // 所有的非零元素， data[0]未用，data表示三元组 int mu, nu, tu; // 矩阵的行数、列数和总共的非零元素个数}TSMatrix; 转置转置需要经历以下三个步骤： 将矩阵的行列值相互交换； 将每个三元组中的 i 和 j 相互调换； 重排三元组之间的次序便可实现矩阵的转置。 普通转置算法思想： 行列数先互换，将M的元素数赋值给T的元素数。 按三元组的方式扫描：每个列标需要扫描所有的三元组，如果原矩阵的三元组列标等于设置递增的列标，则为扫描到一条，将原三元组的列值赋值给转置后三元组的行值，原三元组的行值赋值给转置后三元组的列值，原三元组的元素值赋值给转置后三元组的元素值。 123456789101112131415Status TransposeSMatrix(TSMatrix M, TSMatrix &amp;T){ //采用三元组表存储表示，求稀疏矩阵M的转置矩阵T，算法时间复杂度为O(nu * tu) T.mu = M.nu; T.nu = M.mu; T.tu = M.tu; if(T.tu){ q = 1; for(col=1; col&lt;=M.nu; col++)//n是列数 for(p=1; p&lt;=M.tu; p++) if(M.data[p].j == col){ T.data[q].i = M.data[p].j; T.data[q].j = M.data[p].i; T.data[q].v = M.data[p].v; q++; } }} 快速转置算法思想： 要想扫描一次 M 就能得到 T，必须每次扫描到一个三元组就直接将其放到转置三元组中相应的位置上。num 和cpot，分别用于存储矩阵 M 中每一列的非零元素个数和矩阵 M 中每一列第一个非零元素在 T 中的存储位置。有如下公式成立： cpot[1] = 1cpot[col] = cpot[col - 1] + num[col - 1], 2 &lt;= col &lt;= M.nu 行列数先互换，将M的元素数赋值给T的元素数。 计算每列非零元的个数：先将num数组初始化为0，然后扫描一遍三元组，将三元组列标对应的num数组作加一处理，这样就能得到M中的每一列含有非零元个数。 求第col列中第一个非零元在转置后三元组中的序号：从第二列开始，每列的copt等于前一列的copt加上前一列的num。第一列的 cpot[1] = 1。 遍历一遍三元组，取出原矩阵三元组的列标和在转置后三元组中的位置，将原三元组的列值赋值给转置后三元组的行值，将原三元组的行值赋值给转置后三元组的列值，将原三元组的元素值赋值给转置后三元组的元素值。每次赋值完以后要将对应列的copt值加1。 12345678910111213141516171819202122Status FastTransposeSMatrix(TSMatrix M, TSMatrix &amp;T){ //采用三元组表存储表示，求稀疏矩阵M的转置矩阵T，算法时间复杂度为O(nu + tu) T.mu = M.nu; T.nu = M.mu; T.tu = M.tu; if(T.tu){ for(col=1; col&lt;= M.nu; col++) num[col] = 0; for(t=1; t&lt;=M.tu; t++) num[M.data[t].j]++; //求M中每一列含非零元个数 cpot[1] = 1; //求第col列中第一个非零元在b.data中的序号 for(col=2; col&lt;=M.nu; col++) cpot[col] = cpot[col-1] + num[col-1]; for(p=1; p&lt;=M.tu; p++){ col = M.data[p].j; //col是原矩阵三元组的列标 q = cpot[col]; //q是在转置后三元组第一个非零元的位置 T.data[q].i = M.data[p].j; T.data[q].j = M.data[p].i; T.data[q].v = M.data[p].v; cpot[col]++; } }}","link":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E8%BD%AC%E7%BD%AE%E7%AE%97%E6%B3%95.html"},{"title":"红黑树","text":"红黑树红黑树（英语：Red–black tree）是一种自平衡二叉查找树，红黑树相对于AVL树来说，牺牲了部分平衡性以换取插入/删除操作时少量的旋转操作，整体来说性能要优于AVL树。红黑树具有以下性质: 节点是红色或黑色。 根是黑色。 所有叶子都是黑色（叶子是NIL节点）。 每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。） 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。 旋转和变色由于插入或者旋转会打破红黑树的性质，所以需要变色和旋转来维持红黑树的性质和平衡。变色只需将黑色结点变为红色或将红色结点变为黑色。旋转操作分为左旋和右旋：对结点4进行左旋：左旋后：对结点7进行右旋：右旋后： 插入 插入结点是根节点（插入前是一棵空树）：直接把插入结点涂为黑色。 插入结点的父结点是黑色的：直接插入。 插入结点的父结点是红色的： 1）插入结点Z的叔结点是红色：将父结点和叔结点设为黑色，祖父结点设为红色。将祖父结点设为当前红色结点继续操作。2）插入结点Z的叔结点是黑色且当前结点是父亲结点的右孩子：将父亲结点作为新的当前结点并以新的当前结点为支点进行左旋，将插入结点Z原来的父亲结点和祖父结点变色。3)插入结点Z的叔结点是黑色且当前结点是父亲结点的左孩子：以插入结点Z的父节点为支点向右旋转，会得到情况2)，再进行2)的操作即可。 删除红黑树的删除基于二叉搜索树的性质。 删除的是红色结点：不会破坏红黑树的性质，直接删除。 删除的是黑色结点：1）待删除结点(X)的兄弟结点是黑色，且其(W)子结点都是黑色：将待删除结点的兄弟结点变为红色，再以待删除结点的父结点开始作为迭代对象继续进行修复操作，直到迭代对象成为根节点或为红色时为止，最后再把迭代对象变为黑色来保证不会出现相邻的红色结点。2）待删除结点(X)的兄弟结点是黑色，其(W)右子结点是红色：将待删除结点的兄弟结点变色为和待删除结点的父结点同色，再将待删除结点的兄弟结点的父结点和右子结点变为黑色，最后把待删除结点的父结点进行左旋。 3）待删除结点(X)的兄弟结点是黑色，其(W)子结点左红右黑：先交换待删除结点的兄弟结点和其左子结点的颜色，再以待删除结点的兄弟结点为支点进行右旋，这时会变成情况2）。 4）待删除结点(X)的兄弟结点是红色：交换待删除结点的兄弟结点和待删除结点的父结点的颜色，再以待删除结点的父结点为支点进行左旋，这样就转化为以上三种情况之一。","link":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91.html"},{"title":"结构体和指针详解","text":"结构型和指针型：结构型​ 结构型可以理解为用户用基本类型为原料制作的数据类型，比如数组是由多个相同数据类型的变量组合起来的。但是如果要用到不同的数据类型该怎么办呢？这时候就用到结构体了。结构体可以制作新的数据类型，即可以用系统已经有的不同的基本数据类型或用户定义的结构型来组合成用户需要的复杂数据类型。 指针型​ 指针型变量里装的是变量的地址，通过指针可以找出这个变量在内存中的位置。指针型变量的定义是在变量名之前加了一个 *。*a是取变量a的内容，&amp;a是取变量a的地址。语句a = &amp;b是将变量b的地址存于变量a中，即我们常说的指针a指向b。 结点的构造 ​ 指针型用的最多的就是和结构型结合起来构造节点（如链表的结点、二叉树的结点等）。 链表结点的定义 ​ 链表的结点有两个域：一个是数据域，用来存放数据；另一个是指针域，用来存放下一个结点的位置。 ​ 链表结点的结构型定义如下： 12345typedef struct Node{ int data; struct Node *next; //指向Node型变量的指针}Node; 结构体名字为Node，结构体成员有一个是用自己来定义的和自己类型相同的变量的指针（struct Node *next）。 二叉树结点的定义 ​ 在链表结点结构型的基础上，再加上一个指向自己同一类型变量的指针域，即二叉树结点结构型。 123456typedef struct BTNode { int data; struct BTNode *lchild; //指向左孩子结点指针 struct BTNode *rchild; //指向右孩子结点指针}BTNode; 利用空间申请函数申请一个结点空间：BT = (BTNode*)malloc(sizeof(BTNode)); 一般来说，用结构体变量直接取分量，其操作用“.”；用指针结构体变量的指针来去分量，其操作用“-&gt;”，-&gt;是结构体指针运算符。 关于 typedef 和 #define typedef ​ typedef可以理解为给现有的数据类型起一个新名字。如typedef struct{...} TypeA即给struct{...}起了一个新名字TypeA。 #define ​ #define定义常量，以达到更人性化、更容易理解的目的。如： 1234#define ERROR 1#define OK 0#define bool STATUS#define int ELEMTYPE","link":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3.html"},{"title":"KMP算法","text":"求得模式串中相等的前缀和后缀的最大长度，前缀是除了最后一个字符外的全部头部组合，后缀是除了第一个字符外的全部尾部组合 根据最大长度去求 next 数组，next数组相当于最大长度值整体向右移动一位，然后初始值赋为 -1。 开始将模式串P和文本串的字母一个个进行匹配，第 1 个匹配成功，第二个没有匹配成功，将模式串索引值为当前 next 数组值的元素移动到失配位置。 移动以后该位置仍然不匹配： 再将模式串索引值为当前 next 数组值的元素移动到失配位置。这里next值为 -1。移动以后发现匹配。 一直匹配移动到如下位置不匹配： 再将模式串索引值为当前 next 数组值的元素移动到失配位置。这里next值为 2。移动以后发现匹配。 一直到最后匹配成功。 注：next[j] 的含义是：在子串的第 j 个字符与主串发生失配时，则跳到主串的 next[j] 位置重新与主串当前失配位置进行比较。","link":"/%E7%AE%97%E6%B3%95/KMP%E7%AE%97%E6%B3%95.html"},{"title":"最大值","text":"给定一组非负整数 nums，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。 注意：输出结果可能非常大，所以你需要返回一个字符串而不是整数。 示例1： 输入：nums = [10,2]输出：”210” 示例2： 输入：nums = [3,30,34,5,9]输出：”9534330” 实现思路 使用排序方法进行比较时，比较两个字符串（设为A和B），以先后顺序拼接而成的两个字符串A+B和B+A，如果A+B更大，则A在前B在后，否则A在后B在前。由于int型数组没有自定义排序的功能，字符串有自定义的排序，那么我们首先将原数组转化为字符串数组。采用外部排序接口Comparator，对compare方法传入(a, b)，返回(b+a).compareTo(a+b)。若b+a &gt; a+b结果为1，并排序交换a和b的位置；若b+a &lt; a+b则不交换。 代码实现 123456789101112131415161718192021222324public String largestNumber(int[] nums) { String[] strArr = new String[nums.length]; //数字数组转为字符串数组 for (int i = 0; i &lt; nums.length; i++) { strArr[i] = String.valueOf(nums[i]); } //自定义两个相连的字符串排序 Arrays.sort(strArr, new Comparator&lt;String&gt;() { @Override public int compare(String o1, String o2) { return (o2 + o1).compareTo(o1 + o2); } }); StringBuilder sb = new StringBuilder(); //防止出现了[0,0]的情况，此时返回&quot;0&quot; if (strArr[0].equals(&quot;0&quot;)) { return &quot;0&quot;; } //字符数组转为字符串 for (String temp : strArr) { sb.append(temp); } return sb.toString(); } 注： compare用来比较排序两个参数，如果比较结果为1进行交换，其他不进行交换。当后一个对象比当前对象大（o2.compareTo(o1) &gt;0），返回结果值为1时，前后交换，说明是降序排列。当后一个对象比当前对象小（o1.compareTo(o2) &gt; 0），返回结果值为1时，前后交换，说明是升序排列。","link":"/%E7%AE%97%E6%B3%95/%E6%9C%80%E5%A4%A7%E5%80%BC.html"},{"title":"TCP的三次握手和四次挥手","text":"TCP协议是7层⽹络协议中的传输层协议，负责数据的可靠传输。 在建⽴TCP连接时，需要通过三次握⼿来建⽴，过程是： 客户端向服务端发送⼀个SYN 服务端接收到SYN后，给客户端发送⼀个SYN_ACK 客户端接收到SYN_ACK后，再给服务端发送⼀个ACK 在断开TCP连接时，需要通过四次挥⼿来断开，过程是： 1. 客户端向服务端发送FIN 2. 服务端接收FIN后，向客户端发送ACK，表示我接收到了断开连接的请求，客户端你可以不发数据了， 不过服务端这边可能还有数据正在处理 3. 服务端处理完所有数据后，向客户端发送FIN，表示服务端现在可以断开连接 4. 客户端收到服务端的FIN，向服务端发送ACK，表示客户端也会断开连接了","link":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.html"},{"title":"Spring","text":"SpringSpring简介==Spring是一个轻量级的控制反转（IOC）和面向切面编程（AOP）的框架== Spring组成 Spring Boot 一个快速开发的脚手架。 基于SpringBoot可以快速开发单个微服务。 SpringCloud SpringCloud基于SpringBoot实现的。 现在大多数公司都在使用SpringBoot进行快速开发，学习SpringBoot的前提，需要完全掌握Spring及SpringMVC。 IOCIOC理论控制反转 IOC 是一种设计思想，个人认为所谓控制反转就是获取依赖对象的方式反转了。 控制：谁来控制对象的创建。传统的应用程序是由程序本身控制创建的，使用Spring后，对象是由Spring来创建的。 反转：程序本身不创建对象，而变成被动的接收对象。 比如通过set接口使得程序不再具有主动性，而是变成了被动的接受对象。控制器不再是在程序猿手上，而是在用户手上，程序猿不用在去管理对象的创建了，系统的耦合性大大降低~ UserDao123456private UserDao userDao;//利用set进行动态实现对象的注入public void setUserDao(userDao userDao) { this.userDao = userDao;} 解耦过程： IOC本质控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IOC容器，其实现方法是依赖注入（Dependency Injection，DI）。依赖注入：就是利用set方法来实现注入的。 配置文件12345678910&lt;!--使用Spring来创建对象，在Spring中对象成为Bean--&gt;&lt;!--传统式声明：类型 变量名 = new 类型(); Hello hello = new Hello(); 在bean中，id相当于变量名，name是给bean取的别名，class相当于new的对象(类)：包名+类。 property相当于给对象(类)中的属性设置一个值，调用的是对象中的set方法。其中value是基本数据类型赋值，ref是对象赋值。 ref：引用在Spring容器中创建好的对象。--&gt;&lt;bean id=&quot;hello&quot; class=&quot;com.lvjie.pojo.Hello&quot; name=&quot;hello1&quot;&gt; &lt;property name=&quot;str&quot; value=&quot;Spring&quot; ref=&quot;hello&quot;/&gt;&lt;/bean&gt; 使用Spring容器获取对象： MyTest12345//获取Spring的上下文对象ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);//我们的对象都在Spring中管理了，要使用的话直接取出来就可以Hello hello = (hello) context.getBean(&quot;hello&quot;);System.out.println(hello.toString()); IOC创建对象的方式 使用无参构造创建对象，默认！ 使用有参构造创建对象(假设构造方法含有一个参数) 下标赋值 下标赋值123&lt;bean id=&quot;user&quot; class=&quot;com.lvjie.pojo.User&quot;&gt; &lt;constructor-arg index=&quot;0&quot; value=&quot;lvjie&quot;/&gt;&lt;/bean&gt; 类型(不推荐，可能类型重复) 类型123&lt;bean id=&quot;user&quot; class=&quot;com.lvjie.pojo.User&quot;&gt; &lt;constructor-arg type=&quot;java.lan.String&quot; value=&quot;lvjie&quot;/&gt;&lt;/bean&gt; 参数名 参数名123&lt;bean id=&quot;user&quot; class=&quot;com.lvjie.pojo.User&quot;&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;lvjie&quot;/&gt;&lt;/bean&gt; Spring配置导入jar包依赖123456&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.3.0&lt;/version&gt;&lt;/dependency&gt; 别名alis可以给bean取一对一别名，name可以bean取多个名字 importimport一般用于团队开发使用，可以将多个配置文件导入合并为一个总的，使用的时候直接使用总的配置就可以了。 依赖注入（DI)构造器注入见IOC创建对象的方式 Set注入【重点】 依赖注入本质是Set注入,包括有： bean | ref | list | set | map | props | value p/c命名空间注入123&lt;!--需要线引入第三方约束--&gt;xmlns:p=&quot;http://www.springframework.org/schema/p&quot;xmlns:c=&quot;http://www.springframework.org/schema/c&quot; P/C命名空间1234&lt;!--p命名空间注入可以直接注入属性的值--&gt;&lt;bean id=&quot;user&quot; class=&quot;com.lvjie.pojo.User&quot; p:name=&quot;lvjie&quot; p:age=&quot;18&quot;/&gt;&lt;!--c命名空间注入需要先有参构造器，通过构造器注入：construct-args--&gt;&lt;bean id=&quot;user2&quot; class=&quot;com.lvjie.pojo.User&quot; c:name=&quot;lvjie&quot; c:age=&quot;18&quot;/&gt; bean的作用域 单例模式（Spring默认模式）：每次从容器中get的对象是同一个。 单例模式1&lt;bean id=&quot;user&quot; class=&quot;com.lvjie.pojo.User&quot; scope=&quot;singleton&quot;/&gt; 原型模式：每次从容器中get的时候，都会产生一个新对象。 原型模式1&lt;bean id=&quot;user&quot; class=&quot;com.lvjie.pojo.User&quot; scope=&quot;prototype&quot;/&gt; 其余的request、session、application、这些只能在 web开发中使用到。 Bean的自动装配自动装配是Spring满足bean依赖的一种方式，Spring会在上下文中自动寻找，并给bean装配属性。在Spring中有三种装配的方式： 在xml中显示的配置 在Java中显示的配置 隐式的自动装配bean【重要】 byName/byType自动装配byName1234&lt;!--byName: 会自动在容器上下文中查找，和自己对象set方法里面的值对应的beanid!--&gt;&lt;bean id=&quot;people&quot; class=&quot;com.lvjie.pojo.People&quot; autowire=&quot;byName&quot; &lt;proprerty name=&quot;name&quot; value=&quot;lvjie&quot;/&gt;&lt;/bean&gt; byType1234&lt;!--byType: 会自动在容器上下文中查找，和自己对象属性类型相同的bean!--&gt;&lt;bean id=&quot;people&quot; class=&quot;com.lvjie.pojo.People&quot; autowire=&quot;byType&quot; &lt;proprerty name=&quot;name&quot; value=&quot;lvjie&quot;/&gt;&lt;/bean&gt; 小结：byName的时候，需要保证所有的bean的id唯一，并且这个bean需要和自动注入的属性的set方法里面的值一致。byType的时候，需要保证所有的bean的class唯一，并且这个bean需要和自动注入的属性的类型一致。 使用注解自动装配要使用注解需要：导入约束（context）、配置注解的支持（context:annotati on-config）、在对象属性前或set方法前加入@Autowired。 配置文件12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/springcontext.xsd&quot; &lt;context:annotation-config&gt;&lt;/beans&gt; 实体类12345678public class People { @Autowired private Cat cat; //@Autowired //public Cat setCate(){ // return cat; //}} 注解是用反射来实现的。使用Autowired我们可以不用编写Set方法了。 @Autowired默认通过byType方式实现，而且必须要求这个对象存在。【常用】 如果Autowired不唯一自动装配属性(当有多个对象时），则需要通过@Qualifier(value=“xxx”) @Resource默认通过byName方式实现，如果找不到名字，则通过byType实现。如果两个都找不到的情况下就报错。 @Autowired(required = false) 字段标记了注解说明这个对象可以为null。@Nullable 字段标记这个字段可以为null。 使用注解开发bean要使用注解开发，必须要保证aop的包导入了使用注解需要导入context约束，增加注解的支持。 spring配置文件123456789101112&lt;?xml version=”1.O” encoding=”UTF-8”?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;f xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--指定要扫描的包，这个包下的注解就会生效--&gt; &lt;context:component-scan base-package=&quot;com.lvjie.pojo&quot;/&gt; &lt;context:annotation-config/&gt;&lt;/beans&gt; @Component注解等价于&lt;bean id=&quot;user&quot; class=&quot;com.lvjie.pojo.Uer&quot;/&gt; 属性注入@Value(&quot;lvjie&quot;)注解相当于&lt;property name=&quot;name&quot; value=&quot;lvjie&quot;/&gt; 实体类123456789@Componentpublic class User { public String name; @Value(&quot;lvjie&quot;) public void setName(String name) { this.name = name; }} 衍生注解@Component 有几个衍生注解：但功能都相当于@Component，都代表将某个类注册到Spring中，对应分层对应注解名称使用。 dao层注解【@Repository】 service层注解【@Service】 controller层注解 【@Controller】 作用域@Scope(&quot;xxx&quot;)注解使用在类前相当于bean的作用域。 小结xml 适用于任何场合，维护简单方便。注解 不是自己的类不能使用。 xml 与注解 最佳实践： xml用来管理bean 注解只负责完成属性的注入 使用Java的方式配置Spring实体类12345678910111213141516171819//这里这个注解的意思，就是说明这个类被Spring接管了，注册到了容器中@Componentpublic class User { private string name; public string getName (){ return name; } @Value(&quot;lvjie&quot;) //属性注入值 public void setName(String name) { this.name = name; } @override pub1ic string toString() f return &quot;User{&quot; + &quot;name='&quot; + name + '\\' +'}'; }} 配置文件1234567891011121314151617181920package com.lvjie.config;import com.lvjie.pojo.User;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Import;// 这个也会Spring容器托管，注册到容器中，因为他本来就是一个@Component// @Configuration代表这是一个配置类，就和我们之前看的beans.xm1@Configuration@ComponentScan(&quot;com.lvjie.pojo&quot;) @Import(lvjieConfig2.class)pub1ic class KuangConfig { //注册一个bean，就相当于我们之前写的一个bean标签 //这个方法的名字，就相当于bean标签中的id属性 //这个方法的返回值，就相当于bean标签中的class属性 @Bean pub1ic User user(){ return new user(); //就 是返回要注入到bean的对象! }} MyTest12345678public class MyTest {public static void main(String[] args) { //如果完全使用了配置类方式去做，我们就只能通过AnnotationConfig上下文来获取容器，通过配置类的class对象加载! Applicationcontext context = new AnnotationConfigApplicationContext (lvjieConfig.class); User getUser = (User) context. getBean(&quot;user&quot;); System.out.println(getUser.getName()); }} 这种纯Java的配置方式，在SpringBoot中随处可见！ 代理模式静态代理 代理模式的好处： 可以使真实角色的操作更加纯粹，不用取关注一些公共的业务 公共业务就交给代理角色，实现了业务的分工 公共业务发生扩展时，方便集中管理 缺点： 一个真实角色就会产生一个代理角色，代码量会翻倍，开发效率会变低~ 动态代理可以解决以上缺点。 动态代理 动态代理和静态代理角色一样 动态代理的代理类是动态生成的，不是我们直接写好的 动态代理分为两大类:基于接口的动态代理和基于类的动态代理 基于接口 ——— JDK动态代理 基于类 ——— cglib Java字节码实现 ——— javasist 需要了解两个类：Proxy：代理；InvocationHandler：调用处理程序。 ProxyInvocationHandler12345678910111213141516171819202122232425//等我们会用这个类，自动生成代理类!public class ProxyInvocationHandler implements InvocationHandler { //被代理的接口 private Object target; public void setTarget(Object target) { this. target = target; } //生成得到代理类 public Object getProxy(){ return Proxy.newProxyInstance(this.getClass().getClassLoader(), target.getClass().getInterfaces(), this); } //处理代理实例，并返回结果: public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { log(method.getName()); object result = method.invoke(target, args); return result; } public void log(String msg){ System.out.print1n(&quot;执行了&quot;+msg+&quot;方法&quot;); }} Client123456789101112public class Client { public static void main(String[] args) { //真实角色 UserServiceImpl userService = new UserServiceImpl(); //代理角色，不存在 ProxyInvocationHandler pih = new ProxyInvocationHandler(); pih.setTarget(userService); // 设置要代理的对象 //动态生成代理类 UserService proxy = (UserService) pih.getProxy(); proxy.query(); }} 动态代理的好处： 可以使真实角色的操作更加纯粹，不用取关注一些公共的业务 公共业务就交给代理角色，实现了业务的分工 公共业务发生扩展时，方便集中管理 一个动态代理类代理的是一个接口，一般就是对应的一类业务 一个动态代理类可以代理多个类，只要是实现了同一个接口即可 AOPAOP简介AOP（Aspect Oriented Programming）：面向切面编程。底层是动态代理。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 AOP在Spring中的作用==提供声明式事务：允许用户自定义切面== 使用Spring实现AOP使用Spring API接口使用AOP，需要导入一个依赖包 maven依赖123456&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj &lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.4&lt;/version&gt;&lt;/ dependency&gt; Log123456789public class Log implements MethodBeforeAdvice { //method: 要执行的目标对象的方法 //args: 参数 //target: 目标对象 public void before(Method method, Object[] args, Object target) throws Throwable { System.out.println(target.getClass().getName()+&quot;的&quot;+method.getName()+&quot;被执行了&quot;); }} AfterLog1234567public class AfterLog implements AfterReturningAdvice { //returnValue: 返回值 public void afterReturning(Object returnValue, Method method, Object[] args, object target) throws Throwable { System.out.printin(&quot;执行了&quot; + method.getName() + &quot;方法，返回结果为：&quot; + returnValue); }} ApplicatinContext.xml12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns= &quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!--注册bean--&gt; &lt;bean id-&quot;userService&quot; class=&quot; com.lvjie.service.UserServiceImpl&quot;/&gt; &lt;bean id=&quot;log&quot; class=&quot;com.lvjie.log.Log&quot;/&gt; &lt;bean id=&quot;afterLog&quot; class-&quot;com.lvjie.log.AfterLog&quot;/&gt; &lt;!--方式一:使用原生Spring API接口--ン &lt;!--配置aop:需要导入aop的约束--〉 &lt;aop:config&gt; &lt;!--切入点: expression: 表达式，execution( 要执行的位置! *****)--&gt; &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.lvjie.service.UserServiceImpl.*(..))&quot;/&gt; &lt;!--执行环绕増加! --&gt; &lt;aop:advisor advice-ref&quot;log&quot; pointcut-ref=&quot;pointcut&quot;/&gt; &lt;aop:advisor advice-ref=&quot;afterLog&quot; pointcut-ref=&quot;pointcut&quot;/&gt; &lt;/aop:config&gt;&lt;/beans&gt; MyTest12345678public class MyTest { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //动态代理代理的是接口:注意点 UserService userService = (UserService)context.getBean(&quot;userService&quot;); userService.select(); }} 自定义类ApplicationContext.xml123456789101112&lt;!--方式二:自定义类--&gt;&lt;bean id=&quot;diy&quot; class=&quot;com.lvjie.diy.DiyPointCut&quot;/&gt; &lt;aoр:config&gt; &lt;!--自定义切面, ref要引用的类--&gt; &lt;aop:aspect ref=&quot;diy&quot;&gt; &lt;!--切入点--&gt; &lt;aop:pointcut id=&quot;point&quot; expression=&quot;execution(* com.lvjie.service.UserServiceImpl.*(..))&quot;/&gt; &lt;!--通知--&gt; &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;point&quot;/&gt; &lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;point&quot;/&gt; &lt;/aop: aspect&gt;&lt;/aop: config&gt; 使用注解实现ApplicationContext.xml1234&lt;!--方式三--&gt;&lt;bean id=&quot;annotationPointCut&quot; class=&quot;com.lvjie.diy.AnnotationPointCut&quot;/&gt;&lt;!--开启注解支持 JDK( #i proxy-target-class= &quot;false &quot;) cglib (proxy- target-class=&quot;true&quot;) --&gt;&lt;aop:aspectj-autoproxy/&gt; AnnotationPointCut1234567891011121314151617181920212223242526@Aspect //标注这个类是一 个切面public class AnnotationPointCut { @Before(&quot;executipn(* com.lvjie.service.UserServiceImpl.*(..))&quot;) public void before(){ System.out.println(&quot;=====方法执行前=====&quot;); } @After(&quot;execution(*com.lvjie.service.UserServiceImpl.*(..))&quot;) public void after(){ System. out. println(&quot;=====方法执行后=====&quot;); } //在环绕增强中，我们可以给定一个参数，代表我们要获取处理切入的点; @Around(&quot;execution(* com.lvjie.service.UserServiceImpl.*(..))&quot;) public void around(ProceedingJoinPoint jp) throws Throwable { System.out.println(&quot;环绕前&quot;); Signature signature = jp.getSignature();//获得签名 System.out.println(&quot;signature :&quot;+signature); Object proceed = jp.proceed(); //执行方法 System.out.println(&quot;环绕后&quot;); System.out.println(proceed); }} 整合MybatisMybatis-spring 编写数据源 sqlSessionFactory sqlSessionTemplate 需要给接口加实现类 将自己写的实现类注入到Spring中 测试 MyTest12345678public class MyTest { @Test public void test() throws IOException { ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); UserMapper userMapper = context.getBean(&quot;userMapper&quot;, UserMapper .class); for(User user : userMapper.selectUser()) { System.out.println(user);} spring-dao.xml12345678910111213141516171819202122232425&lt;!--DataSource: 使用Spring的数据源替换Mybatis的配置 我们这里使用Spring提供的JDBC：org.springframework.jdbc.datasource--&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;&lt;/bean&gt;&lt;!--sqLSessionFactory--&gt;&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;!--绑定Mabatis配置文件--&gt; &lt;property name=&quot;configuration&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:com/lvjie/mapper/*.xml&quot;/&gt;&lt;/bean&gt;&lt;!--SqLSessionTemplate: 就是我们使用的sqlSession--&gt;&lt;bean id=&quot;sqlSession&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt; &lt;!-- 只能使用构造器注入SessionFactory, 因为它没有set方法--&gt; &lt;constructor-arg index=&quot;0&quot; ref=&quot; sqlSessionFactory&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;userMapper&quot; class=&quot;com.lvjie.mapper.UserMapperImpl&quot;&gt; &lt;property name=&quot;sqlSession&quot; ref=&quot;sqlSession&quot;/&gt;&lt;/bean&gt; UserMapperImpl123456789101112public class UserMapperImpl implements UserMapper { //在原来我们的所有操作，都使用sqlSession来执行，现在都使sqlSessionTemplate; private SqlSessionTemplate sqlSession; public void setSqlSession(SqlSessionTemplate sqlSession) { this.sqlSession = sqlSession; } public List&lt;User&gt; selectUser() { UserMapper mapper = sqlSession.getMapper(UserMapper.class); return mapper.selectUser(); }} 声明式事务事务 把一组业务当成一个业务来做；要么都成功，要么都失败! 确保完整性和一致性; 事务ACID原则: 原子性 一致性 隔离性 多个业务可能操作同一个资源，防止数据损坏 持久性 事务一旦提交,无论系统发生什么问题，结果都不会再被影响，被持久化的写到存储器中! Spring中的事务管理spring-dao.xml123456789101112131415161718&lt;!--配置声明式事务--&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;&lt;/bean&gt;&lt;!--结合AOP实现事务的织入--&gt;&lt;!--配置事务通知; --&gt;&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager= &quot;transactionManager&quot;&gt; &lt;!--给那些方法配置事务--&gt; &lt;!--配置事务的传播特性: new propagation= --&gt; &lt;tx : attributes&gt; &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;!--配置事务切入--&gt;&lt;aop:config&gt; &lt;aop:pointcut id= &quot;txPointCut&quot; expression=&quot;execution(* com.lvjie.mapper.*.*(..))&quot;/&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txPointCut&quot; /&gt;&lt;/aop:config&gt;","link":"/Spring/Spring.html"},{"title":"数据结构历年试题","text":"2018年应用题 算法设计题 1234567891011121314151617void merge(SqList *La, SqList *Lb, SqList *Lc){ int i = 0, j = 0, k = 0; while(i&lt;La-&gt;length &amp;&amp; j&lt;Lb-&gt;length){ if(La.elem[i] == Lb.elem[j]){//当前两个元素相同，为交集 Lc.elem[k++] = La.elem[i]; i++; j++; } else if(La.elem[i] &gt; Lb.elem[j]){//Lb当前指示的数小 j++; } else{ i++; } } Lc.length = k;} 12345678910111213141516171819void split(LinkList head, LinkList head1, LinkList head2){ if(head == head-&gt;next) return;//单向循环链表为空 LinkList p = head-&gt;next; LinkList p1 = head1, p2 = head2; while(p != head){ if(p-&gt;data % 2 == 1){ p-&gt;next = p1-&gt;next; p1-&gt;next = p; p1 = p1-&gt;next; } else{ p-&gt;next = p2-&gt;next; p2-&gt;next = p; p2 = p2-&gt;next; } p = p-&gt;next; }} 12345678910111213141516void PreOrder_NR(BiTree tree){ if(tree == NULL)//树为空 return; Initstack(&amp;s);//创建栈 BiTree p = tree; while(!StackEmpty(s) || p){ while(p){//循环直到没有左子树 Push(&amp;s, p);//将结点入栈 printf(&quot;%d&quot;, p-&gt;data);//输出结点 p = p-&gt;lchild;//进行遍历左孩子 } Pop(&amp;s, &amp;p);//获得栈顶并出栈 p = p-&gt;rchild;//对其右子树进行遍历 }} 123456789101112131415//递归查找指定结点在二叉排序树中的层次int height(TlemType f, int c, BiTree t){//f为指定的数，c为层次，t为结点 if(t){//未查找到 return 0;//返回层次0 } if(t-&gt;data == f){//查找到 return c;//返回层次 } else if(t-&gt;data &lt; f){//查找数大于当前结点 return height(f, c+1, t-&gt;rchild);//查找右子树 } else if(t-&gt;data &gt; f){//查找数小于当前结点 return height(f, c+1, t-&gt;lchild);//查找左子树 } } 123456int Yanghui(int row, int col){ if(col = 1 || row == col) return 1; else return Yanghui(row-1, col-1) + Yanghui(row-1,col);} 123456789int singleBranch(BiTree t){ if(t){ int a = 0; if((t-&gt;lchild &amp;&amp; t-&gt;rchild==NULL) || (t-&gt;lchild==NULL &amp;&amp; t-&gt;rchild)) a = 1; return a + singleBranch(t-&gt;lchild) + singleBranch(t-&gt;rchild); } return 0;} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/**利用快速排序思想解决。由于要求“对每粒砾石的颜色只能看一次”，设3个指针i，j和k，分别指向红色、白色砾石的后一位置和待处理的当前元素。从k=n开始，从右向左搜索，若该元素是兰色，则元素不动，指针左移（即k-1）；若当前元素是红色砾石，分i&gt;=j（这时尚没有白色砾石）和i&lt;j两种情况。前一情况执行第i个元素和第k个元素交换，之后i+1；后一情况，i所指的元素已处理过（白色），j所指的元素尚未处理，应先将i和j所指元素交换，再将i和k所指元素交换。对当前元素是白色砾石的情况，也可类似处理。*/void sort(int *data, int n){//data为砾石数据，n为数量 int i = 1, j = 1, k = n, t; while(k != j){//从后往前进行 while(data[k] == 3)//为蓝砾石都可以直接跳过 k--; if(data[k] == 1){//红砾石 if(i &gt;= j){//左边只有红砾石，直接与i指向交换即可 t = data[k]; data[k] = data[i]; data[i] = t; i++; } else{//左边已经有红、白砾石；需要先交换i与j的砾石，再交换i与k的砾石 //就是将i指向的白砾石放在已经排序的白砾石后面，再将红砾石放在i位置 t = data[j]; data[j] = data[i]; data[i] = t; j++; t = data[k]; data[k] = data[i]; data[i] = t; i++; } } if(data[k] == 2){//白砾石 if(i &lt;= j){//左边已经有白色砾石了 t = data[k]; data[k] = data[j]; data[j] = t; j++; } else{//当前左边没有白色砾石 t = data[k]; data[k] = data[i]; data[i] = t; j = i + 1; } } }//while //处理最后一个砾石 if(data[k] == 2)//最后一个为白砾石，不需要移动 j++; else if(data[k] == 1){//最后一个为红砾石，需要移动 t = data[j];//与i指向交换 data[j] = data[i]; data[i] = t; i++; j++; } printf(&quot;红：%d个 白：%d个 蓝：%d个\\n&quot;,i-1,j-i,n-j+1);} 2019年应用题 ABCD ACBD ACDB ADCB ABDCBACD BCAD BCDA BDCA BADCCBAD CBDA CDBADCBA总数 = C(2n, n) - C(2n, n+1) —-&gt;14 根节点的第一个子结点作为根节点的左孩子，该子结点的兄弟结点作为根节点的右孩子。 假设网 N 的任何一棵最小生成树都不包含 (u, v)。 设 T 是连通网上的一棵最小生成树，当将边 (u, v) 加入到 T 中时，由生成树的定义，T 中必存在一条包含 (u, v) 的回路。另一方面，由于 T 是生成树，则在 T 上必存在另一条 (u’, v’)，其中 u’∈U，V’∈V-U，且 u 和 u’ 之间，v 和 v’ 之间均有路径相通，删去边 (u’, v’)，便可消除上述回路，同时得到另一棵生成树 T’。因为 (u, v) 的代价不高于 (u’, v’)，则 T’ 的代价亦不高于 T，T’ 是包含 (u, v) 的一棵最小生成树，和假设矛盾。 （1）265、301、694、076、436、863、742、751、129、937（2）076、129、265、751、937、863、742、694、301、436（3）937、694、863、265、436、751、742、129、076、301 算法设计题 12345678910111213141516171819202122232425SqList merge(SqList La, SqList Lb){ SqList Lc; Lc.length = 0; Lc.listsize = La.length + Lb.length; Lc.elem = (ElemType *)malloc(sizeof(ElemType)*Lc.listsize); int i = 1, j = 1, k = 1; while(i &lt;= La.length &amp;&amp; j &lt;= Lb.length){ if(La.elem[i] &lt;= Lb.elem[j]){ Lc.elem[k++] = La.elem[i++]; } else{ Lc.elem[k++] = Lb.elem[j++]; } } while(i &lt;= La.length){ Lc.elem[k++] = La.elem[i++]; } while(j &lt;= Lb.length){ Lc.elem[k++] = Lb.elem[j++]; } Lc.length = k - 1; return Lc;} 1234567891011121314//头插法逆置单链表void inverse(LinkList head){ LinkList p = head-&gt;next; if(!p) return;//链表为空 head-&gt;next = NULL; while(p){//头插法 LinkList q = p; p = p-&gt;next; q-&gt;next = head-&gt;next; head-&gt;next = q; }} 123456789101112131415161718void InOrderTraverse(BiTree T){//中序遍历（非递归） Initstack(&amp;s);//栈 BiTree e = T; if(!e){ return;//树为空 } while(e || !StackEmpty(s)){ while(e){ Push(&amp;s, e); e = e-&gt;lchild; } Pop(&amp;s, &amp;e);//出栈 printf(&quot;%d&quot;,e-&gt;data);//访问结点 e = e-&gt;rchild; }} 1234567891011121314151617181920212223void FastTransposeSMatrix(TSMatrix M, TSMatrix *T){ T.mu = M.nu; T.nu = M.mu; T.tu = M.tu; if(T.tu){ int num[M.mu+1]; for(int i=1;i&lt;=M.mu;i++) num[i] = 0; for(int i=1;i&lt;=M.tu;i++) num[M.data[t].j]++;//求M中每一列含非零元个数 int cpot[M.nu+1]; cpot[1] = 1; //求第i列中第一个非零元在b.data中的序号 for(int i=2;i&lt;=M.nu;i++) cpot[i] = cpot[i-1] + num[i-1]; for(int i=1;i&lt;=M.tu;i++){ int col = M.data[p].j; int q = cpot[col]; T.data[q].i = M.data[p].j; T.data[q].j = M.data[p].i; T.data[q].v = M.data[p].v; cpot[col]++; } }} 12345678910111213141516171819202122232425262728293031323334OperandType EvaluateExpression(){ //算术表达式求值的算符优先算法。设OPTR和OPND分别为运算符栈和运算数栈 //OP为运算符集合 InitStack(OPTR);//创建空栈OPTR Push(OPTR, '#');//OPTR栈压入‘#’ InitStack(OPND);//创建空栈OPND c = getchar();//获取输入一个字符 while(c != '#' || GetTop(OPTR) != '#'){//#相遇，运算结束 if(!In(c, OP)){//是否为运算符 Push(OPND, c);//不是运算符则进运算数栈OPND c = getchar();//获取下一个输入 } else{ switch(Precede(GetTop(OPTR), c)){//比较获取的运算符与符号栈顶符号的优先级关系，Precede获取优先级函数 case '&lt;': //栈顶元素优先权低 Push(OPTR, c);//压入操作符栈OPTR c = getchar();//获取下个输入 break; case '=': //脱括号并接收下一个字符 Pop(OPTR, x);//出栈OPTR c = getchar(); break; case '&gt;': //退栈两个数进行运算，再将结果入栈 Pop(OPTR, theta);//获取操作符号theta Pop(OPND, b);//获取运算数b Pop(OPND, a);//获取运算数a Push(OPND, Operate(a, theta, b));//对a、b进行theta运算结果入栈，Operate运算函数 break; } }//switch }//while return GetTop(OPND);}//EvaluateExpression 123456789int TwoBranched(BiTree T){//计算双分支节点个数 if(T){ int a = 0; if(T-&gt;lchild&amp;&amp;T-&gt;rchild) a = 1; return a + TwoBranched(T-&gt;lchild) + TwoBranched(T-&gt;rchild); } return 0;} 1234567891011121314151617181920212223//快速排序#define LIST_INIT_SIZE 100 //线性表存储空间的初始分配量 #define LISTINCREMENT 10 //线性表存储空间的分配增量 typedef struct{ ElemType *elem; //存储空间基址 int length; //当前长度 int listsize; //当前分配的存储容量(以sizeof(ElemType)为单位) }SqList;void sort(SqList L){//将奇数放在偶数前面 //利用的是快速排序类似的思想 int i = 1, j = L.length; while(i &lt; j){ while(i&lt;j &amp;&amp; L.elem[i]%2==1 &amp;&amp; i&lt;=L.length) i++; while(i&lt;j &amp;&amp; L.elem[j]%2==0 &amp;&amp; j&gt;0) j--; if(i &lt; j){ int t = L.elem[i]; L.elem[i] = L.elem[j]; L.elem[j] = t; } }} 2020年应用题 （1）35、26、48、32、43、80、63、49、37、73（2）26、32、35、49、43、80、63、48、37、73（3）80、73、49、48、63、35、26、32、37、43 算法设计题 1234567891011121314151617181920212223242526272829303132//顺序改变用头插法void merge(LinkList La, LinkList Lb, LinkList Lc){ LinkList pa = La-&gt;next, pb = Lb-&gt;next, p; Lc = La; Lc-&gt;next = NULL; while(pa &amp;&amp; pb){ if(pa-&gt;data &lt;= pb-&gt;data){ p = pa; pa = pa-&gt;next; p-&gt;next = Lc-&gt;next; Lc-&gt;next = p; } else{ p = pb; pb = pb-&gt;next; p-&gt;next = Lc-&gt;next; Lc-&gt;next = p; } } while(pa){ p = pa; pa = pa-&gt;next; p-&gt;next = Lc-&gt;next; Lc-&gt;next = p; } while(pb){ p = pb; pb = pb-&gt;next; p-&gt;next = Lc-&gt;next; Lc-&gt;next = p; }} 123456789101112131415161718192021222324252627282930313233bool isValid(char * s){ int n = strlen(s);//获取字符串长度 char str[10010];//栈 int num = 0;//栈的尾标记 for(int i=0;i&lt;n;i++){ if(s[i] == '(' || s[i] == '[' || s[i] == '{')//左符号进栈 str[num++] = s[i]; else{ if(s[i] == ')'){//右括号 if(num&lt;1 || str[num-1] != '(')//若栈为空或者栈尾不是左括号，则匹配失败 return false; else//出栈 num--; } else if(s[i] == ']'){ if(num&lt;1 || str[num-1] != '[')//若栈为空或者栈尾不是左括号，则匹配失败 return false; else//出栈 num--; } else{ if(num&lt;1 || str[num-1] != '{')//若栈为空或者栈尾不是左括号，则匹配失败 return false; else//出栈 num--; } } } if(num == 0)//栈为空 return true; else//栈不为空 return false;} 123456789101112131415161718//暴力查找法typedef char SString[maxlen+1];bool matching(SString s, SString find){ int n = s[0] - '0'; if(find[0] - '0' &lt;= 0) return 0;//查找失败 for(int i=1;i&lt;=n;i++){ if(s[i] == find[1]){ int j; for(j=0;j&lt;find[0]-'0';j++) if(s[i+j] != find[1+j]) break; if(j == find[0]-'0') return 1;//查找成功 } } return 0;//查找失败 } 1234567891011121314151617181920212223void FastTransposeSMatrix(TSMatrix M, TSMatrix *T){ T.mu = M.nu; T.nu = M.mu; T.tu = M.tu; if(T.tu){ int num[M.mu+1]; for(int i=1;i&lt;=M.mu;i++) num[i] = 0; for(int i=1;i&lt;=M.tu;i++) num[M.data[t].j]++;//求M中每一列含非零元个数 int cpot[M.nu+1]; cpot[1] = 1; //求第i列中第一个非零元在b.data中的序号 for(int i=2;i&lt;=M.nu;i++) cpot[i] = cpot[i-1] + num[i-1]; for(int i=1;i&lt;=M.tu;i++){ int col = M.data[p].j; int q = cpot[col]; T.data[q].i = M.data[p].j; T.data[q].j = M.data[p].i; T.data[q].v = M.data[p].v; cpot[col]++; } }} 123456789int greaterThan60(BiTree t){//data大于60的结点数 if(t){ int cnt = 0; if(t-&gt;data &gt; 60) cnt = 1; return cnt + greaterThan60(t-&gt;lchild) + greaterThan60(t-&gt;rchild); } return 0;} 12345678910111213141516void levelTraversal(BiTree T){//二叉树层次遍历 if(!T)//二叉树为空 return; InitQueue(&amp;Q); EnQueue(&amp;Q, T); BiTree p; while(!EmptyQueue(Q)){ DeQueue(&amp;Q, &amp;p); printf(&quot;%d&quot;,p-&gt;data); if(p-&gt;lchild) EnQueue(&amp;Q, p-&gt;lchild); if(p-&gt;rchild) EnQueue(&amp;Q, p-&gt;rchild); }} 2021年应用题 算法设计题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455void add(Polylist PLA, Polylist PLB, Polylist PLC){ Polylist p = PLA-&gt;next, q = PLB-&gt;next, f = PLC, l; while(p &amp;&amp; q){ if(p-&gt;exp &lt; q-&gt;exp){//PLA的指数小 l = (Polylist)malloc(sizeof(Polynode)); l-&gt;co = p-&gt;co; l-&gt;exp = p-&gt;exp; l-&gt;next = NULL; f-&gt;next = l; f = f-&gt;next; p = p-&gt;next; } else if(p-&gt;exp == q-&gt;exp){//PLA和PLB的指数相等，两者合并 if(p-&gt;co + q-&gt;co != 0){//合并后不为0 l = (Polylist)malloc(sizeof(Polynode)); l-&gt;co = p-&gt;co + q-&gt;co; l-&gt;exp = p-&gt;exp; l-&gt;next = NULL; f-&gt;next = l; f = f-&gt;next; } p = p-&gt;next; q = q-&gt;next; } else{//PLB的指数小 l = (Polylist)malloc(sizeof(Polynode)); l-&gt;co = q-&gt;co; l-&gt;exp = q-&gt;exp; l-&gt;next = NULL; f-&gt;next = l; f = f-&gt;next; q = q-&gt;next; } } while(p){//将PLA后序的结点加入PLC l = (Polylist)malloc(sizeof(Polynode)); l-&gt;co = p-&gt;co; l-&gt;exp = p-&gt;exp; l-&gt;next = NULL; f-&gt;next = l; f = f-&gt;next; p = p-&gt;next; } while(q){//将PLB后序的结点加入PLC l = (Polylist)malloc(sizeof(Polynode)); l-&gt;co = q-&gt;co; l-&gt;exp = q-&gt;exp; l-&gt;next = NULL; f-&gt;next = l; f = f-&gt;next; q = q-&gt;next; }} 1234567891011121314151617181920212223242526272829303132333435int judge(){ //输入表达式，返回1为括号匹配成功，返回0为括号匹配失败 char str[10000], e; scanf(&quot;%s&quot;,str); if(strlen(str)&lt;=0) return 1; InitStack(S);//初始化栈 int i = 0; Push(S, str[i++]); for(;i&lt;strlen(str);i++){ if(str[i] == ')'){ Pop(S, e); if(e != '(')//括号不匹配 return 0; } else if(str[i] == ']'){ Pop(S, e); if(e != '[')//括号不匹配 return 0; } else if(str[i] == '}'){ Pop(S, e); if(e != '{')//括号不匹配 return 0; } else{ Push(S, str[i]); } } if(StackEmpty(S))//栈为空，括号匹配成功 return 1; else//栈不为空，括号匹配失败 return 0;} 123456789101112131415161718void PreorderBiTree(BiTree &amp;T){//先序建立二叉树 char a; scanf(&quot;%c&quot;,&amp;a); if(a == '#'){ T = NULL; } else{ T = (BiTree)malloc(sizeof(BiTNode)); if(!T){ printf(&quot;内存分配出现问题！！！\\n&quot;); printf(&quot;请重新启动程序！！！&quot;); exit(0); } T-&gt;data = a;//将数据赋值给该节点 PreorderBiTree(T-&gt;lchild);//建立左孩子 PreorderBiTree(T-&gt;rchild);//建立右孩子 }} 123456789101112131415161718void InOrderTraverse(BiTree T){//中序遍历（非递归） InitStack(S);//栈 BiTree e = T; if(!e){ return;//树为空 } while(e || !StackEmpty(S)){ while(e){ Push(S, e);//入栈 e = e-&gt;lchild; } Pop(S, e);//出栈 printf(&quot;%c&quot;,e-&gt;data);//访问结点 e = e-&gt;rchild; }} 12345678910111213void dfs(int A[][], int n){//A为图的邻接矩阵，n为结点个数 InitQueue(Q); EnQueue(Q, 0);//从0号点开始遍历 while(!EmptyQueue(Q)){ int i; DeQueue(Q, i); printf(&quot;%d &quot;, i + 1); for(int j = 0; j &lt; n; j++) if(A[i][j] != 0) EnQueue(Q, j); }} 12345678910111213141516171819202122232425262728293031323334OperandType EvaluateExpression(){ //算术表达式求值的算符优先算法。设OPTR和OPND分别为运算符栈和运算数栈 //OP为运算符集合 InitStack(OPTR);//创建空栈OPTR Push(OPTR, '#');//OPTR栈压入‘#’ InitStack(OPND);//创建空栈OPND c = getchar();//获取输入一个字符 while(c != '#' || GetTop(OPTR) != '#'){//#相遇，运算结束 if(!In(c, OP)){//是否为运算符 Push(OPND, c);//不是运算符则进运算数栈OPND c = getchar();//获取下一个输入 } else{ switch(Precede(GetTop(OPTR), c)){//比较获取的运算符与符号栈顶符号的优先级关系，Precede获取优先级函数 case '&lt;': //栈顶元素优先权低 Push(OPTR, c);//压入操作符栈OPTR c = getchar();//获取下个输入 break; case '=': //脱括号并接收下一个字符 Pop(OPTR, x);//出栈OPTR c = getchar(); break; case '&gt;': //退栈两个数进行运算，再将结果入栈 Pop(OPTR, theta);//获取操作符号theta Pop(OPND, b);//获取运算数b Pop(OPND, a);//获取运算数a Push(OPND, Operate(a, theta, b));//对a、b进行theta运算结果入栈，Operate运算函数 break; } }//switch }//while return GetTop(OPND);}//EvaluateExpression","link":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8E%86%E5%B9%B4%E8%AF%95%E9%A2%98.html"},{"title":"Mybatis","text":"Mybatis环境： Jdk1.8 Mysql 5.7 Maven 3.6.1 idea 简介 MyBatis 是一款优秀的持久层框架 它支持自定义 SQL、存储过程以及高级映射 MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作 MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录 maven仓库123456&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;arti factId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.6&lt;/version&gt;&lt;/dependency&gt; 持久化持久化就是将程序的数据在持久状态和瞬时状态转化的过程 持久层 完成持久化工作的代码块 层界限十分明显 为什么需要Mybatis 帮助程序猿将数据存入到数据库 方便 传统的jdbc代码太复杂了。简化。框架。自动化。 第一个Mybatis程序思路：搭建环境—&gt;导入Mybatis—&gt;编写代码—&gt;测试 搭建环境搭建数据库 搭建数据库1234567891011121314CREATE DATABASE `mybatis`;USE `mybatis`;CREATE TABLE `user` ( `id` INT(20) NOT NULL PRIMARY KEY, `name` VARCHAR(30) DEFAULT NULL, `pwd` VARCHAR(30) DEFAULT NULL) ENGINE= INNODB DEFAULT CHARSET=utf8;INSERT INTO `user`(`id`, `name`, `pwd`)VALUES(1,'lvjie','123456'),(2, '张三', '123456'),(3, '李四', '123890') 新建maven项目，导入maven依赖 导入maven依赖12345678910111213141516171819202122&lt;!--导入依赖--&gt;&lt;dependencies&gt; &lt;!--mysql驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;!--mybatis--&gt; &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建一个模块 编写mybatis的核心配置文件 在resources目录下 Mybatis核心配置文件123456789101112131415161718192021222324&lt;?xml version=&quot;1.O&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;!--configuration核心配置文件--&gt;&lt;configuration&gt; &lt;environments defau1t=&quot; devel opment&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot; /&gt; &lt;dataSource type=&quot;POOLED&quot; &gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;ur1&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUni code=true&amp;amp;characterEncoding=UTF-8&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--每一个Mapper.XML都需要在Mybatis核心配置文件中注册! --&gt; &lt;mappers&gt; &lt;!--resource路径必须是斜杠，不是点--&gt; &lt;mapper resource= &quot;com/lvjie/dao/UserMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 编写mybatis工具类 MybatisUtils.java SqlSession相当于preparestatement，执行sql语句，SqlSession需要通过工厂创建 MybatisUtils.java12345678910111213141516171819202122//sqLSessionFactory --&gt; sqlSessionpublic class MybatisUtils { private static SqlSessionFactory sqlSessionFactory; static{ try { //使用Mybatis第-步:获取sqlSessionFactory对象 String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream( resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); } catch ( IOException e) { e.printStackTrace(); } } // 既然有了SqlSessionFactory, 顾名思义，我们就可以从中获得SqlSession的实例了。 // SqlSession 完全包含了面向数据库执行SQL命令所需的所有方法。 public static SqlSession getSqlSession(){ return sqlSessionFactory.openSession(); }} 编写代码实体类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class User { private int id; private String name; private String pwd; public User() { } public User(int id, String name, String pwd) { this.id = id; this.name = name; this.pwd = pwd; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getPwd() { return pwd; } public void setPwd(String pwd) { this.pwd = pwd; } @java.lang.Override public java.lang.String toString() { return &quot;User{&quot; + &quot;id=&quot; + id + &quot;, name='&quot; + name + '\\'' + &quot;, pwd='&quot; + pwd + '\\'' + '}'; } } Dao接口123public interface UserDao { List&lt;User&gt; getUerList();} 接口实现类由原来的UserDaoImpl转变为一个Mapper配置文件 Mapper配置文件1234567891011&lt;?xml version=&quot;1.0&quot; encoding-&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--namespace=绑定一个对应的Dao/Mapper接口--&gt;&lt;mapper namespace=&quot;com.lvjie.dao.UserDao&quot;&gt;&lt;!--select査詢語句--&gt;&lt;select id-&quot;getUserList&quot; resu1tType-&quot;com.lvjie.pojo.User&quot;&gt; select * from mybatis.user&lt;/select&gt;&lt;/mapper&gt; 测试核心配置文件中注册mappers junit测试 test123456789101112131415public class UserDaoTest{ @Test public void test(){ //第一步:获得SqlSession对象 SqlSession sqlSession = MybatisUtils.getSqlSession(); //方式一: getMapper UserDao userDao = sqlSession.getMapper(UserDao.class); List&lt;User&gt; userList = userDao.getUserList(); for (User user : userList) { System.out.println(user); } //关闭SqlSession sqlSession.close(); }} 添加maven依赖防止配置无法加载 maven123456789101112131415161718192021&lt;!-- #buіld #rіс. rеѕоurсеѕ, ЖjL:#іІ]В-іі #Ш#УÉJjF]/f--&gt;&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/ main/ resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/ include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; CRUDnamespacenamespace中的包名要和 Dao/mapper 接口的包名一致! Select选择，查询语句; .●id: 就是对应的namespace中的方法名;●resultType: Sq|语句执行的返回值!●parameterType :参数类型! 编写接口UserMapper UserMapper接口12345//查询全部用户List&lt;User&gt; getUserList();//根据 ID 查询用户User getUserById(int id); 编写对应的mapper中的sql语句 UserMapper.xml12345678&lt;!--查询全部用户--&gt;&lt;select id=&quot;getUserList&quot; resultType=&quot;com.lvjie.pojo.User&quot;&gt; select * from mybatis.user&lt;/select&gt;&lt;!--根据id查询用户--&gt;&lt;select id=&quot;getUserById&quot; resultType=&quot;com.lvjie.pojo.User&quot; parameterType=&quot;int&quot;&gt; select * from mybatis.user where id = #{id}&lt;/select&gt; 测试 test123456789101112131415161718192021222324@testpublic void getUserById() { SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sql.Session.getMapper(UserMapper.class); List&lt;User&gt; userList = mapper.getUserList(); for (User user : userList) { System.out.println(user) } sqlSession.close();}@testpublic void getUserById() { SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sql.Session.getMapper(UserMapper.class); User user = mappper.getUserById(1); System.out.println(user); sqlSession.close();} Insert 编写接口UserMapper UserMapper接口12//增加一个用户int addUser(User user); 编写对应的mapper中的sql语句 UserMapper.xml123&lt;insert id=&quot;addUser&quot; parameterType=&quot;com.lvjie.pojo.User&quot; &gt; insert into mybatis.user (id, name, pwd) values (#{id}, #{name}, #{pwd});&lt;/insert&gt; 测试 test123456789101112@testpublic void addUser() { SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sql.Session.getMapper(UserMapper.class); mappper.addUser(new User(4, &quot;lvjie&quot;, &quot;111111&quot;)); //增删改需要提交事务 sqlSession.commit(); sqlSession.close();} Update 编写接口UserMapper UserMapper接口12//修改用户int updateUser(User user); 编写对应的mapper中的sql语句 UserMapper.xml123&lt;update id=&quot;updateUser&quot; parameterType=&quot;com.lvjie.pojo.User&quot;&gt; update mybatis.user set name = #{name}, pwd = #{pwd} where id = #{id};&lt;/update&gt; 测试 test123456789101112@testpublic void updateUser() { SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sql.Session.getMapper(UserMapper.class); mappper.updateUser(new User(4, &quot;lvjie&quot;, &quot;123456&quot;)); //增删改需要提交事务 sqlSession.commit(); sqlSession.close();} Delete 编写接口UserMapper UserMapper接口12//删除一个用户int deleteUser(int id); 编写对应的mapper中的sql语句 UserMapper.xml123&lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt; delete from mybatis.user where id = #{id};&lt;/delete&gt; 测试 test123456789101112@testpublic void deleteUser() { SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sql.Session.getMapper(UserMapper.class); mappper.deleteUser(4); //增删改需要提交事务 sqlSession.commit(); sqlSession.close();} 万能Map假设我们的实体类或数据库中的表，字段或者参数过多，我们应当考虑使用Map！ UserMapper接口12// 万能的mapint addUser2(Map&lt;String, Object&gt; map); UserMapper.xml1234&lt;!--对象中的属性，可以直接取出来，传递map的key--&gt;&lt;insert id=&quot;addUser&quot; parameterType=&quot;map&quot;&gt; insert into mybatis.user(id, pwd) values (#{userid}, #{password});&lt;/insert&gt; test123456789101112131415@testpublic void addUser2() { SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); map.put(&quot;userid&quot;, 5); map.put(&quot;password&quot;, &quot;22222&quot;); map.addUser(map); //增删改需要提交事务 sqlSession.commit(); sqlSession.close();} Map传递参数，直接在sql中去除key即可 对象传递参数，直接在sql中取对象的属性即可 多个参数用map，或者注解。 模糊查询在sql中陪你姐中使用通配符 1select * from mybatis.user where name like &quot;%&quot;#{value}&quot;%&quot; 配置解析核心配置文件 mybatis-config.xml MyBatis 的配置文件包含了会深深影呵MyBatis行为的设置和属性信息。 配置文件12345678configuration (配置) properties (属性)settings (没置)typeAliases (炎型別名)environments (坏境配置)environment (坏境変量)transactionManager (事努管理器)mappers (映射器) 环境配置（environments)Mybatis默认的事务管理器是JDBC，连接池：POOLED 属性（Properties）我们可以通过properties属性来实现引用配置文件编写一个配置文件 db.properties1234driver=com.mysql.jdbc.Driverur1=jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;useUnicode=true&amp;characterEncoding=UTF-8username=rootpassword=123456 在核心配置文件中引入 配置文件1234&lt;!--引入配置文件--&gt;&lt;properties resource=&quot;db.properties&quot;&gt;&lt;!-- &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; --&gt;&lt;/properties&gt; 可以直接引用外部文件，如果两个文件由同一个字段，有先使用外部配置文件的。 类型别名(typeAliases) 类型别名是为Java类型设置一个短的名字。 存在的意义仅在于用来减少类完全限定名的冗余。 typeAlias1234&lt;!--可以给实体类起别名--&gt;&lt;typeAliases&gt; &lt;typeAlias type=&quot;com.lvjie.pojo.User&quot; alias=&quot;User&quot;/&gt;&lt;/typeAliases&gt; 也可以指定一个包名， MyBatis 会在包名下面搜索需要的Java Bean，比如:扫描实体类的包，它的默认别名就为这个类的类名的首字母小写! typeAlias1234&lt;!--可以给实体类起别名--&gt;&lt;typeAliases&gt; &lt;package name=&quot;com.lvjie.pojo&quot;/&gt;&lt;/typeAliases&gt; 在实体类比较少的时候，使用第一种方式如果实体类十分多，建议使用第二种。第一中可以DIY别名，第二种则不行，如果非要改，需要在实体上增加注解 注解12@Alias(&quot;user&quot;)public class User {} 映射器（mapper)MapperRegitry:注册绑定我们的Mapper文件;方式一：【推荐使用】 Mapper.XML1234&lt;!--每一个Mapper.XML都需要在Mybatis核心配置文件中注册--&gt;&lt;mappers&gt; &lt;mapper resource=&quot;com/lvjie/dao/userMapper.xml&quot;/&gt;&lt;/mappers&gt; 方式二: 使用Class文件绑定注册 Mapper.XML1234&lt;!--每一个Mapper.XML都需要在Mybatis核心配置文件中注册--&gt;&lt;mappers&gt; &lt;mapper class=&quot;com.lvjie.dao.userMapper&quot;/&gt;&lt;/mappers&gt; 注意点: 接口和他的Mapper配置文件必须同名! 接口和他的Mapper配置文件必须在同一个包下! 方式三:使用扫描包进行注入绑定 Mapper.XML1234&lt;!--每一个Mapper.XML都需要在Mybatis核心配置文件中注册! --&gt;&lt;mappers&gt; &lt;package name=&quot;com.lvjie.dao&quot;/&gt;&lt;/mappers&gt; 注意点: 接口和他的Mapper配置文件必须同名! 接口和他的Mapper配置文件必须在同一个包下! 生命周期和作用域 生命周期和作用域，是至关重要的，因为错误的使用会导致非常严重的并发问题。SqISessionFactoryBuilder:（建造工厂） 一旦创建了SqlSessionFactory, 就不再需要它了 SqlSessionFactory:（工厂） 说白了就是可以想象为:数据库连接池 SqISessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。 因此SqlSessionFactory的最佳作用域是应用作用域。 最简单的就是使用单例模式或者静态单例模式。 SqlSession（一个请求） 连接到连接池的一个请求! SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。 用完之后需要赶紧关闭，否则资源被占用! 这里面每一个Mapper，就代表一个具体的业务。 解决属性名和字段名不一致的问题当数据库中的字段和我们的实体类字段不一致时会出现结果不能正确显示，比如 实体类12345public class User { private int id; private String name; private String password;} 解决方法： 起别名 123&lt;select id=&quot;getUserById&quot; resultType=&quot;com.lvjie.pojo.User&quot;&gt; select id,name,pwd as password from mybatis.user where id = #{id}&lt;/select&gt; 结果集映射 resultMap 12345678&lt;!--结果集映射--&gt;&lt;resultMap id=&quot;UserMap&quot; type=&quot;User&quot;&gt; &lt;!--column数据库中的字段，property实体类中的属性--&gt; &lt;result column=&quot;pwd&quot; property=&quot;password&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;getUserById&quot; resultMap=&quot;UserMap&quot;&gt; select * from mybatis.user where id = #{id}&lt;/select&gt; 日志日志工厂如果一个数据库操作出现了异常，我们需要排错，日志就是最好的助手。 在Mybatis核心配置文件中配置我们的日志。 STDOUT_LOGGING标准日志输出 STDOUT_LOGGING123&lt;settings&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;&lt;/settings&gt; Log4j什么是Log4j? Log4j是Apache的一个开源项目,通过使用Log4j, 我们可以控制日志信息输送的目的地是控制台、文件、GUI组件。 我们也可以控制每-条日志的输出格式; 通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。 通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。 先导入log4j的包 maven123456&lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt;&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/ groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt; Log4j.properties Log4j.properties123456789101112131415161718192021222324#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码log4j.rootLogger=DEBUG, console, file#控制台输出的相关设置log4j.appender.console = org.apache.log4j.ConsoleAppenderlog4j.appender.console.Target = System.outlog4j.appender.console.Threshold = DEBUGlog4j.appender.console.layout = org.apache.log4j.PatternLayoutlog4j.appender.console.layout.ConversionPattern = [%c]-%m%n#文件输出的相关设置log4j.appender.file = org.apache.log4j.RollingFileAppenderlog4j.appender.file.File=./log/lvjie.loglpg4j.appender.file.MaxFileSize=10mblog4j.appender.file.Threshold=DEBUGlog4j.appender.file.layout=org.apache.log4j.PatternLayoutlog4j.appender.file.layout.ConversionPattern=[%p][%d(yy-MM-dd]] [%c]%m%n#日志输出级别log4j.logger.org.mybatis=DEBUGlog4j.logger.java.sql=DEBUGlog4j.logger.java.sql.Statement=DEBUGlog4j.logger.java.sql.ResultSet=DEBUGlog4j.logger.java.sql.PreparedStatement=DEBUG 配置log4j为日志的实现 123&lt;settings&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J&quot;/&gt;&lt;/settings&gt; 简单使用 在要使用Log4j的类中，导入包import org.apache.log4j.Logger; 日志对象，参数为当前类的class 1static Logger logger = Logger.getLogger(UserDaoTest.class); 使用Limit分页12# 语法 select * from user limit startIndex,pageSize;select * from user limit 3,5; 使用Mybatis实现分页 接口 接口12//分页List&lt;User&gt; getUserByLimit(Map&lt;String,Integer&gt; map); Mapper.xml Mapper.xml1234&lt;!--分页--&gt; &lt;select id=&quot;getuserByLimit&quot; parameterType=&quot;map&quot; resu1tMap=&quot;userMap &quot;&gt; select * from mybatis.user limit #{startIndex}, #{pagesize}&lt;/select&gt; 测试 test12345678910111213@Testpublic void getUserByLimit() { sqlsession sqlsession = MybatisUtils.getsqlsession(); UserMapper mapper = sqlsession.getMapper(userMapper.class); HashMap&lt;String, Integer&gt; map = new HashMap&lt;string, Integer&gt;(); map.put(&quot;startIndex&quot;, 1); map.put(&quot;pageSize&quot;, 2); List&lt;User&gt; userList = mapper.getUserByLimit(map); for (User user : userList) { System.out.println(user); } sqlsession.close();} 注解使用注解开发 注解在接口上实现 接口12@Select(&quot;select * from user&quot;)List&lt;User&gt; getUsers(); 需要在核心配置文件中绑定接口! 核心配置文件1234&lt;!--绑定接口--&gt;&lt;mappers&gt; &lt;mapper class=&quot;com.lvjie.dao.UserMapper&quot;/&gt;&lt;/mappers&gt; 本质: 反射机制实现底层: 动态代理 CRUD我们可以在工具类创建的时候实现自动提交事务! 123public static SqlSession getsqlSession(){ return sqlSessionFactory.openSession(true);} 编写接口，增加注解 UserMapper1234567891011121314151617181920public interface UserMapper { @Select(&quot;select * from user&quot;) List&lt;User&gt; getUsers(); //方法存在多个基本类型参数或String类型，所有的参数前而必须加上@Param( &quot;id&quot;)注解 @Select(&quot;select * from user where id = #{id}&quot; ) User getUserById(@Param(&quot;id&quot;) int id); //方法存在引用类型参数，不用加Param()注解 @Insert(&quot;insert into user(id, name, pwd) values (#{id}, #{name}, #{password})&quot;) int addUser(User user); @Update(&quot;update user set name=#{name}, pwd=#{password} where id = #{id}&quot;) int updateUser(User user); //在SQL中引用的是我在@Param()中设定的属性名 @Delete(&quot;delete from user where id = #{uid}&quot;) int deleteUser(@Param(&quot;uid&quot;) int id);} Lombok使用步骤:1.在IDEA中安装Lombok插件!2.在项目中导入lombok的jar包 maven12345&lt;dependency&gt; &lt;groupId&gt;org.projectlombok &lt;/groupId&gt; &lt;artifactId&gt;lombok &lt;/artifactId&gt; &lt;version&gt;1.18.10&lt;/version&gt;&lt;/dependency&gt; 3.在实体类上加注解即可! 注解类型123456@Data //get和set和toString方法，不包括有参和无参构造方法@Al1ArgsConstructor //有参构造方法@NoArgsConstructo //无参构造方法@ToString //toString方法@Getter //get方法@Setter //set方法 多对一处理一个老师对应多个学生 实体类 实体类1234567@Datapublic class Student { private int id; private String name; //学生需要关联一个老师 private Teacher teacher;} 实体类12345@Datapublic class Teacher { private int id; private String name;} SQL 12345678910111213141516171819202122ECREATE TABLE `teacher` { `id` INT (10) NOT NULL, `name` VARCHAR (30 ) DEFAULT NULL, PRIMARY KEY (`id`)} ENGINE=INNODB DEFAULT CHARSET=utf8INSERT INTO `teacher`(`id`, `name`) VALUES (1, 'lvjie') ;ECREATE TABLE `student` { `id` INT (10) NOT NULL, `name` VARCHAR (30) DEFAULT NULL, `tid` INT(10) DEFAULT NULL, PRIMARY KEY (`id`) , KEY `fktid` (`tid`) , CONSTRAINT `fktid` FOREIGN KEY (`tid`) REFERENCES `teacher` (`id`)} ENGINE= INNODB DEFAULT CHARSET=utf8INSERT INTO `student` (`id`, `name`, `tid`) VALUES ('1', '小明', '1');INSERT INTO `student` (`id`, `name`, `tid`) VALUES ('2', '小红', '1');INSERT INTO `student` (`id`, `name`, `tid`) VALUES ('3', '小张', '1');INSERT INTO `student` (`id`, `name`, `tid`) VALUES ('4', '小李', '1');INSERT INTO `student` (`id`, `name`, `tid`) VALUES ('5', '小王', '1'); 测试环境搭建 导入lombok 新建实体类Teacher, Student 建立Mapper接口 建立Mapper.XML文件 在核心配置文件中绑定注册我们的Mapper接口或者文件! [方式很多， 随心选] 测试查询是否能够成功! 按照结果嵌套处理（联表查询）联表查询1234567891011121314&lt;!--按照结果嵌套处理--&gt;&lt;select id=&quot; getStudent2&quot; resultMap=&quot; StudentTeacher2&quot; &gt; select s.id sid, s.name sname, t.name tname from student s, teacher t where s.tid = t.id;&lt;/select&gt;&lt;resultMap id=&quot;StudentTeacher&quot; type=&quot;Student&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;sid&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;sname&quot;/&gt; &lt;association property=&quot;teacher&quot; javaType=&quot;Teacher&quot;&gt; &lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt; &lt;/association&gt;&lt;/resultMap&gt; 按照查询嵌套处理（子查询）子查询1234567891011121314151617181920&lt;!--思路: 1.查询所有的学生信息 2.根据查询出来的学生的tid, 寻找对应的老师!--&gt;&lt;select id=&quot;getStudent&quot; resultMap=&quot;StudentTeacher&quot;&gt; select * from student&lt;/select&gt;&lt;resultMap id=&quot;StudentTeacher&quot; type=&quot;Student&quot; &gt; &lt;result property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property- &quot;name&quot; column=&quot;name&quot; /&gt; &lt;!-- 复杂的属性，我们需要单独处理 association 对象 collection 集合 --&gt; &lt;association property=&quot;teacher&quot; column=&quot;tid&quot; javaType=&quot;Teacher&quot; select=&quot;getTeacher&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;getTeacher&quot; resultType=&quot;Teacher&quot; &gt; select * from teacher where id = #{id}&lt;/select&gt; 一对多处理一个老师拥有多个学生1.环境搭建，和刚才一样实体类 实体类1234567@Datapublic class Student { private int id; private String name; private int tid;} 实体类12345678@Datapublic class Teacher { private int id; private String name; //一个老师拥有多个学生 private List&lt;student&gt; students;} 按照结果嵌套处理（联表查询）联表查询1234567891011121314151617181920&lt;!--按结果嵌套查询--&gt;&lt;select id=&quot;getTeacher&quot; resultMap-&quot;TeacherStudent&quot;&gt; select s.id sid, s.name sname, t.name tname, t.id tid from student s, teacher t where s.tid = t.id and t.id = #{tid}&lt;/select&gt;&lt;resultMap id=&quot; TeacherStudent&quot; type=&quot;Teacher&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;tid&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt; &lt;!--复杂的属性，我们需要单独处理 对象: association 集合: collection javaType 指定属性的类型! 集合中的泛型信息，我们使用ofType 获取 --&gt; &lt;collection property= &quot; students&quot; ofType=&quot;Student&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;sid&quot;/&gt; &lt;result property= &quot;name&quot; column=&quot;sname&quot;/&gt; &lt;result property=&quot;tid&quot; column=&quot;tid&quot;/&gt; &lt;/collection&gt;&lt;/resultMap&gt; 按照查询嵌套处理（子查询）子查询123456789&lt;select id=&quot;getTeacher&quot; resultMap=&quot;TeacherStudent&quot;&gt; select * from mybatis.teacher where id = #{tid}&lt;/select&gt;&lt;resultMap id=&quot;TeacherStudent&quot; type=&quot;Teacher&quot;&gt; &lt;collection property=&quot;students&quot; javaType=&quot;ArrayList&quot; ofType=&quot;Student&quot; select=&quot;getStudentByTeacherId&quot; column=&quot;id&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;getStudentByTeacherId&quot; resultType=&quot;Student&quot;&gt; select * from mybatis.student where tid = #{tid}&lt;/select&gt; 小结 关联 - association [多对一 ] 集合 - collection [一对多] javaType &amp; ofType JavaType用来指定实体类中属性的类型 ofType用来指定映射到List或者集合中的pojo类型，泛型中的约束类型! 动态SQL动态SQL就是根据不同的条件生成不同的SQL语句。所谓的动态SQL，本质上还是SQL语句，只是我们可以在SQL层面去执行一个逻辑代码。动态SQL就是在拼接SQL语句，我们只要保证SQL的正确性，按照SQL的格式，去排列组合就可以了。 搭建环境1234567CREATE TABLE blog (id varchar(50) NOT NULL COMMENT '博客id',title varchar (100) NOT NULL COMMENT '博客标题'，author varchar(30) NOT NULL COMMENT ' 博客作者'，create_time datetime NOT NULL COMMENT '创建时间' ,views int(30) NOT NULL COMMENT '浏览量') ENGINE=InnoDB DEFAULT CHARSET=utf8 创建一个基础工程 导包 编写配置文件 编写实体类 实体类12345678@Datapublic class Blog { private int id; private String title; private String author; private Date createTime; private int views;} 编写实体类对应Mapper接口和Mapper.xml文件 IFMapper.xml123456789&lt;select id=&quot;queryBlogIF&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt; select from mybatis.blog where 1=1 &lt;if test=&quot;title != null&quot;&gt; and title = #{title} &lt;/if&gt; &lt;if test=&quot;author != null&quot;&gt; and author = #{author} &lt;/if&gt;&lt;/select&gt; WhereMapper.xml1234567891011&lt;select id=&quot;queryBlogWhere&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt; select * from mybatis.blog &lt;where&gt; &lt;if test=&quot;title != null&quot;&gt; title = #{title} &lt;/if&gt; &lt;if test=&quot;author != null&quot;&gt; and author = #{author} &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; ChooseMapper.xml12345678910111213141516&lt;select id-&quot;queryBlogChoose&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt; select * from mybatis.blog &lt;where&gt; &lt;choose&gt; &lt;when test=&quot;title != null&quot;&gt; title = #{title} &lt;/when&gt; &lt;when test=&quot;author != null&quot;&gt; and author = #{author} &lt;/when&gt; &lt;otherwise&gt; and views = #{views} &lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt;&lt;/select&gt; SetMapper.xml123456789101112&lt;update id=&quot;updateBlog&quot; parameterType=&quot;map&quot;&gt; update mybatis.blog &lt;set&gt; &lt;if test=&quot;title != null&quot;&gt; title = #{title}, &lt;/if&gt; &lt;if test &quot;author != null&quot;&gt; author = #{author} &lt;/if&gt; &lt;/set&gt; where id = #{id} &lt;/update&gt; SQL片段有的时候，我们可能会将一些功能的一部分抽取出来，方便复用。 使用SQL标签抽取公共的部分 Mapper.xml12345678&lt;sql id=&quot;if-title-author&quot;&gt; &lt;if test=&quot;title != null&quot;&gt; title = #{title} &lt;/if&gt; &lt;if test=&quot;author != null&quot;&gt; and author = #{author} &lt;/if&gt;&lt;/sql&gt; 注意事项 最好基于单表来定义SQL片段 不要存在where标签 在需要使用的地方使用Include标签引用即可 Mapper.xml123456&lt;select id=&quot;queryBlogIF&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt; select * from mybatis.blog &lt;where&gt; &lt;include refid &quot;if-title-author&quot;&gt;&lt;/include&gt; &lt;/where&gt;&lt;/select&gt; ForeachMapper.xml123456789101112&lt;!-- select * from mybatis.blog where 1=1 and (id=1 or id=2 or id=3) 我们现在传递一个万能的map，这map中可以存在一个集合!--&gt;&lt;select id=&quot;queryBlogForeach&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt; select * from mybatis.blog &lt;where&gt; &lt;foreach collection=&quot;ids&quot; item=&quot;id&quot; open=&quot;and (&quot; close=&quot;)&quot; separator=&quot;or&quot;&gt; id = #{id} &lt;/foreach&gt; &lt;/where&gt;&lt;/select&gt; 缓存简介 什么是缓存[ Cache ]? 存在内存中的临时数据。 将用户经常查询的数据放在缓存(内存)中，用户去查询数据就不用从磁盘上(关系型数据库数据文件)查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。 为什么使用缓存? 减少和数据库的交互次数，减少系统开销，提高系统效率。 什么样的数据能使用缓存? 经常查询并且不经常改变的数据。 Mybatis缓存 MyBatis包含一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大的提升查询效率。 MyBatis系统中默认定义了两级缓存: 一级缓存和二级缓存 默认情况下，只有一级缓存开启。(SqISession级别的缓存， 也称为本地缓存) 二级缓存需要手动开启和配置，他是基于namespace级别的缓存。 为了提高扩展性，MyBatis定义了缓存接口Cache. 我们可以通过实现Cache接口来自定义二级缓存 一级缓存 一级缓存也叫本地缓存: SqlSession 与数据库同-次会话期间查询到的数据会放在本地缓存中。 以后如果需要获取相同的数据，直接从缓存中拿，没必须再去查询数据库; 缓存失效的情况: 查询不同的东西 增删改操作，可能会改变原来的数据，所以必定会刷新缓存! 查询不同的Mapper.xml 手动清理缓存! 1sqlSession.clearCache();//手动清理缓存 小结：一级缓存默认是开启的，只在一次SqISession中有效， 也就是拿到连接到关闭连接这个区间段!一级缓存就是一个Map。 二级缓存 二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存 基于namespace级别的缓存，一个名称空间，对应一个二级缓存; 工作机制 一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中; 如果当前会话关闭了，这个会话对应的一级缓存就没了；但是我们想要的是，会话关闭了，一级缓存中的数据被保存到二级缓存中; 新的会话查询信息，就可以从二级缓存中获取内容; 不同的mapper查出的数据会放在自己对应的缓存(map) 中; 步骤: 开启全局缓存 Mapper.xml12&lt;!--显示的开启全局缓存--&gt;&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt; 在要使用二级缓存的Mapper中开启 Mapper.xml12&lt;!--在当前Mapper.xml中使用二级缓存--&gt;&lt;cache/&gt; 也可以自定义参数 Mapper.xml12345&lt;!--在当前Mapper.xml中使用二级缓存--&gt;&lt;cache eviction=&quot;FIFO&quot; flushInterval=&quot;60000&quot; size=&quot;512&quot; readonly=&quot;true&quot;/&gt; 小结: 只要开启了二级缓存，在同一个Mapper下就有效 所有的数据都会先放在一级缓存中 只有当会话提交，或者关闭的时候，才会提交到二级缓冲中","link":"/Spring/Mybatis.html"},{"title":"数据结构白皮书复习题","text":"时间复杂度 下面程序的时间复杂度是 —— O(m*n) 123for(i=0;i&lt;m;i++) for(j=0;j&lt;n;j++) a[i][j] = 0; 下面程序的时间复杂度是 —— O(n) 123s = 1;for(i=1;i&lt;n;i++) s = s * i; 下面程序的时间复杂度是 —— O(n2) 1234s = 0;for(i=0;i&lt;n;i++) for(j=0;j&lt;n;j++) s += a[i][j]; 下面程序的时间复杂度是 —— O(log3n) 123i = 1;while(i &lt;= n) i = i * 3; 逻辑图和逻辑结构 B = (K, R)K = {k1, k2, k3, k4, k5, k6, k7, k8, k9}R = {&lt;k1, k2&gt;, &lt;k1, k3&gt;, &lt;k3, k6&gt;, &lt;k3, k4&gt;, &lt;k4, k5&gt;, &lt;k6, k8&gt;, &lt;k6, k7&gt;, &lt;k8, k9&gt;} 线性表 123456789101112Status DeleteSame(SqList &amp;L){//从线性表L中删除值相同的多余元素 int i; while(i &lt;= ListLength(L) - 1){ GetElem(L, i, e1);//获取第i位元素e1 GetElem(L, i+1, e2);//获取第i+1位元素e2 if(e1 != e2)//元素不相同，进行下一个 i++; else//元素相同，删除一个 ListDelete(L, i+1, e); } return OK;} 12345678Status DeleteK(SqList &amp;L, int i, int k){//在线性表L中删除第i个元素起的k个元素 if(i&lt;0 || k&lt;0 || i+k-1&gt;L.length)//i为逻辑位序 return INFEASIBLE; for(int j=i+k-1; j&lt;=L.length-1; j++)//将i+k-1起的所有元素依次移到i-1起的对应位置上 L.elem[j-k] = L.elem[j]; L.length = L.length - k; return OK;} 1234567891011Status Compare_SqList(SqList LA, SqList LB){ //比较字符表LA和LB，并用返回表示结果 //值为正，表示LA&gt;LB //值为负，表示LA&lt;LB //值为零，表示LA=LB //设LA和LB中表长以后存储的字符均为空 for(int i=1; LA.elem[i]||LB.elem[i]; i++) if(LA.elem[i] != LB.elem[i])//出现字符不相同，则可以区分大小 return LA.elem[i] - LB.elem[i]; return 0;} 123456789101112131415Status Delete_Between(LinkList &amp;L, int mink, int maxk){ //删除链表L中值大于mink且小于maxk的所有元素 LinkList p = L, p; while(p-&gt;next-&gt;data &lt;= mink) p = p-&gt;next;//p是最后一个不大于mink的元素 if(p-&gt;next){//如果还有比mink更大的元素 q = p-&gt;next; while(q-&gt;data &lt; maxk){ p-&gt;next = q-&gt;next;//q的第一个不小于maxk的元素 free(q); q = p-&gt;next; } } return OK;} 12345678910111213141516171819202122232425262728293031323334Status ListMergeOppose_L(LinkList &amp;La, LinkList &amp;Lb, LinkList &amp;Lc){ LinkList pa = La-&gt;next; LinkList pb = Lb-&gt;next;//pa和pb分别指向A，B的当前元素 Lc = La; Lc-&gt;next = NULL; while(pa &amp;&amp; pb){ if(pa-&gt;data &lt;= pb-&gt;data){ p = pa-&gt;next; pa-&gt;next = Lc-&gt;next; Lc-&gt;next = pa;//将La的元素插入新表的表头 pa = p; } else{ p = pb-&gt;next; pb-&gt;next = Lc-&gt;next; Lc-&gt;next = pb;//将Lb的元素插入新表的表头 pb = p; } } while(pa){ p = pa-&gt;next; pa-&gt;next = Lc-&gt;next; Lc-&gt;next = pa;//将La的剩余元素插入新表的表头 pa = p; } while(pb){ p = pb-&gt;next; pb-&gt;next = Lc-&gt;next; Lc-&gt;next = pb;//将Lb的剩余元素插入新表的表头 pb = p; } free(Lb); return OK;} 12345678910111213141516171819202122Status Divide_LinkedPoly(LinkedPoly &amp;L, LinkedPoly &amp;La, LinkedPoly &amp;Lb){ //将单向循环链表存储的稀疏多项式L拆成只含奇次项的La和只含偶次项的Lb La = L; Lb = (LinkedPoly)malloc(sizeof(PolyNode)); LinkedPoly p = L-&gt;next; LinkedPoly pa = La; LinkedPoly pb = Lb; while(p != L){ if(p-&gt;data.exp % 2){//奇次项 pa-&gt;next = p; pa = p; } else{//偶次项 pb-&gt;next = p; pb = p; } p = p-&gt;next;//下一个多项式 } pa-&gt;next = La;//将La首尾相连，成循环链表 pb-&gt;next = Lb;//将Lb首尾相连，成循环链表 return OK;} 栈和队列ABCD、ABDC、ACBD、ACDB、BACD、ADCB、BADC、BCAD、BCDA、BDCA、CBAD、CBDA、CDBA、DCBA 队列Q采用顺序存储结构，设队头指针front指向队列头元素位置，队尾指针rear指向队列尾元素的下一个位置，队列的容量(即存储的空间大小)为MAXQSIZE。入队时，若Q.rear==MAXQSIZE，则会发生队列的上溢现象，即使队列中尚余有足够的空间，但元素却不能入队，出现了“假溢出”现象。一般地，可用以下方法解决： (1)采用移动元素的方法。假定空余空间足够，每当有一个新元素入队，就将队列中已有的元素向队头移动一个位置。 (2)每当删去一个队头元素，则可依次移动队列中的元素总是使front指针指向队列中的第一个位置。 (3)采用循环队列方式。将队头、队尾看作是一个首尾相接的循环队列，此时队首仍在队尾之前，作插入和删除运算时仍遵循“先进先出”的原则。 Stack char 队列逆置 12345678910111213141516171819202122232425262728293031Status InitCircleQueue(LinkQueue &amp;Q){ //初始化循环链表表示的队列Q Q.rear = (QueuePtr)malloc(sizeof(QNode)); if(!Q.rear) exit(OVERFLOW); Q.rear-&gt;next = Q.rear;//连成循环 } Status EnCircleQueue(LinkQueue &amp;Q, QElemType e){ //把元素e插入循环链表表示的队列Q p = (QueuePtr)malloc(sizeof(QNode)); if(!p) exit(OVERFLOW); p-&gt;data = e; p-&gt;next = Q.rear-&gt;next;//直接把p加在Q.rear的后面 Q.rear-&gt;next = p; Q.rear = p;//修改尾指针 }Status DeCircleQueue(LinkQueue &amp;Q, QElemType &amp;e){ //从循环链表表示的队列Q头部删除元素e if(Q.rear-&gt;next == Q.rear) return INFEASIBLE;//队列已空 p = Q.rear-&gt;next-&gt;next; e = p-&gt;data; Q.rear-&gt;next-&gt;next = p-&gt;next; if(Q.rear == p) Q.rear = p-&gt;next; free(p); return OK;} 12345678910111213141516int Palindrome_Test(){ //判别字符串是否回文序列，是则返回1，否则返回0 InitStack(S);//初始化栈 InitQueue(Q);//初始化队列 while((c=getchar()) != '@'){ Push(S, c);//进栈 EnQueue(Q, c);//进队列 } while(!StackEmpty(S)){//利用栈：后进先出；队列：先进先出的特点进行比较 Pop(S, a); DeQueue(Q, b); if(a != b) return ERROR; } return OK;} 数组（1）按行优先存储：A[0][0][0][0]，A[0][0][0][1]，A[0][0][1][0]，A[0][0][1][1]，A[0][1][0][0]，A[0][1][0][1]，A[0][1][1][0]，A[0][1][1][1]，A[1][0][0][0]，A[1][0][0][1]，A[1][0][1][0]，A[1][0][1][1]，A[1][1][0][0]，A[1][1][0][1]，A[1][1][1][0]，A[1][1][1][1]。（2)按列优先存储：A[0][0][0][0]，A[1][0][0][0]，A[0][1][0][0]，A[1][1][0][0]，A[0][0][1][0]，A[1][0][1][0]，A[0][1][1][0]，A[1][1][1][0]，A[0][0][0][1]，A[1][0][0][1]，A[0][1][0][1]，A[1][1][0][1]，A[0][0][1][1]，A[1][0][1][1]，A[0][1][1][1]，A[1][1][1][1]。 123456789101112131415161718void EMove_k(int A[n], int k){//把数组A的元素循环右移k位，只用一个辅助空间 for(int i=1;i&lt;=k;i++) if(n%i==0 &amp;&amp; k%i==0)//求n和k的最大公约数p p = i; for(int i=0;i&lt;p;i++){ j = i; m = (i+k)%n; temp = A[i]; while(m != i){//循环右移一步 A[j] = temp; temp = A[m]; A[m] = A[j]; j = m; m = (j+k)%n; } A[i] = temp; }} 1234567891011121314151617181920212223242526/** * 算法1：依题意，先求出每行的最小值元素，放入 min[m] 之中，再求出每列的最大值元素，放入 max[n] 之中，若某元素既在 min[i] 中，又在 max[j] 中，则该元素 A[i][j] 便是马鞍点，找出所有这样的元素，即找到了所有马鞍点。 */void Get_Saddle1(int A[m][n]){ have = 0; for(int i=0;i&lt;m;i++){//计算每行的最小值元素，放入min[m] min[i] = A[i][0]; for(int j=1;j&lt;n;j++) if(A[i][j] &lt; min[i]) min[i] = A[i][j]; } for(int j=0;j&lt;n;j++){//计算每列的最大值元素，放入max[m] max[j] = A[0][j]; for(int i=1;i&lt;m;i++) if(A[i][j] &gt; max[j]) max[j] = A[i][j]; } for(int i=0;i&lt;m;i++) for(int j=0;j&lt;n;j++) if(min[i] == max[j]){//判定是否为马鞍点 print(A[i][j]);//显示马鞍点 have = 1; } if(!have) print(&quot;没有鞍点\\n&quot;);} 123456789101112131415161718/** * 算法2：依题意，先求出某行的最小值元素 min，再判断该 min 是否是其所在列的最大值元素，如果是，则该元素便是马鞍点，找出每一行中所有这样的元素，即找到了所有马鞍点。 */void Get_Saddle2(int A[m][n]){ for(int i=0;i&lt;m;i++){ for(min=A[i][0],j=0;j&lt;n;j++) if(A[i][j] &lt; min)//求一行中的最小值 min = A[i][j]; for(j=0;j&lt;n;j++) if(A[i][j] == min){//判断该最小值是否为马鞍点 for(flag=1,k=0;k&gt;m;k++) if(min &lt; A[k][j]) flag = 0; if(flag) print(A[i][j]);//显示马鞍点 } } } 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//稀疏矩阵的三元组顺序表存储表示#define MAXSIZE 12500 //假设非零元素个数的最大值为12500 typedef struct{ int i,j;//该非零元的行下标和列下标 ElemType v;//非零元值 }Teiple;typedef struct{ Triple data[MAXSIZE + 1];//非零元三元组，data[0]未用 int mu, nu, tu;//矩阵的行数、列数和非零元个数 }TSMatrix;void TSMatrix_Add(TSMatrix A, TSMatrix B, TSMatrix &amp;C){//三元组顺序表表示的稀疏矩阵加法 C.mu = A.mu; C.nu = A.nu; C.tu = 0; pa = 1; pb = 1; pc = 1; for(row=1;row&lt;=A.mu;row++){//对居中的每一行进行相加 while(A.data[pa].i &lt; row &amp;&amp; pa &lt;= A.tu) pa++; while(B.data[pb].i &lt; row &amp;&amp; pb &lt;= B.tu) pb++; while(A.data[pa].i == row &amp;&amp; B.data[pb].i == row &amp;&amp; pa &lt;= A.tu &amp;&amp; pb &lt;= B.tu){//行列相等的元素 if(A.data[pa].j == B.data[pb].j){ ce = A.data[pa].e + B.data[pb].e; if(ce){//和不为0 C.data[pc].i = row; C.data[pc].j = A.data[pa].j; C.data[pc].e = ce; pa++; pb++; pc++; } } else if(A.data[pa].j &gt; B.data[pb].j){ C.data[pc].i = row; C.data[pc].j = B.data[pb].j; C.data[pc].e = B.data[pb].e; pb++; pc++; } else{ C.data[pc].i = row; C.data[pc].j = A.data[pa].j; C.data[pc].e = A.data[pa].e; pa++; pc++; } } while(A.data[pa]==row &amp;&amp; pa&lt;=A.tu){//插入A中剩余的元素（第row行） C.data[pc].i = row; C.data[pc].j = A.data[pa].j; C.data[pc].e = A.data[pa].e; pa++; pc++; } while(B.data[pb]==row &amp;&amp; pb&lt;=B.tu){//插入B中剩余的元素（第row行） C.data[pc].i = row; C.data[pc].j = B.data[pb].j; C.data[pc].e = B.data[pb].e; pb++; pc++; } } C.tu = pc;} 串KMP算法详解 排序 可以把排序算法的输出解释为对一个待排序的下标求一种排列，使得序列中的元素按照升序排序。例如，待排序序列是 (a1, a2, … , an)，则输出是这些元素的一个排序。因此，对于一个任意的 n 个元素的序列排序后，可能的输出有 n! 个，即有 n! 个不同的比较路径。在排序过程中，每次比较会有两种情况出现，若整个排序需要进行 t 次比较，则会出现 2t 种情况，于是有：22 ≥ n!，即 t ≥ log2(n!)。当待排序元素个数 n 非常大时，有 t ≥ log2(n!) ≈ nlog2n。 （1）直接插入排序初始关键字：[503] 017 512 061 908 170 897 275 653 426 154i=2：（017）[017 503] 512 061 908 170 897 275 653 426 154i=3：（512）[017 503 512] 061 908 170 897 275 653 426 154i=4：（061）[017 061 503 512] 908 170 897 275 653 426 154i=5：（908）[017 061 503 512 908] 170 897 275 653 426 154i=6：（170）[017 061 170 503 512 908] 897 275 653 426 154i=7：（897）[017 061 170 503 512 897 908] 275 653 426 154i=8：（275）[017 061 170 275 503 512 897 908] 653 426 154i=9：（653）[017 061 170 275 503 512 653 897 908] 426 154i=10：（426）[017 061 170 275 426 503 512 653 897 908] 154i=11：（154)[017 061 154 170 275 426 503 512 653 897 908] （2）希尔排序（增量 d[1]=5 ） 初始关键字：503 017 512 061 908 170 897 275 653 426 154一趟排序结果：154 017 275 061 426 170 897 512 653 908 503二趟排序结果：154 017 275 061 426 170 503 512 653 908 897三趟排序结果：017 061 154 170 275 426 503 512 653 897 908 （3）快速排序 初始关键字： 503 017 512 061 908 170 897 275 653 426 154一次划分结果： 154 017 426 061 275 170 [503] 897 653 908 512分别快排结果： 061 017 [154] 426 275 170 [503] 897 653 908 512 [017] [061] [154] 426 275 170 [503] 897 653 908 512 [017] [061] [154] 170 275 [426] [503] 897 653 908 512 [017] [061] [154] [170] [275] [426] [503] 897 653 908 512 [017] [061] [154] [170] [275] [426] [503] 512 653 [897] [908] 排序结果：[017] [061] [154] [170] [275] [426] [503] [512] [653] [897] [908] （4）堆排序 初始关键字：503 017 512 061 908 170 897 275 653 426 154 初始堆：908 653 897 503 426 170 512 275 061 017 154输出堆顶 908：154 653 897 503 426 170 512 275 061 017 [908]调整后的新堆：897 653 512 503 426 170 154 275 061 017 [908]输出堆顶 897：017 653 512 503 426 170 154 275 061 [897 908]调整后的新堆：653 503 512 275 426 170 154 017 061 [897 908]输出堆顶 653：061 503 512 275 426 170 154 017 [653 897 908]调整后的新堆：512 503 170 275 426 061 154 017 [653 897 908]输出堆顶 512：017 503 170 275 426 061 154 [512 653 897 908]调整后的新堆：503 426 170 275 017 061 154 [512 653 897 908]输出堆顶 503：154 426 170 275 017 061 [503 512 653 897 908]调整后的新堆：426 275 170 154 017 061 [503 512 653 897 908]输出堆顶 426：061 275 170 154 017 [426 503 512 653 897 908]调整后的新堆：275 154 170 061 017 [426 503 512 653 897 908]输出堆顶 275：017 154 170 061 [275 426 503 512 653 897 908]调整后的新堆：170 154 017 061 [275 426 503 512 653 897 908]输出堆顶 170：061 154 017 [170 275 426 503 512 653 897 908]调整后的新堆：154 061 017 [170 275 426 503 512 653 897 908]输出堆顶 154：017 061 [154 170 275 426 503 512 653 897 908]调整后的新堆：061 017 [154 170 275 426 503 512 653 897 908]输出堆顶 061：017 [061 154 170 275 426 503 512 653 897 908] 排序结果：[017 061 154 170 275 426 503 512 653 897 908] （5）归并排序 初始关键字：[503] [017] [512] [061] [908] [170] [897] [275] [653] [426] [154]一趟归并之后：[017 503] [061 512] [170 908] [275 897] [426 653] [154]二趟归并之后：[017 061 503 512] [170 275 897 908] [154 426 653]三趟归并之后：[017 061 170 275 503 512 897 908] [154 426 653]四趟归并之后：[017 061 154 170 275 426 503 512 653 897 908] （6）基数排序初始关键字： 503 017 512 061 908 170 897 275 653 426 154第一趟分配：Q[0] Q[1] Q[2] Q[3] Q[4] Q[5] Q[6] Q[7] Q[8] Q[9]第一趟分配：170 061 512 503 154 275 426 017 908 653 897第一趟收集：170 061 512 503 653 154 275 426 017 897 908第二趟分配：Q[0] Q[1] Q[2] Q[3] Q[4] Q[5] Q[6] Q[7] Q[8] Q[9]第二趟分配：503 512 426 653 061 170 897 908 017 154 275第二趟收集：503 908 512 017 426 653 154 061 170 275 897第三趟分配：Q[0] Q[1] Q[2] Q[3] Q[4] Q[5] Q[6] Q[7] Q[8] Q[9] 017 154 275 426 503 653 897 908 061 170 512第三趟收集：017 061 154 170 275 426 503 512 653 897 908 采用基数排序方法时间复杂度最佳。因为这里英文单词的长度相等，且英文单词是由 26 个字母组成的，满足进行基数排序的条件，同时，依题意，m&lt;&lt;n，基数排序的时间复杂性由 O(m(n+rm)) 变成 O(n)，因此时间复杂性最佳。 （1）当每个记录本身的信息量很大时，应尽量减少记录的移动,直接插入、冒泡和简单选择排序的平均时间复杂度为 O(n2)，但简单选择排序中记录移动的次数最少，所以采用简单选择排序为佳。 （2）在直接插入、冒泡和简单选择排序中，直接插入和冒泡排序是稳定的，且两者在关键码呈基本正序时都居于最好时间复 O(n)，因此可从中任选一个方法。 （3）就平均时间性能而言,基于比较和移动的排序方法中快速排序最佳。 （4）快速排序在最坏情况的时间复杂度为 O(n2)，而堆排序和二路归并排序最坏情况的时间复杂度为 O(nlog2n)，其中堆排序不稳定，所以应选择二路归并排序。 （5）按照关键码的结构，采用基数排序为好。 12345678910111213141516171819#define LIST_INIT_SIZE 100#define LISTINCREMENT 10typedef struct{ ElemType *elem;//存储空间基址 int length;//当前长度 int listsize;//当前分配的存储容量以一数据元素存储长度为单位 }SqList;void partition(SqList &amp;L){ int i = 1, j = L.length - 1; while(i &lt; j){ while(i&lt;j &amp;&amp; L.elem[i]%2!=0) i++; while(i&lt;j &amp;&amp; L.elem[j]%2==0) j--; if(i &lt; j) L.elem[i]&lt;--&gt;L.elem[j]; }} 123456789101112void Divide(int L[], int n){//将L中值为负的记录调到非负的记录之前 low = 0; high = n - 1; while(low &lt; high){ while(low&lt;high &amp;&amp; L[high]&gt;=0)//以0作为虚拟枢轴 high--; L[low]&lt;--&gt;L[high]; while(low&lt;high &amp;&amp; L[low]&lt;0) low++; L[low]&lt;--&gt;L[high]; }} 12345678910111213141516171819202122232425/** * 设立三个指针 i、j、k，其中：j 表示当前元素，i 以前的元素全部为红色，k 以后的元素全部为蓝色。可以根据 j 的颜色，把其交换到序列的前部或后部。 */typedef enum {RED, WHITE, BLUE} color;//三种颜色 void Flag_Arrange(color a[], int n){ //把由三种颜色组成的序列重排为按照红、白、蓝的顺序排列 i = 0; j = 0; k = n - 1; while(j &lt;= k){ switch(a[j]){ case RED: a[i]&lt;--&gt;a[j]; i++; j++; break; case WHITE: j++; break; case BLUE: a[j]&lt;--&gt;a[k]; k--; } } } 查找 1234567891011121314151617typedef struct BiTNode { TElemType data; struct BiTNode *lchild, *rchild;//左右孩子指针 }BiTNode, *BiTree; int last = 0, flag = 1;int Is_BSTree(BiTree T){ //判断二叉树T是否二叉排序树，是则返回1，否则返回0 if(T-&gt;lchild &amp;&amp; flag) Is_BSTree(T-&gt;lchild); if(T-&gt;data &lt; last)//与其中序前驱相比较 flag = 0; last = T-&gt;data; if(T-&gt;rchild &amp;&amp; flag) Is_BSTree(T-&gt;rchild); return flag;} 1234567891011121314typedef struct BiTNode { TElemType data; struct BiTNode *lchild, *rchild;//左右孩子指针 }BiTNode, *BiTree; void Print_NLT(BiTree T, int x){//从大到小输出二叉排序树T中所有不小于x的元素 if(T-&gt;lchild) Print_NLT(T-&gt;lchild); if(T-&gt;data &lt; x)//当遇到小于x的元素时立即结束运行 exit(); printf(&quot;%d&quot;, T-&gt;data); if(T-&gt;rchild) Print_NLT(T-&gt;rchild);//先有后左的中序遍历 } 树 ​ 当 n=2 时，要使其成为最优二叉树，必须使两个结点都成为叶子结点。​ 设 n=k 时成立，则当 n=k+1 时，要使其成为最优，必须用 k 个结点的哈夫曼树与第 k+1 个结点组成一个新的最优二叉树，所以 n=k+1 时也成立。 1234567891011121314151617181920212223242526#define MAX_TREE_SIZE 100 //二叉树的最大结点数 typedef TElemType SqBiTree[MAX_TREE_SIZE];//1号单元存储根结点 void PreOrder_Sq(SqBiTree BT){//先序遍历二叉树BT InitStack(S); p = 1;//p指示当前结点的位置 while(p&lt;=n &amp;&amp; !StackEmpty(S)){ while(p &lt;= n){ Visit(BT[p]); Push(S, p); p = 2 * p; } if(!StackEmpty(S)){//栈非空，遍历右子树 Pop(S, p); p = p * 2 + 1; } }}void PreOrder_Sq_Recursion(SqBiTree BT, int t, int n){//先序遍历二叉树（递归） if(t &lt;= n){ Visit[BT[t]]; PreOrder_Sq_Recursion(BT, t*2, n); PreOrder_Sq_Recursion(BT, t*2+1, n); }} 1234567891011121314typedef struct BiTNode { TElemType data; struct BiTNode *lchild, *rchild;//左右孩子指针 }BiTNode, *BiTree; int LeadCount_BiTree(BiTree T){//求二叉树中叶子结点的数目 if(!T)//空树，没有叶子 return 0; else if(!T-&gt;lchild &amp;&amp; !T-&gt;rchild)//叶子结点 return 1; else//左、右子树的叶子数相加 return LeadCount_BiTree(T-&gt;lchild) + LeadCount_BiTree(T-&gt;rchild);} 1234567891011121314typedef struct BiTNode { TElemType data; struct BiTNode *lchild, *rchild;//左右孩子指针 }BiTNode, *BiTree; int NodeCount_BiTree(BiTree T){//求二叉树中所有结点的数目 if(!T)//空树，没有叶子 return 0; else{ int num1 = NodeCount_BiTree(T-&gt;lchild); int num2 = NodeCount_BiTree(T-&gt;rchild); return num1 + num2 + 1; }} 1234567891011121314151617typedef struct BiTNode { TElemType data; struct BiTNode *lchild, *rchild;//左右孩子指针 }BiTNode, *BiTree; int BranchCount_BiTree(BiTree T){//求二叉树中所有单分支结点数目 if(!T)//空树，没有叶子 return 0; else{ int num1 = NodeCount_BiTree(T-&gt;lchild); int num2 = NodeCount_BiTree(T-&gt;rchild); if((!T-&gt;lchild &amp;&amp; T-&gt;rchild) || (T-&gt;lchild &amp;&amp; !T-&gt;rchild)) return num1 + num2 + 1; else return num1 + num2; }} 123456789101112typedef struct BiTNode { TElemType data; struct BiTNode *lchild, *rchild;//左右孩子指针 }BiTNode, *BiTree; void Revolute_BiTree(BiTree T){//交换所有结点的左右子树 Swap(T-&gt;lchild, T-&gt;rchild);//交换左右子树 if(T-&gt;lchild) Revolute_BiTree(T-&gt;lchild);//左子树交换自己的左右子树 if(T-&gt;rchild) Revolute_BiTree(T-&gt;rchild);//右子树交换自己的左右子树 } 123456789101112131415161718192021222324252627typedef struct BiTNode { TElemType data; struct BiTNode *lchild, *rchild;//左右孩子指针 }BiTNode, *BiTree; int Get_Sub_Depth(BiTree T, int x){//求二叉树中以值为x的结点为根的子树深度 if(T-&gt;data == x){ printf(Get_Depth(T));//找到了值为x的结点，求其深度 return 0; } else{ if(T-&gt;lchild)//在左子树中继续寻找 Get_Sub_Depth(T-&gt;lchild, x); if(T-&gt;rchild)//在右子树中继续寻找 Get_Sub_Depth(T-&gt;rchild, x); }}int Get_Depth(BiTree T){//求子树深度的递归算法 if(!T) return 0; else{ m = Get_Depth(T-&gt;lchild); n = Get_Depth(T-&gt;rchild); return (m&gt;n?m:n) + 1; }} 12345678910111213141516171819202122typedef struct BiTNode { TElemType data; struct BiTNode *lchild, *rchild;//左右孩子指针 }BiTNode, *BiTree; void NR_PreOrder(BiTree bt){//非递归先序遍历二叉树 InitStack(S); if(!bt) return; p = bt; while(p || !StackEmpty(S)){ while(p){//到达最左边的结点 Visit(p-&gt;data);//访问结点的数据域 Push(S, p);//将当前指针p压栈 p = p-&gt;lchild;//指针指向p的左孩子 } if(!StackEmpty(S)){ Pop(S, p);//从栈中弹出栈顶元素 p = p-&gt;rchild;//指针指向p的右孩子结点 } }} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758void CreateBiTree2(BiTree &amp;T,char str[]){//建立二叉树链表(非递归)广义表 BiTree S[1000];//存放父节点 int flag = 0;//存入为左孩子还是右孩子，1为左孩子，2为右孩子 int k = 0;//记入前一个父节点的存放位置 BiTree p; p = (BiTree)malloc(sizeof(BiTNode));//申请根节点的空间 p-&gt;data = str[0]; p-&gt;lchild = NULL; p-&gt;rchild = NULL; int i; for(i=1;str[i] != '#';i++){ //printf(&quot;1\\n&quot;); if(str[i] == '('){//将父节点存放入数组中，并且下一个存放左孩子 flag = 1; S[k++] = p; } else if(str[i] == ','){//下一个为存放右孩子 flag = 2; } else if(str[i] == ')'){//将一个父节点出数组 k--; } else{ p = (BiTree)malloc(sizeof(BiTNode));//申请一个孩子的空间 p-&gt;data = str[i]; p-&gt;lchild = NULL; p-&gt;rchild = NULL; if(flag == 1){//左孩子 S[k-1]-&gt;lchild = p; } else if(flag == 2){//右孩子 S[k-1]-&gt;rchild = p; } } } T = S[0];//将根返回 }void Level_Order(BiTree BT){//按层次、非递归遍历二叉树 if(!BT) return; InitQueue(Q); p = BT;//初始化 EnQueue(Q, p);//访问根结点，并将根结点入队 while(!QueueEmpty(Q)){//当队非空时重复执行下列操作 DeQueue(Q, p);//出队 Visit(p); if(!p-&gt;lchild) EnQueue(Q, p-&gt;lchild);//处理左孩子 if(!p-&gt;rchild) EnQueue(Q, p-&gt;rchild);//处理右孩子 }} 假设此二叉树总结点数为 n，度为 0 的结点数为 n0，度为 1 的结点数为 n1，度为 2 的结点数为 n2，则：n = n0 + n1 + n2（1） 在二叉树中，除了根结点外，其余结点都有一个分支进入，设 B 为分支总数，则：n = B + 1，由于这些分支是由度为 1 或度为 2 的结点射出的，所以有：B = n1 + 2n2，于是有：n = n1 + 2n2 + 1（2） 由（1）和（2)可得：n0 = n2 + 1 证毕。 假设此二叉树的深度为 k，根据二叉树性质 2 及完全二叉树的定义得到：2k-1-1&lt;n≤2k-1，即 2k-1≤n&lt;2k 于是 k-1≤log2n&lt;k 即 k = ⌊log2n⌋ + 1。 （1）第 H 层上的结点数目为 k^H-1^。（2）如果 p 是其双亲的最小的孩子（右孩子），则 p 减去根结点的一个结点，应是 k 的整数倍，该整数即为所在的组数，每一组为一棵满 k 叉树，正好应为双亲结点的编号。如果 p 是其双亲的最大的孩子（左孩子），则 p+k-1 为其最小的弟弟，再减去一个根结点，除以 k，即为其双亲结点的编号。 综合来说，对于 p 是左孩子的情况，i=(p+k-1)/k；对于 p 是右孩子的情况，i=(p-1)/k，如果左孩子的编号为 p，则其右孩子编号必为 p+k-1 ，所以，其双亲结点的编号为 i=⌊(p+k-2)/k⌋，向下取整。（3）结点 p 的右孩子的编号为 kp+1，左孩子的编号为 kp+1-k+1=k(p-1)+2，第 i 个孩子的编号为 k(p-1)+2+i-1=kp-k+i+1。（4）当(p-1)%k != 0时，结点 p 有右兄弟，其右兄弟的编号为 p+1。 根据树的定义，在一棵树中，除树根结点外，每个结点有且仅有一个前驱结点，也就是说，每个结点与指向它的一个分支一一对应，所以除树根结点之外的结点树等于所有结点的分支数，即度数，从而可得树中的结点数等于所有结点的度数加 1。总结点数为：1+n1+2n2+3n3+…+knk 度为 0 的结点数应为总结点数减去度不为 0 的结点数的总和，即n0 = 1+n1+2n2+3n3+…+knk-(n1+n2+n3+…+nk) 图 数学归纳法 当 n=2 时，图G连通只需一条边，命题成立。 设 n=k(k&gt;2) 时命题成立，即当 n=k 时，图G至少有 k-1 条边。 当 n=k+1(k2) 时，由上述假设可知，图G中已有 k 个顶点是连通的，且至少有 k-1 条边。现增加一个顶点 p 后，若 p 与图中已有的 k 个顶点没有边，显然 p 与图 G 不连通。若要求 k+1 个顶点组成的图是连通图，p 必须与图 G 原有的 k 个顶点中的任何一个顶点有边相连，即 k 条边就可使图连通。因此，当 n=k+1 时，图 G 至少有 k 条边，命题成立。证毕。 关键路径只有一条：（α，G，H，K，J，E，ω)","link":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BD%E7%9A%AE%E4%B9%A6%E5%A4%8D%E4%B9%A0%E9%A2%98.html"}],"tags":[{"name":"git命令","slug":"git命令","link":"/tags/git%E5%91%BD%E4%BB%A4/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"齐次","slug":"齐次","link":"/tags/%E9%BD%90%E6%AC%A1/"},{"name":"特解","slug":"特解","link":"/tags/%E7%89%B9%E8%A7%A3/"},{"name":"数学","slug":"数学","link":"/tags/%E6%95%B0%E5%AD%A6/"},{"name":"多元函数微积分学","slug":"多元函数微积分学","link":"/tags/%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E7%A7%AF%E5%88%86%E5%AD%A6/"},{"name":"node","slug":"node","link":"/tags/node/"},{"name":"npm","slug":"npm","link":"/tags/npm/"},{"name":"PicGo","slug":"PicGo","link":"/tags/PicGo/"},{"name":"Typora","slug":"Typora","link":"/tags/Typora/"},{"name":"Chrome","slug":"Chrome","link":"/tags/Chrome/"},{"name":"NAT","slug":"NAT","link":"/tags/NAT/"},{"name":"二叉排序树","slug":"二叉排序树","link":"/tags/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/"},{"name":"关键路径","slug":"关键路径","link":"/tags/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/"},{"name":"线性表","slug":"线性表","link":"/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"},{"name":"快速转置","slug":"快速转置","link":"/tags/%E5%BF%AB%E9%80%9F%E8%BD%AC%E7%BD%AE/"},{"name":"三元组","slug":"三元组","link":"/tags/%E4%B8%89%E5%85%83%E7%BB%84/"},{"name":"红黑树","slug":"红黑树","link":"/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"},{"name":"结构体","slug":"结构体","link":"/tags/%E7%BB%93%E6%9E%84%E4%BD%93/"},{"name":"指针","slug":"指针","link":"/tags/%E6%8C%87%E9%92%88/"},{"name":"KMP","slug":"KMP","link":"/tags/KMP/"},{"name":"LeetCode","slug":"LeetCode","link":"/tags/LeetCode/"},{"name":"TCP","slug":"TCP","link":"/tags/TCP/"},{"name":"Spring","slug":"Spring","link":"/tags/Spring/"},{"name":"试题","slug":"试题","link":"/tags/%E8%AF%95%E9%A2%98/"},{"name":"Mybatis","slug":"Mybatis","link":"/tags/Mybatis/"}],"categories":[{"name":"git","slug":"git","link":"/categories/git/"},{"name":"Math","slug":"Math","link":"/categories/Math/"},{"name":"node","slug":"node","link":"/categories/node/"},{"name":"tools","slug":"tools","link":"/categories/tools/"},{"name":"内网穿透","slug":"内网穿透","link":"/categories/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"},{"name":"数据结构","slug":"数据结构","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"计算机网络","slug":"计算机网络","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"SSM","slug":"SSM","link":"/categories/SSM/"}]}