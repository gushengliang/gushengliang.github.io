{"pages":[],"posts":[{"title":"absolute和relative定位","text":"relative 定位 相对于 自身 定位 absolute 定位 相对于 最近的一层父级定位元素 定位 定位元素有四种：relative absolute fixed 或 body","link":"/CSS/absolute%20%E5%92%8C%20relative%20%E5%AE%9A%E4%BD%8D.html"},{"title":"display:table-cell在布局上的应用","text":"display: table-cell在布局上的应用应用一：元素垂直居中使用table-cell搭配vertical-align可以十分简单地完成元素垂直居中： 12345678910&lt;div id=&quot;box&quot;&gt; &lt;div id=&quot;content&quot;&gt;content goes here...&lt;/div&gt;&lt;/div&gt;#box { display: table-cell; width: 200px; height: 100px; vertical-align: middle;} 应用二：自适应两栏布局使用table-cell完成“左侧宽度固定，右侧宽度自适应”的两栏布局： 123456789101112131415161718&lt;div id=&quot;container&quot;&gt; &lt;div id=&quot;left&quot;&gt;content goes here...&lt;/div&gt; &lt;div id=&quot;right&quot;&gt;content goes here...&lt;/div&gt;&lt;/div&gt;#left { float: left; width: 150px;}#right { display: table-cell; width: 9999px;}#container { overflow: auto;} 应用三：等高布局12345678910111213141516&lt;div id=container&gt; &lt;div id=&quot;left&quot;&gt;content goes here...&lt;/div&gt; &lt;div id=&quot;right&quot;&gt;content goes here...&lt;/div&gt;&lt;/div&gt;#container { /*另一种实现等高 display: flex;*/ display: table-row;}#left,#right { display: table-cell; width: 100px;} 应用四：等宽布局123456789101112131415&lt;div id=&quot;container&quot;&gt; &lt;div class=&quot;cell&quot;&gt;content goes here...&lt;/div&gt; &lt;div class=&quot;cell&quot;&gt;content goes here...&lt;/div&gt; &lt;div class=&quot;cell&quot;&gt;content goes here...&lt;/div&gt;&lt;/div&gt;#container { display: table; table-layout: fixed; width: 450px;}.cell { display: table-cell;}","link":"/CSS/display%20table-cell%E5%9C%A8%E5%B8%83%E5%B1%80%E4%B8%8A%E7%9A%84%E5%BA%94%E7%94%A8.html"},{"title":"两列布局css","text":"方案一：123456789101112131415//父盒子#parent{ width: 100%; position: relative; }//左侧子盒子定宽#left { width: 400px; /* 左侧定宽 */ position: absolute;}//右侧子盒子自适应#right { position: absolute; left: 400px; /* 右侧距离父盒子定宽 */} 方案二：123456789101112131415//父盒子#parent{ width: 100%; /* 子元素 - 水平排列 */ display: flex;}//左侧子盒子定宽#left { width: 400px; /* 定宽 */}//右侧子盒子自适应#right { /* 右边自适应设置 100% - 400 */ flex:1;} 方案三：1234567891011121314//父盒子#parent{ width: 100%; display: table;}//左侧子盒子定宽#left { display:table-cell; /* td */ width: 400px; /* 定宽 */}//右侧子盒子自适应#right { display:table-cell; /* td */ }","link":"/CSS/%E4%B8%A4%E5%88%97%E5%B8%83%E5%B1%80css.html"},{"title":"解决GitHub访问不了问题","text":"进入在线DNS解析 查询github.com和raw.githubusercontent.com的A记录 转到C:\\Windows\\System32\\drivers\\etc,打开host文件添加以下内容 host123# github20.205.243.166 github.com185.199.110.133 raw.githubusercontent.com 保存并退出以后就可以访问GitHub了。","link":"/Github/%E8%A7%A3%E5%86%B3GitHub%E8%AE%BF%E9%97%AE%E4%B8%8D%E4%BA%86%E9%97%AE%E9%A2%98.html"},{"title":"Collection集合和Map集合","text":"集合一共分为两种:Collection/Map Collection List Set Map HashMap TreeMap Hashtable Collection集合List集合使用for循环输出1234567891011121314public static void main(String[] args) { // 创建ArrayList集合的对象 List&lt;Person&gt; persons = new ArrayList&lt;Person&gt;(); persons.add(new Person(&quot;张三&quot;, 23, &quot;男&quot;)); persons.add(new Person(&quot;李四&quot;, 31, &quot;女&quot;)); persons.add(new Person(&quot;王五&quot;, 22, &quot;男&quot;)); persons.add(new Person(&quot;赵六&quot;, 27, &quot;女&quot;)); // 输出集合中对象的姓名 for (int i = 0; i &lt; persons.size(); i++) { System.out.println(persons.get(i).getName()); } } 张三 李四 王五 赵六 使用for…each循环输出for…each其实是一个专门用来输出对象集合或者数组的循环。 语法: for(数据类型 对象:对象集合){ 执行的语句; } 案例: 1234567891011121314public static void main(String[] args) { // 创建ArrayList集合的对象 List&lt;Person&gt; persons = new ArrayList&lt;Person&gt;(); persons.add(new Person(&quot;张三&quot;, 23, &quot;男&quot;)); persons.add(new Person(&quot;李四&quot;, 31, &quot;女&quot;)); persons.add(new Person(&quot;王五&quot;, 22, &quot;男&quot;)); persons.add(new Person(&quot;赵六&quot;, 27, &quot;女&quot;)); // 输出集合中对象的姓名 for (Person per : persons) { System.out.println(per.getName()); } } 张三 李四 王五 赵六 使用迭代器输出123456789101112131415public static void main(String[] args) { // 创建ArrayList集合的对象 List&lt;Person&gt; persons = new ArrayList&lt;Person&gt;(); persons.add(new Person(&quot;张三&quot;, 23, &quot;男&quot;)); persons.add(new Person(&quot;李四&quot;, 31, &quot;女&quot;)); persons.add(new Person(&quot;王五&quot;, 22, &quot;男&quot;)); persons.add(new Person(&quot;赵六&quot;, 27, &quot;女&quot;)); // 输出集合中对象的姓名 Iterator&lt;Person&gt; iterator = persons.iterator(); // 获取迭代器对象 while (iterator.hasNext()) { // 判断是否有下一个对象 System.out.println(iterator.next().getName()); // 获取对象 } } 张三 李四 王五 赵六 Set集合List类型的集合中添加的元素是可以重复添加但是有序，而Set集合中不能重复添加对象，而且没有顺序。 Set集合在开发中常用的子类有两个： HashSet TreeSet HashSetHashSet是Set接口的一个子类，主要的特点是：里面不能存放重复元素，而且是采用散列的存储方式，所以是没有顺序的。 123456public static void main(String[] args) { // 创建集合的对象 HashSet&lt;String&gt; hashSet = new HashSet&lt;String&gt;(); System.out.println(hashSet);} [] 输出对象的时候发现其实和List集合没有太大的区别。 向集合中添加重复的内容123456789101112public static void main(String[] args) { // 创建集合的对象 HashSet&lt;String&gt; hashSet = new HashSet&lt;String&gt;(); // 添加重复的数据 hashSet.add(&quot;lvjie&quot;); hashSet.add(&quot;edu&quot;); hashSet.add(&quot;lvjie&quot;); hashSet.add(&quot;com&quot;); System.out.println(hashSet);} [com, org, edu, lvjie] 添加完成后发现HashSet集合存放对象是无序的。在添加完重复的内容以后，在集合中存放的重复内容只能有一个。 输出集合的内容for…each123456789101112public static void main(String[] args) { // 创建集合的对象 HashSet&lt;String&gt; hashSet = new HashSet&lt;String&gt;(); // 添加正常的数据 hashSet.add(&quot;lvjie&quot;); hashSet.add(&quot;edu&quot;); hashSet.add(&quot;com&quot;); for (String str : hashSet) { System.out.println(str); }} com edu lvjie 迭代器输出1234567891011121314public static void main(String[] args) { // 创建集合的对象 HashSet&lt;String&gt; hashSet = new HashSet&lt;String&gt;(); // 添加正常的数据 hashSet.add(&quot;lvjie&quot;); hashSet.add(&quot;edu&quot;); hashSet.add(&quot;com&quot;); Iterator&lt;String&gt; iterator = hashSet.iterator(); while (iterator.hasNext()) { System.out.println(iterator.next()); }} com edu lvjie 自定义的类的对象输出自定义Person类12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.lvjie.entity;public class Person { private String name; private Integer age; private String sex; public Person(String name, Integer age, String sex) { this.name = name; this.age = age; this.sex = sex; } public Person() {} public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } public String getSex() { return sex; } public void setSex(String sex) { this.sex = sex; } @Override public String toString() { return &quot;Person [name=&quot; + name + &quot;, age=&quot; + age + &quot;, sex=&quot; + sex + &quot;]&quot;; }} 12345678910public static void main(String[] args) { HashSet&lt;Person&gt; hashSet = new HashSet&lt;Person&gt;(); // 添加对象 hashSet.add(new Person(&quot;张三&quot;, 23, &quot;男&quot;)); hashSet.add(new Person(&quot;李四&quot;, 31, &quot;女&quot;)); hashSet.add(new Person(&quot;王五&quot;, 22, &quot;男&quot;)); hashSet.add(new Person(&quot;赵六&quot;, 27, &quot;女&quot;)); System.out.println(hashSet);} [Person [name=王五, age=22, sex=男], Person [name=张三, age=23, sex=男], Person [name=李四, age=31, sex=女], Person [name=赵六, age=27, sex=女]] TreeSetTreeSet集合中存放的内容需要排序，而这里的排序不是添加内容时的顺序而是要按照指定的属性来完成对象的排序操作。 123456public static void main(String[] args) { // 创建集合的对象 TreeSet&lt;String&gt; treeSet = new TreeSet&lt;String&gt;(); System.out.println(treeSet);} [] 可以发现TreeSet和HashSet类的操作其实没有太大的区别。 12345678910111213public static void main(String[] args) { // 创建集合的对象 TreeSet&lt;String&gt; treeSet = new TreeSet&lt;String&gt;(); // 添加正常的数据 treeSet.add(&quot;lvjie&quot;); treeSet.add(&quot;edu&quot;); treeSet.add(&quot;admin&quot;); treeSet.add(&quot;com&quot;); treeSet.add(&quot;admin&quot;); System.out.println(treeSet);} [admin, com, edu, lvjie] 向TreeSet集合中添加完成后，内容是有序的，这里的有序不是添加内容的顺序，而是内容按照一定的方式进行排序了，但是添加的重复内容就只能有一个存放在此集合中。 自定义的类的对象输出123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.lvjie.entity;public class Person implements Comparable&lt;Person&gt; { // 为了给对象排序 private String name; private Integer age; private String sex; public Person(String name, Integer age, String sex) { this.name = name; this.age = age; this.sex = sex; } public Person() {} public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } public String getSex() { return sex; } public void setSex(String sex) { this.sex = sex; } @Override public String toString() { return &quot;Person [name=&quot; + name + &quot;, age=&quot; + age + &quot;, sex=&quot; + sex + &quot;]&quot;; } @Override public int compareTo(Person per) { if (this.age &lt; per.getAge()) { return -1; } else if (this.age &gt; per.getAge()) { return 1; } else { return 0; } }} [Person [name=王五, age=22, sex=男], Person [name=张三, age=23, sex=男], Person [name=赵六, age=27, sex=女], Person [name=李四, age=31, sex=女]] 在TreeSet集合中集合会给存储的对象进行排序，而这个排序的操作是由Comparable接口来完成的，所以自定义类一定要实现Comparable接口，这也是和HashSet的不同所在。 Map集合HashMap123456public static void main(String[] args) { // 创建HashMap类的对象 HashMap&lt;Integer, String&gt; hashMap = new HashMap&lt;Integer, String&gt;(); System.out.println(hashMap);} {} 输出代表了Map类的对象是一个键值对对象。 在Map集合中是通过key值获取对应的内容的。 public V get(Object key){} 12345678910111213public static void main(String[] args) { // 创建HashMap类的对象 HashMap&lt;Integer, String&gt; hashMap = new HashMap&lt;Integer, String&gt;(); // 添加内容 hashMap.put(1, &quot;lvjie&quot;); hashMap.put(2, &quot;edu&quot;); hashMap.put(3, &quot;com&quot;); System.out.println(hashMap); // 获取key为2的对应的值 System.out.println(hashMap.get(2));} {1=lvjie, 2=edu, 3=com} edu 获取Map集合中的所有value值 public Collection values(){} 12345678910111213141516public static void main(String[] args) { // 创建HashMap类的对象 HashMap&lt;Integer, String&gt; hashMap = new HashMap&lt;Integer, String&gt;(); // 添加内容 hashMap.put(11, &quot;lvjie&quot;); hashMap.put(22, &quot;edu&quot;); hashMap.put(33, &quot;com&quot;); System.out.println(hashMap); // 获取全部的value值 Collection&lt;String&gt; list = hashMap.values(); for (String value : list) { System.out.println(value); }} {33=com, 22=edu, 11=lvjie} com edu lvjie TreeMapTreeMap是可以进行排序的，但是它的排序是给Map集合中的key(键)进行排序。 1234567891011public static void main(String[] args) { // 创建TreeMap类的对象 TreeMap&lt;String, String&gt; treeMap = new TreeMap&lt;String, String&gt;(); // 向集合中添加内容 treeMap.put(&quot;num2&quot;, &quot;edu&quot;); treeMap.put(&quot;num3&quot;, &quot;com&quot;); treeMap.put(&quot;num4&quot;, &quot;lvjie&quot;); treeMap.put(&quot;num1&quot;, &quot;lvjie&quot;); System.out.println(treeMap);} {num1=lvjie, num2=edu, num3=com, num4=lvjie} Map集合的内容输出输出Map集合中key123456789101112131415161718192021public static void main(String[] args) { // 创建TreeMap类的对象 TreeMap&lt;Student, String&gt; treeMap = new TreeMap&lt;Student, String&gt;(); // 添加内容 treeMap.put(new Student(&quot;李四&quot;, 31, 1002), &quot;回族&quot;); treeMap.put(new Student(&quot;张三&quot;, 23, 1001), &quot;汉族&quot;); treeMap.put(new Student(&quot;王五&quot;, 22, 1003), &quot;维吾尔族&quot;); // 方式一使用for...each循环 Set&lt;Student&gt; keys = treeMap.keySet(); // 获取所有的key for (Student student : keys) { System.out.println(student); } // 方式二使用迭代器 Iterator&lt;Student&gt; iterator = keys.iterator(); while (iterator.hasNext()) { System.out.println(iterator.next()); }} Student [name=王五, age=22, code=1003] Student [name=李四, age=31, code=1002] Student [name=张三, age=23, code=1001] 输出Map集合中value通过key获取value1234567891011121314151617181920212223public static void main(String[] args) { // 创建TreeMap类的对象 TreeMap&lt;Student, String&gt; treeMap = new TreeMap&lt;Student, String&gt;(); // 添加内容 treeMap.put(new Student(&quot;李四&quot;, 31, 1002), &quot;回族&quot;); treeMap.put(new Student(&quot;张三&quot;, 23, 1001), &quot;汉族&quot;); treeMap.put(new Student(&quot;王五&quot;, 22, 1003), &quot;维吾尔族&quot;); // 方式一使用for...each循环 Set&lt;Student&gt; keys = treeMap.keySet(); // 获取所有的key for (Student student : keys) { // 通过key获取value值 System.out.println(treeMap.get(student)); } // 方式二使用迭代器 Iterator&lt;Student&gt; iterator = keys.iterator(); while (iterator.hasNext()) { // 通过key获取value值 System.out.println(treeMap.get(iterator.next())); }} 维吾尔族 回族 汉族 直接获取value值1234567891011121314151617181920212223public static void main(String[] args) { // 创建TreeMap类的对象 TreeMap&lt;Student, String&gt; treeMap = new TreeMap&lt;Student, String&gt;(); // 添加内容 treeMap.put(new Student(&quot;李四&quot;, 31, 1002), &quot;回族&quot;); treeMap.put(new Student(&quot;张三&quot;, 23, 1001), &quot;汉族&quot;); treeMap.put(new Student(&quot;王五&quot;, 22, 1003), &quot;维吾尔族&quot;); // 直接获取集合中value Collection&lt;String&gt; collection = treeMap.values(); // 方式一使用for...each for (String string : collection) { System.out.println(string); // 输出value值 } // 方式二使用迭代器 Iterator&lt;String&gt; iterator = collection.iterator(); while (iterator.hasNext()) { System.out.println(iterator.next()); // 输出value值 }} 维吾尔族 回族 汉族","link":"/Java/Collection%E9%9B%86%E5%90%88%E5%92%8CMap%E9%9B%86%E5%90%88.html"},{"title":"JDK，JRE和JVM","text":"简介JVM (Java Virtual Machine)。jvm 运行 Java 字节码，能够跨平台。 JRE (Java Runtime Environment)。JRE是Java 程序运行的最小环境，没有 JRE，Java 程序就无法运行。 JDK (Java Development Kit)。JDK 是用于开发 Java 程序的最小环境。没有 JDK，Java 程序员就无法使用 Java 语言编写 Java 程序。 三者之间的关系JDK&gt;JRE&gt;JVM。在JDK的安装目录下有一个jre目录，里面有两个文件夹bin和lib，bin里的就是jvm，lib中则是jvm工作所需要的类库，而jvm和 lib合起来就称为jre。 JDK=JRE+多种Java开发工具 JRE=JVM+各种类库","link":"/Java/JDK%EF%BC%8CJRE%20%E5%92%8C%20JVM.html"},{"title":"Java面向对象三大特征","text":"面向对象的三大特征：封装、继承、多态。封装：使属性私有化，提供get、set方法；可以使类具有独立性和隔离性； 继承: 子类继承父类，拥有父类中的所有非私有特性，只支持单继承、多重继承，提高了代码的复用性； 多态：是在继承的基础上实现的，父类引用指向不同的子类对象时，调用相同的方法，呈现出不同的结果。 封装在Java中封装性一般有如下的两种情况: 属性封装：private 属性类型 属性名称 ; 封装属性其实就是为了不让外部直接调用类中的属性。属性封装后咱们需要提供方法供外界调用，属性在本类中是可以直接使用的。 方法封装：private 方法返回值 方法名称(参数列表){} 封装方法其实就是为了不让外部直接调用类中的方法。此方法主要是用来让类中方法进行调用的。 案例123456789101112131415161718192021222324252627282930313233343536package com.lvjie.entity;public class Person { // 类名称一定要大写 // 全局变量 private String name; private int age; private char sex; // 方法 public void setName(String n) { //this.name代表全局变量，n是局部变量 this.name = n; } public String getName() { return name; } public void setAge(int a) { age = a; } public int getAge() { return age; } public void setSex(char s) { sex = s; } public char getSex() { return sex; }} 123456789101112public class Test { public static void main(String[] args) { Person per = new Person(); // 给per对象的属性赋值 per.setName(&quot;张三&quot;); per.setAge(23); per.setSex('女'); // 获取per对象的属性输出 System.out.println(&quot;姓名:&quot; + per.getName() + &quot;,年龄&quot; + per.getAge() + &quot;,性别:&quot; + per.getSex()); }} 姓名:张三,年龄23,性别:女 继承多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可。 Java只支持单继承，不支持多继承，支持多重继承(继承体系)。 子类对象在实例化自己之前必须首先调用父类中的构造方法之后再调用子类自己的构造方法。 多态多态是指多种状态，当一个操作在不同的对象时，会产生不同的结果。对象多态性其实就是在Java中一个对象可以以不同的形态出现在程序中。Java中面向对象的多态性一共就有如下的两点: 方法的重载和覆写 对象的多态性 向上转型(核心) 对象向上转型：父类 父类对象 = 子类实例 ; 案例(对象向上转型)向上转型1234567891011//Person person = new Student(&quot;张三&quot;, 23, &quot;男&quot;, &quot;20180201&quot;);public static void main(String[] args) { // 创建子类的对象 Student student = new Student(&quot;张三&quot;, 23, &quot;男&quot;, &quot;20180201&quot;); System.out.println(student); // 创建父类对象 Person person = student; // 向上转型,子类对象可以转换成父类对象 person.eat(); // 调用的学生的方法 } 姓名张三,年龄:23,性别:男,学号:20180201 我是学生，吃饭 父类对象只能调用子类覆写的父类的方法，子类自己的方法父类对象无法调用。","link":"/Java/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81.html"},{"title":"List操作","text":"Lambda 表达式Lambda 表达式的语法格式： (parameters) -&gt; expression (parameters) -&gt;{ statements; } Lambda 表达式的简单例子: 不需要参数,返回值为 5 () -&gt; 5 接收一个参数(数字类型),返回其2倍的值 x -&gt; 2 * x3. 接受2个参数(数字),并返回他们的差值 (x, y) -&gt; x – y4. 接收2个int型整数,返回他们的和 (int x, int y) -&gt; x + y5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void) (String s) -&gt; System.out.print(s) List方法foreach1234// 设置list每一项的值list.forEach(item-&gt;{ item.setUser(&quot;lvjie&quot;);}) filter1234// 过滤输出符合年龄大于21岁的listlist.stream().filter(item -&gt;{ item.getAge &gt; 21}).collect(Collectors.toList()); map12// 抽取list每一项中的id组成新的listlist.stream().map(item =&gt; item.id).collect(Collectors.toList()); contains12// 列表包含字符串返回truelist.contains(&quot;lvjie&quot;) some1234// 列表里如果有一项的年龄大于21就返回truelist.stream().some(item -&gt; { item.getAge &gt; 21}).collect(Collectors.toList()); every1234// 列表里每一项的年龄都大于21才返回truelist.stream().every(item-&gt;{ item.getAge &gt; 21}).collect(Collectors.toList()); reduce12345let list = [1, 2, 3, 4];// 第一参数为数组中的每一项累加和，初始为数组第一项，第二参数为数组的每一项，初始为数组第二项list.stream().reduce((total, item) -&gt;{ return total + item; }).collect(Collectors.toList()); // 10 collect12// 收集流中的数据到listList&lt;String&gt; list = stream.collect(Collectors.toList());","link":"/Java/List%E6%93%8D%E4%BD%9C.html"},{"title":"cookie、session和token的区别","text":"HTTP 协议是一种无状态协议，所以一旦HTTP报文交换完成，客户端和服务器端就会谁也不认识谁了，这意味着服务器无法从连接上跟踪会话。即当用户A购买了一件商品并放入购物车中，当再次购买该商品时，服务器已经无法判断是哪个用户的会话了，所以才必须引入一种机制用于跟踪会话。 cookiecookie相当于通行证。是一小段文本信息。当客户端请求服务器后，如果服务器需要记录该用户状态，就会使用response回复报文向客户端颁发一个通行证cookie。而客户端收到cookie后会将cookie保存起来，当浏览器再次请求该网页时，浏览器会连同cookie一同交给服务器。服务器检查该cookie，以此辨认用户状态。 sessionsession相当于客户明细表，是另一种记录客户状态的机制，不同的是cookie保存在客户端浏览器中，而session保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是session。当客户端浏览器再次访问时只需要从该session中查找客户的状态就可以了。 如果说cookie是通过检查客户身上的通行证来确定客户身份的话，那session就是通过检查服务器上的客户明细表来确认客户身份的。session相当于程序在服务器上建立的一份客户档案，客户来访时只需要查询客户档案就可以了。 浏览器客户端保存这个“身份标识”是默认采用 cookie 的方式。 tokentoken相当于身份证，是客户端进行请求的一个标识。 当用户第一次登录后，服务器会生成一个token并将此token返回给客户端，以后客户端只需带上这个token请求数据即可，无需再次带上用户名和密码。 token验证相当于直接给服务员看自己的身份证 session和cookie和token的区别 cookie数据存放在客户端的浏览器上。session数据 放在服务器上。token存在哪儿都行，客户端可存放在localstorage或者cookie，而服务器端则会存放于数据库(服务器端的session是直接放在内存中的) cookie比session更不安全，别人可以分析存放在本地的cookie并进行cookie欺骗。 session会在一定时间内保存在服务器上。当访问增多时，会比较占用服务器的内容，考虑到减轻服务器负担，可以考虑使用cookie 单个cookie保存的数据不能超过4K，浏览器都限制一个站点最多保存20个cookie。session没有这种限制。 总结cookie相当于客户的通行证，只有携带通行证的才能通过。 session相当于服务员的客户明细表，用来记录客户通行证的。 token相当于客户的身份证，用来标识客户身份。","link":"/Java/cookie%E3%80%81session%E5%92%8Ctoken%E7%9A%84%E5%8C%BA%E5%88%AB.html"},{"title":"equals和&#x3D;&#x3D;区别","text":"equals 是方法，而 == 是操作符； 对于基本类型的变量来说（如 byte,short,char,int,long,float,double,boolean），只能使用 == ，因为这些基本类型的变量没有 equals 方法。 对于基本类型变量的比较，使用 == 比较， 一般比较的是它们的值。 对于引用类型的变量来说（例如 String 类）才有 equals 方法，因为equals方法是Object类的一个通用方法，Java当中所有的类都是继承于Object这个超类。 对于引用类型来说比较的是他们在内存中的存放地址。 总结 基本类型：比较的就是值是否相同引用类型：比较的就是地址值是否相同 == 的作用： 基本类型：比较值是否相等 引用类型：比较内存地址值是否相等 equals 的作用: 引用类型：比较内存地址值是否相等","link":"/Java/equals%E5%92%8C==%E5%8C%BA%E5%88%AB.html"},{"title":"java泛型","text":"泛型泛型的本质就是”参数化类型”，就是将原来具体的类型参数化，然后在使用时传入具体的类型。 定义语法 [访问权限] class 类名称&lt;泛型类型1,泛型类型2,…泛型类型3&gt;{ ​ [访问权限] 泛型类型标识 变量名称 ; ​ [访问权限] 泛型类型标识 方法名称(){} ; ​ [访问权限] 返回值类型声明 方法名称(泛型类型标识 变量名称){} ; } 案例给坐标点使用泛型1234567891011121314151617181920212223242526272829303132333435package com.lvjie.entity;public class Point&lt;T&gt; { private T pointX; private T pointY; public Point() {} public Point(T pointX, T pointY) { this.pointX = pointX; this.pointY = pointY; } public void setPointX(T pointX) { this.pointX = pointX; } public T getPointX() { return pointX; } public void setPointY(T pointY) { this.pointY = pointY; } public T getPointY() { return pointY; } @Override public String toString() { return &quot;X坐标为:&quot; + this.pointX + &quot;,Y坐标为:&quot; + this.pointY; }} 1234567891011121314public class Test { public static void main(String[] args) { Point&lt;Integer&gt; point1 = new Point&lt;Integer&gt;(23, 34); System.out.println(point1); Point&lt;Float&gt; point2 = new Point&lt;Float&gt;(23.3f, 34.6f); System.out.println(point2); Point&lt;String&gt; point3 = new Point&lt;String&gt;(&quot;北纬30度&quot;, &quot;东经120度&quot;); System.out.println(point3); }} X坐标为:23,Y坐标为:34 X坐标为:23.3,Y坐标为:34.6 X坐标为:北纬30度,Y坐标为:东经120度 List、List&lt;?&gt;和ListList 指定集合元素只能是T类型 List&lt;?&gt; 指定集合元素可以是任意类型 List 指定集合元素只能是Object类型。 Object和T：Object是一个实打实的类，没有泛指谁，是一个确定的类型；T可以泛指Object ?和T：？是一个不确定类，？和T都表示不确定的类型 ，但如果是T的话，函数里面可以对T进行操作，比方 T car = getCar()，而不能用？ car = getCar()。","link":"/Java/java%E6%B3%9B%E5%9E%8B.html"},{"title":"java注解","text":"注解如同标签 注解是一系列元数据，它提供数据用来解释程序代码，但是注解并非是所解释的代码本身的一部分。注解对于代码的运行效果没有直接影响。 **注解就是对于代码中某些鲜活个体的贴上去的一张标签。简化来讲，注解如同一张标签** 注解通过 @interface 关键字进行定义 12public @interface TestAnnotation {} 使用注解 1234public @interface TestAnnotation {@TestAnnotationpublic class Test {} 可以理解为将 TestAnnotation 这张标签贴到 Test 这个类上面。 元注解元注解是一种基本注解，是可以注解到注解上的注解。元注解也是一张标签，但是它是一张特殊的标签，它的作用和目的就是给其他普通的标签进行解释说明的。 元标签有 @Retention、@Documented、@Target、@Inherited、@Repeatable 5 种。 @RetentionRetention 的英文意为保留期的意思。当 @Retention 应用到一个注解上的时候，它解释说明了这个注解的的存活时间。 RetentionPolicy.SOURCE 注解只在源码阶段保留，在编译器进行编译时它将被丢弃忽视。 RetentionPolicy.CLASS 注解只被保留到编译进行的时候，它并不会被加载到 JVM 中。 RetentionPolicy.RUNTIME 注解可以保留到程序运行的时候，它会被加载进入到 JVM 中，所以在程序运行时可以获取到它们。 @Documented作用是能够将注解中的元素包含到 Javadoc 中去。可有可无。 @Target当一个注解被 @Target 注解时，这个注解就被限定了运用的场景。 ElementType.ANNOTATION_TYPE 可以给一个注解进行注解 ElementType.CONSTRUCTOR 可以给构造方法进行注解 ElementType.FIELD 可以给属性进行注解 ElementType.LOCAL_VARIABLE 可以给局部变量进行注解 ElementType.METHOD 可以给方法进行注解 ElementType.PACKAGE 可以给一个包进行注解 ElementType.PARAMETER 可以给一个方法内的参数进行注解 ElementType.TYPE 可以给一个类型进行注解，比如类、接口、枚举 @InheritedInherited 是继承的意思，子类继承超类的注解。 123456@Inherited@Retention(RetentionPolicy.RUNTIME)@interface Test {}@Testpublic class A {}public class B extends A {} 注解 Test 被 @Inherited 修饰，之后类 A 被 Test 注解，类 B 继承 A,类 B 也拥有 Test 这个注解。 @RepeatableRepeatable是可重复的意思。通常是注解的值可以同时取多个。相当于可以取多个标签。 注解的属性 注解的属性也叫做成员变量。注解只有成员变量，没有方法。注解的成员变量在注解的定义中以“无形参的方法”形式来声明，其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型。 123456@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface TestAnnotation { int id(); String msg();} TestAnnotation 这个注解中拥有 id 和 msg 两个属性。 在使用的时候，我们应该给它们进行赋值。赋值的方式是在注解的括号内以 value=”” 形式，多个属性之前用,隔开。 123@TestAnnotation(id=3,msg=&quot;hello annotation&quot;)public class Test {} 注解中属性可以有默认值，默认值需要用 default 关键值指定。 123456@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface TestAnnotation { public int id() default -1; public String msg() default &quot;Hi&quot;;} TestAnnotation 中 id 属性默认值为 -1，msg 属性默认值为 Hi。 如果一个注解内仅仅只有一个名字为 value 的属性时，应用这个注解时可以直接接属性值填写到括号内。 123public @interface Check { String value();} 12@Check(&quot;hi&quot;)int a; 这和下面的效果是一样的 12@Check(value=&quot;hi&quot;)int a; 一个注解没有任何属性，那么在应用这个注解的时候，括号都可以省略。 1public @interface Perform {} 12@Performpublic void testMethod(){} Java 预置的注解@Deprecated用来标记过时的元素。 123456789public class Hero { @Deprecated public void say(){ System.out.println(&quot;Noting has to say!&quot;); } public void speak(){ System.out.println(&quot;I have a dream!&quot;); }} 定义了一个 Hero 类，它有两个方法 say() 和 speak() ，其中 say() 被 @Deprecated 注解。然后我们分别调用它们。 可以看到，say() 方法上面被划了一条直线，这就是编译器识别后的提醒效果。 @Override提示子类要复写父类中被 @Override 修饰的方法。 @SuppressWarnings阻止警告。 123456@SuppressWarnings(&quot;deprecation&quot;)public void test1(){ Hero hero = new Hero(); hero.say(); hero.speak();} @SuppressWarnings(“deprecation”)会阻止调用过时元素警告。 注解与反射注解通过反射获取 通过 getAnnotation() 或者getAnnotations() 方法来获取 Annotation 对象。 12//返回指定A类型的注解public &lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationClass) {} 12//返回注解到这个元素上的所有注解public Annotation[] getAnnotations() {}","link":"/Java/java%E6%B3%A8%E8%A7%A3.html"},{"title":"PageHelper分页","text":"不使用分页插件的分页操作limit关键字：LIMIT [pageNum] [pageSize] select * from table limit 0,5; 取第一页，返回5条数据 使用Mybatis分页插件PageHelper在SpringBoot中使用PageHelper首先要在pom.xml中配置PageHelper的依赖： 12345&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;4.2.1&lt;/version&gt;&lt;/dependency&gt; 在spring的配置文件中配置拦截器插件： 12345pagehelper: helper-dialect: mysql reasonable: true supportMethodsArguments: true params: count=countSql 案例（对用户分页）： 1234567public PageInfo listUserByPage(int pageNum, int pageSize) { PageHelper.startPage(pageNum, pageSize);//调用该方法后，在此方法后面的第一个mybaits查询语句就会按照这个进行分页,这里就是userMapper.listUser() List&lt;User&gt; userList=userMapper.listUser();//查询分页用户列表，如果没有上行语句，查询的是没有分页的所有用户列表 PageInfo pageInfo=new PageInfo(userVoList);//将查询列表封装在PageInfo这个类里 return pageInfo;} 当传入pageNum = 1, pageSize = 5时PageHelper输出的数据结构： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748{ &quot;pageNum&quot;: 1, &quot;pageSize&quot;: 5, &quot;size&quot;: 5, &quot;orderBy&quot;: null, &quot;startRow&quot;: 1, &quot;endRow&quot;: 5, &quot;total&quot;: 11, &quot;pages&quot;: 3, &quot;list&quot;: [ { &quot;userId&quot;: &quot;a24d0c3b-2786-11e8-9835-e4f89cdc0d1f&quot;, &quot;username&quot;: &quot;2015081040&quot; }, { &quot;userId&quot;: &quot;b0bc9e45-2786-11e8-9835-e4f89cdc0d1f&quot;, &quot;username&quot;: &quot;2015081041&quot; }, { &quot;userId&quot;: &quot;b44fd6ac-2786-11e8-9835-e4f89cdc0d1f&quot;, &quot;username&quot;: &quot;2015081042&quot; }, { &quot;userId&quot;: &quot;b7ac58f7-2786-11e8-9835-e4f89cdc0d1f&quot;, &quot;username&quot;: &quot;2015081043&quot; }, { &quot;userId&quot;: &quot;bbdeb5d8-2786-11e8-9835-e4f89cdc0d1f&quot;, &quot;username&quot;: &quot;2015081044&quot; } ], &quot;prePage&quot;: 0, &quot;nextPage&quot;: 2, &quot;isFirstPage&quot;: true, &quot;isLastPage&quot;: false, &quot;hasPreviousPage&quot;: false, &quot;hasNextPage&quot;: true, &quot;navigatePages&quot;: 8, &quot;navigatepageNums&quot;: [ 1, 2, 3 ], &quot;navigateFirstPage&quot;: 1, &quot;navigateLastPage&quot;: 3, &quot;firstPage&quot;: 1, &quot;lastPage&quot;: 3}","link":"/Spring/PageHelper%E5%88%86%E9%A1%B5.html"},{"title":"文件上传和下载","text":"页面文件12345&lt;form action=&quot;/file/upload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;!--这里的名字要和后端接收的参数一样，并且要指定上传的是文件类型 enctype=&quot;multipart/form-data&quot;--&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;上传&quot;&gt;&lt;/form&gt; controller1234567891011121314151617181920212223242526272829303132333435363738@RestController@RequestMapping(&quot;/file&quot;)public class FileController { @PostMapping(&quot;/upload&quot;) public String upload(MultipartFile file) throws Exception { // 获取上传文件的名字 String filename = file.getOriginalFilename(); // 定义文件输出流，第一个参数是本地文件路径，第二个是文件名 FileOutputStream outputStream = new FileOutputStream(new File(&quot;e:/upload/&quot;,filename)); // 将字节型数据写入输出流 outputStream.write(file.getBytes()); // 强制输出流将缓冲区中存在的所有数据写入目标文件 outputStream.flush(); // 关闭缓冲的输出流 outputStream.close(); return &quot;上传成功&quot;; } @GetMapping(&quot;/download&quot;) public void download(String filename, HttpServletResponse response) throws Exception{ // 获得文件输入流,第一个参数是本地文件路径，第二个是文件名 FileInputStream inputStream = new FileInputStream(new File(&quot;e:/upload/&quot;, filename)); // 设置响应头、以附件形式打开文件 response.setHeader(&quot;content-disposition&quot;, &quot;attachment; filename=&quot; + filename); // 获取输出流 ServletOutputStream outputStream = response.getOutputStream(); int len = 0; byte[] data = new byte[1024]; while ((len = inputStream.read(data)) != -1) { //从输入流中读取一定数量的字节，并将其存储在缓冲区字节数组中，读到末尾返回-1 outputStream.write(data, 0, len); } // 关闭输入输出流 outputStream.close(); inputStream.close(); } 使用transferTo方法1234567891011121314151617181920212223242526272829303132333435363738@RestController@RequestMapping(&quot;/file&quot;)public class FileController { @PostMapping(&quot;/upload&quot;) public String upload(MultipartFile file) throws Exception { // 获取源文件名 String originalFilename = file.getOriginalFilename(); // 获取路径,如果不存在则创建文件夹 Path path = Paths.get(&quot;e:/upload/&quot;); if(!Files.exists(path)){ Files.createDirectory(path); } // 获取后缀并用UUID生成新的文件名，防止重名 String ext = originalFilename.substring(originalFilename.lastIndexOf(&quot;.&quot;)+1, originalFilename.length()); String newFileName = UUID.randomUUID().toString()+&quot;.&quot;+ext; // 执行文件上传,第一个参数是文件路径，第二个是文件名 file.transferTo(new File(String.valueOf(path),newFileName)); return &quot;上传成功&quot;; } @GetMapping(&quot;/download&quot;) public void download(String filename, HttpServletResponse response) throws Exception{ Path path = Paths.get(&quot;e:/upload/&quot; + filename); // 设置响应头、以附件形式打开文件 response.setHeader(&quot;content-disposition&quot;, &quot;attachment; filename=&quot; + filename); // 创建新的输出流通道 WritableByteChannel writableByteChannel = Channels.newChannel(response.getOutputStream()); // 读取文件流通道 FileChannel fileChannel = new FileInputStream(path.toFile()).getChannel(); // 将文件通道中的数据复制到新通道 fileChannel.transferTo(0, fileChannel.size(), writableByteChannel); // 通道关闭 fileChannel.close(); writableByteChannel.close(); } }","link":"/Spring/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD.html"},{"title":"请求拦截器和响应拦截器","text":"拦截器介绍一般在使用axios（只是对Ajax进行了统一的封装）时，会用到拦截器的功能，一般分为两种：请求拦截器、响应拦截器。 请求拦截器 在请求发送前进行必要操作处理，例如添加统一cookie、请求体加验证、设置请求头等，相当于是对每个接口里相同操作的一个封装。所谓的请求拦截器，其实就是先执行要添加的数据，然后再执行Ajax，如果把这个添加数据的过程抽出来，就成了所谓的请求拦截器了。 响应拦截器响应拦截器只是在请求得到响应之后，对响应体的一些处理，通常是数据统一处理等，也常来判断登录失效等。所谓的响应拦截器，就是在请求结果的返回后的同时，先不直接导出，而是先对响应码等等的进行处理，处理好之后再导出给页面，如果将这个对象响应码的处理过程抽出来，就成了所谓的响应拦截器 配置拦截器 创建axios实例 12345678// 引入axiosimport axios from 'axios'// 创建实例let instance = axios.create({ baseURL: 'xxxxxxxxxx', timeout: 15000 // 毫秒}) 配置拦截器 语法1234// 请求拦截器instance.interceptors.request.use(req=&gt;{}, err=&gt;{});// 响应拦截器instance.interceptors.reponse.use(req=&gt;{}, err=&gt;{}); 请求拦截器1234567891011//配置请求拦截器instance.interceptors.request.use(function (request) { // 在发送请求之前做些什么 if(localStorage.getItem(&quot;token&quot;);){ request.headers.token = localStorage.getItem(&quot;token&quot;); } return request;}, function (error) { // 对请求错误做些什么 return Promise.reject(error);}); 响应拦截器12345678910111213141516171819202122232425//配置响应拦截器instance.interceptors.response.use(function (response) { // 对响应数据做点什么 const res = response.data; // console.log(&quot;backdata=&quot;,res); if(response.status == 200){ if(res.code == 200){ return res; }else if(res.code == 401){//&quot;没有权限&quot; message.error(res.msg) router.push('/login') }else if(res.code == 402){//&quot;超时或者不合法的token&quot; message.error(res.msg) router.push('/login') }else if(res.code == 500){ message.error(res.msg) throw res.msg; } }else{ message.error(res.msg) }}, function (error) { // 对响应错误做点什么 return Promise.reject(error);}); 导出配有拦截器的axios实例 123export { axios_instance} 总结 在需要拦截请求or响应的地方，就可以使用新建的axios_instance实例来发起异步请求；而不需要拦截请求/响应的地方，就可以直接使用普通的axios来发起异步请求！！！ 请求拦截器：其实就是先执行要添加的数据，然后再执行Ajax，如果把这个添加数据的过程抽出来，就成了所谓的请求拦截器了 响应拦截器：就是是在请求结果的返回后的同时，先不直接导出，而是先对响应码等等的进行处理，处理好之后再导出给页面，如果将这个对象响应码的处理过程抽出来，就成了所谓的响应拦截器","link":"/Spring/%E8%AF%B7%E6%B1%82%E6%8B%A6%E6%88%AA%E5%99%A8%E5%92%8C%E5%93%8D%E5%BA%94%E6%8B%A6%E6%88%AA%E5%99%A8.html"},{"title":"UML类图","text":"一个类分三层，第一层显示类的名称，如果是抽象类，则就用斜体显示。第二层是类的特性，通常就是字段和属性。第三层是类的操作，通常是方法或行为。下面是包含类图基本关系的例子。 实现类与方法接口 继承类与抽象类 依赖类A在方法内使用类B(使用关系) 依赖12345678910public class Screwdriver { //螺丝刀，作为人类的工具，是用来被人类使用的}public class Person{ public void screw(){ //拧螺丝，需使用螺丝刀 Screwdriver screwdriver = new Screwdriver(); }} 关联类A在方法外使用类B(对等关系)，new类A必然会new类B，被关联类B以全局变量的形式出现在关联类A中。 关联1234567public class Company { //公司 private Employee emp ; //一个公司雇员，公司与雇员之间就是一种关联关系。}public class Employee{} 关联包含聚合和组合，出现关联关系需进一步考虑是否是聚合和组合关系。 聚合集体与个体 组合部分与整体","link":"/UML/UML%E7%B1%BB%E5%9B%BE.html"},{"title":"Vue中的callback回调函数","text":"回调函数callback只是提高了函数的复用性 回调函数的写法 123456789101112function validatePassword(rule, value, callback){ if(value.length&lt;6){ callback(new Error('密码不能低于6位！请重新输入。')) }else{ callback('密码长度正确！') }}function showMsg(msg){//回调函数，用来接收校检结果 console.log(msg)}validatePassword('','lvjie123',showMsg)//密码长度正确！validatePassword('','lv12',showMsg)//Error: 密码不能低于6位！请重新输入。 使用回调函数的好处是 validatePassword 不需要知道将要调用的函数名，只要传个函数过来最终它的名字都会变成 callback ， validatePassword 函数就变成一个可以复用的函数。 如果是这种没有回调的写法： 123456789101112function validatePassword(rule, value){ if(value.length&lt;6){ showMsg(new Error('密码不能低于6位！请重新输入。')) }else{ showMsg('密码长度正确！') }}function showMsg(msg){//回调函数，用来接收校检结果 console.log(msg)}validatePassword('','lvjie123')//密码长度正确！validatePassword('','lv12')//Error: 密码不能低于6位！请重新输入。 那么就没法复用，如果 showMsg 这个函数需要改名，那 validatePassword 内部使用了 showMsg 这个函数也得去改，因为已经写死了。","link":"/Vue/Vue%E4%B8%AD%E7%9A%84callback%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0.html"},{"title":"Vue中的var that&#x3D;this；","text":"在vue的代码中，经常能看到这样一段代码 1var that=this; 这个代码的作用是什么呢？我们首先来讲一讲this与that的区别。 12345678910111213141516171819var app=new Vue({ el:&quot;#player&quot;, data:{ query:&quot;五月天&quot;, musicList:[] }, methods:{ searchMusic() { var that=this; axios.get(&quot;url&quot; + this.query).then( function (res) { this.musicList=res.data.result.songs; that.musicList=res.data.result.songs; } ).catch(function (err) { console.log(err); }) }} 在javascript中，this用以指代当前对象，但是this却不是固定不变的。例如在this.query中，此时的this是指app这个实例本身。而this.musicList中的this指代的实际上是axios的回调函数本身，所以此时你在回调函数中，使用this.musicList必然是找不到相应的属性的，因为axios回调函数本身没有musicList这个属性。 所以，我们要在使用回调函数之前将app实例中的属性存储给一个其他值，也就是用that指向this。此时，that即代表app这个实例，this代表axios的回调函数。所以这个时候我们的that.musicList可以找到相应的属性。","link":"/Vue/Vue%E4%B8%AD%E7%9A%84var%20that=this%EF%BC%9B.html"},{"title":"Vue插槽slot","text":"插槽分两类，默认插槽和具名插槽。通俗理解就是默认插槽是没有名称的插槽，具名插槽是有名称的插槽。 默认插槽父组件father123456&lt;template&gt; &lt;div&gt; &lt;h3&gt;这是父组件&lt;/h3&gt; &lt;son&gt;实践默认slot&lt;/son&gt; &lt;/div&gt;&lt;/template&gt; 子组件son1234567&lt;template&gt; &lt;div&gt; &lt;h4&gt;这是子组件&lt;/h4&gt; &lt;!--默认插槽slot是没有名称的--&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt; 具名插槽父组件father12345678910&lt;template&gt; &lt;div&gt; &lt;h3&gt;这是父组件&lt;/h3&gt; &lt;son&gt; &lt;template slot=&quot;myslot&quot;&gt; &lt;div&gt;实践具名slot&lt;/div&gt; &lt;/template&gt; &lt;/son&gt; &lt;/div&gt; &lt;/template&gt; 子组件son1234567&lt;template&gt; &lt;div&gt; &lt;h4&gt;这是子组件&lt;/h4&gt; &lt;!--具名插槽slot有name属性的--&gt; &lt;slot name=&quot;myslot&quot;&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt; 作用域插槽 父组件模板的所有东西都会在父级作用域内编译；子组件模板的所有东西都会在子级作用域内编译。 简单的说，就是父组件中不能直接用子组件中定义的data数据。而slot-scope的出现就是解决了这样的问题。 父组件father123456789101112&lt;template&gt; &lt;div&gt; &lt;h3&gt;这是父组件&lt;/h3&gt; &lt;son&gt; &lt;template slot=&quot;myslot&quot; slot-scope=&quot;slotProps&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;item in slotProps.data1&quot;&gt;{{item}}&lt;/li&gt; &lt;/ul&gt; &lt;/template&gt; &lt;/son&gt; &lt;/div&gt; &lt;/template&gt; 子组件son123456789101112131415161718192021&lt;template&gt; &lt;div&gt; &lt;h4&gt;这是子组件&lt;/h4&gt; &lt;slot name=&quot;myslot&quot; :data1='list'&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt; &lt;script&gt; export default { name:'Son', data(){ return{ list:[ {name:&quot;Tom&quot;,age:15}, {name:&quot;Jim&quot;,age:25}, {name:&quot;Tony&quot;,age:13} ] } } }&lt;/script&gt; 从子组件传过来的名为data1值为list的数据将会被slot-scope接收作为slotProps的一个属性，此时slotProps.data1就是list的值。 这样我们就可以在父组件中取到子组件的值，并且加以应用了。 使用插槽自定义表格列scope.row相当于绑定数组中的一个{}，拿到当前行 12345678910111213141516171819202122232425262728293031323334&lt;template&gt; &lt;el-table :data=&quot;tableData&quot; stripe style=&quot;width: 100%&quot;&gt; &lt;el-table-column prop=&quot;name&quot; label=&quot;姓名&quot; width=&quot;180&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column label=&quot;地址&quot;&gt; &lt;template slot-scope=&quot;slotProps&quot;&gt; &lt;span&gt;{{ slotProps.row.address.city }}&lt;/span&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt;&lt;/template&gt;&lt;script&gt; export default { data() { return { tableData: [{ name: '王小虎', address: {city: '北京',village: '中关村'} }, { name: '王小虎', address: {city: '北京',village: '中关村'} }] } } }&lt;/script&gt;","link":"/Vue/Vue%E6%8F%92%E6%A7%BDslot.html"},{"title":"Vue登录验证码","text":"vue登陆验证码代码： login1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;template&gt; &lt;div&gt; &lt;el-form-item prop=&quot;sidentifyMode&quot; v-if=&quot;isSidentify &gt;= 1&quot;&gt; &lt;div class=&quot;vfcode&quot;&gt; &lt;el-input placeholder=&quot;请输入验证码&quot; v-model=&quot;form.sidentifyMode&quot;&gt;&lt;/el-input&gt; &lt;div @click=&quot;refreshCode()&quot; class=&quot;vfCodeComponents&quot; title=&quot;点击切换验证码&quot;&gt; &lt;s-identify :identifyCode=&quot;identifyCode&quot;&gt;&lt;/s-identify&gt; &lt;/div&gt; &lt;/div&gt; &lt;/el-form-item&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import SIdentify from &quot;../components/SIdentify&quot;; export default { name: &quot;Login&quot;, components: { SIdentify }, data() { //校验验证码 let checkCode = (rule, value, callback) =&gt; { if(value == this.identifyCode) { callback() }else { return callback(new Error('验证码输入错误')); } }; return { isSidentify:0,//登录失败次数 identifyCode: '',//生成的四位数验证码 identifyCodes: '1234567890abcdefjhijklinopqrsduvwxyz',//验证码字符串 form: { sidentifyMode: '',//表单验证码 }, rules: { sidentifyMode:[{required: true, message: &quot;验证码不能为空&quot;},{validator:checkCode,trigger:blur}] } } }, mounted() { this.refreshCode() }, methods: { // 更新验证码 refreshCode() { this.identifyCode = '' this.makeCode(this.identifyCodes, 4) }, // 随机生成验证码字符串 makeCode(data, len) { for (let i = 0; i &lt; len; i++) { this.identifyCode += this.identifyCodes[this.randomNum(0, this.identifyCodes.length - 1)] } }, // 生成随机数 randomNum(min, max) { max = max + 1 return Math.floor(Math.random() * (max - min) + min) } } }&lt;/script&gt;&lt;style scoped&gt; .vfcode{ width: 100%; display: flex; } .vfCodeComponents{ margin-left: 4px; }&lt;/style&gt; SIdentify组件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117&lt;template&gt; &lt;div class=&quot;s-canvas&quot;&gt; &lt;canvas id=&quot;s-canvas&quot; :width=&quot;contentWidth&quot; :height=&quot;contentHeight&quot;&gt;&lt;/canvas&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default { name: 'SIdentify', props: { identifyCode: { type: String, default: '1234' }, fontSizeMin: { type: Number, default: 18 }, fontSizeMax: { type: Number, default: 40 }, backgroundColorMin: { type: Number, default: 180 }, backgroundColorMax: { type: Number, default: 240 }, colorMin: { type: Number, default: 50 }, colorMax: { type: Number, default: 160 }, lineColorMin: { type: Number, default: 40 }, lineColorMax: { type: Number, default: 180 }, dotColorMin: { type: Number, default: 0 }, dotColorMax: { type: Number, default: 255 }, contentWidth: { type: Number, default: 111 }, contentHeight: { type: Number, default: 38 } }, methods: { // 生成一个随机数 randomNum(min, max) { return Math.floor(Math.random() * (max - min) + min) }, // 生成一个随机的颜色 randomColor(min, max) { let r = this.randomNum(min, max) let g = this.randomNum(min, max) let b = this.randomNum(min, max) return 'rgb(' + r + ',' + g + ',' + b + ')' }, drawPic() { let canvas = document.getElementById('s-canvas') let ctx = canvas.getContext('2d') ctx.textBaseline = 'bottom' // 绘制背景 ctx.fillStyle = this.randomColor(this.backgroundColorMin, this.backgroundColorMax) ctx.fillRect(0, 0, this.contentWidth, this.contentHeight) // 绘制文字 for (let i = 0; i &lt; this.identifyCode.length; i++) { this.drawText(ctx, this.identifyCode[i], i) } }, // 绘制文本 drawText(ctx, txt, i) { ctx.fillStyle = this.randomColor(this.colorMin, this.colorMax) ctx.font = this.randomNum(this.fontSizeMin, this.fontSizeMax) + 'px SimHei' let x = (i + 1) * (this.contentWidth / (this.identifyCode.length + 1)) let y = this.randomNum(this.fontSizeMax, this.contentHeight - 5) var deg = this.randomNum(-30, 30) // 字符旋转角度(不超过45度比较好) // 修改坐标原点和旋转角度 ctx.translate(x, y) ctx.rotate((deg * Math.PI) / 180) ctx.fillText(txt, 0, 0) // 恢复坐标原点和旋转角度 ctx.rotate((-deg * Math.PI) / 180) ctx.translate(-x, -y) }, }, watch: { identifyCode() { this.drawPic() } }, mounted() { this.drawPic() } }&lt;/script&gt;&lt;style scoped&gt; #s-canvas{ border-radius: 4px; }&lt;/style&gt;","link":"/Vue/Vue%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81%E7%A0%81.html"},{"title":"Vue组件传值ref和props","text":"ref父组件获取子组件的属性和方法： 父组件12345678&lt;Son ref=&quot;son&quot;&gt;&lt;/Son&gt;&lt;script&gt; //获取ref为user的子组件的data值,属性为msg let data = this.$refs.son.msg; //调用ref为user的子组件的open方法 let method = this.$refs.son.open();&lt;/script&gt; 子组件Son12345678910data() { return{ msg: 'hello lvjie' }},methods:{ open(){ console.log('this is a open method') }} props父组件向子组件传值父组件123456789101112131415161718192021222324&lt;!--父传子属性：sun对应当前的data属性，sunny可随便取，对应子组件的props属性父传子方法：save对应当前的save方法，saveToUser是对应子组件的props方法--&gt;&lt;h1&gt;父组件&lt;/h1&gt;&lt;Son :sunny=&quot;sun&quot; :saveToUser=&quot;save&quot;&gt;&lt;/Son&gt;&lt;script&gt; export default { data(){ return{ sun: [ {name: 'lvjie'}, {name: 'hello'} ] } }, methods:{ save(){ console.log(&quot;保存内容：父传子方法&quot;) } } }&lt;/script&gt; 子组件Son123456789101112131415161718192021222324&lt;h1&gt;子组件&lt;/h1&gt;&lt;li v-for=&quot;son in sunny&quot;&gt; &lt;h2&gt;{{son.name}}&lt;/h2&gt; &lt;button @click=&quot;saveToUser&quot;&gt;输出保存内容&lt;/button&gt;&lt;/li&gt;&lt;script&gt; export default { props:{ sunny:{ type:Array, default:()=&gt;{} }, saveToUser:{ type:Function, default:()=&gt;{} } }, data(){ return{ } } }&lt;/script&gt; 子组件向父组件传值子组件Son12345678910111213&lt;h1&gt;子组件&lt;/h1&gt;&lt;h1 @click=&quot;change()&quot;&gt;{{title}}&lt;/h1&gt;&lt;script&gt; export default { methods:{ change(){ //注册事件：titleChanged表示事件方法名称，对应父组件中的自定义方法名称。后面是传入的内容，相当于形参 this.$emit('titleChanged','lvjie') } } }&lt;/script&gt; 父组件123456789101112131415161718&lt;h1&gt;父组件&lt;/h1&gt;&lt;son :titleChanged=&quot;updateTitle($event)&quot;&gt;&lt;/son&gt;{{title}}&lt;script&gt; export default { data(){ return{ title: &quot;原标题&quot; } } methods:{ updateTitle(el){ this.titile = el; } } }&lt;/script&gt;","link":"/Vue/Vue%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BCref%E5%92%8Cprops.html"},{"title":"Git命令清单","text":"一般来说，日常使用只要记住下图6个命令，就可以了。 Workspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库 新建代码库12345678# 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url] 配置Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 123456789# 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name &quot;[name]&quot;$ git config [--global] user.email &quot;[email address]&quot; 增加/删除文件123456789101112131415161718192021# 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed] 代码提交123456789101112131415161718# 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 分支123456789101112131415161718192021222324252627282930313233343536373839404142# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 标签1234567891011121314151617181920212223242526# 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag] 查看信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat &quot;@{0 day ago}&quot;# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog 远程同步1234567891011121314151617181920212223# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all 撤销12345678910111213141516171819202122232425262728293031# 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]# 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop","link":"/git/Git%E5%91%BD%E4%BB%A4%E6%B8%85%E5%8D%95.html"},{"title":"解决Git提交没有权限","text":"第一次提交会出现Git提交没有权限： 解决方法首先在termital终端输入： 1ssh-keygen -t rsa -C &quot;username&quot; (注：username为你git上的用户名) 对于提示信息全部按下Enter键。 使用以下命令查看生成的SSH key : 1cat /User/username/.ssh/id_rsa.pub 把显示出来的SSH keys直接添加到github账户设置里边的SSH keys，ssh-rsa 也需要加进去。最后就可以正常执行git提交命令了。 当出现connect to host github.com port 22: Connection refused时需要进行kexue上网再次推送。","link":"/git/%E8%A7%A3%E5%86%B3Git%E6%8F%90%E4%BA%A4%E6%B2%A1%E6%9C%89%E6%9D%83%E9%99%90.html"},{"title":"不定积分常用公式","text":"不定积分常用公式总结：","link":"/math/%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86%E5%B8%B8%E7%94%A8%E5%85%AC%E5%BC%8F.html"},{"title":"二阶常系数线性非齐次微分方程的通解和特解","text":"有二阶常系数线性非齐次微分方程 1. 如果 g(t) 里有指数函数，在特解里也要用相同的指数函数。 例: 先把方程设齐次： 然后解通解:通解:然后解特解：带入原方程：特解:最后: 2. 如果 g(t) 是多项式，在特解里要用通用相同次数的多项式。 例: 通解:然后解特解：代入原方程：化简，比较系数得：特解:最后: 3. 如果 g(t) 里含有cos或者sin函数，特解里要用cos和sin函数。 例: 通解:然后解特解：代入原方程:化简，比较系数得：特解:最后: 4. 如果 g(t) 是n个函数相加，那么要把方程拆分成n个部分，依次求特解。得：对以上的n个微分方程依次求特解。 例: 通解:然后解特解：特解:最后: 5. 列出预选的特解，一定要和通解进行比较。如果预选特解中和通解中出现重复项，那么要在特解上乘以t，直到不再出现重复项。 例： 通解：由于因此初选特解但是 yp 和 yc 中第一项相同，那么要在 yp 乘以 t ，得， 但是 yp 和 yc 中第二项也相同，那么再乘以 t ，得， 把特解和通解再比较，没有重复了。特解选好了。代入原方程得：特解：最后： 6. 如果 g(t) 是两个或两个以上函数相乘，那么特解中要用 g(t) 中每个函数对应的特解相乘来求解。 例： 通解：g(t)是由几个函数相乘再相加所得，先要把它拆分开来。是由二次多项式和sin函数相乘所得。特解中要用通用二次多项式、cos和sin函数。设特解和通解比较，发现 Ccos(3t)​ 和 Fsin(3t) 和通解有相同项。那么，要在 yp1基础上乘以 t ，得：即再比较，没有相同项了。然后， 是由指数函数和cosine函数相乘所得。特解中要用指数函数、cos和sin函数。设特解然后和通解 yc​ 比较，没有相同项。最后： 总结： 如果 g(t) 中出现指数函数 (e^at^)，在特解里也要用相同的指数函数。 如果 g(t) 是多项式，在特解里要用通用相同次数的多项式。 如果 g(t) 里出现任意一个cos或者sin函数，特解里要用cos和sin函数。 如果 g(t) 是n个函数相加， ，那么要把方程拆分成n个部分，依次求特解。 列出预选的特解，一定要和通解先进行比较。如果预选特解中和通解中出现重复项，那么要在特解上乘以 t ，直到不再出现重复项。 如果 g(t) 是两个或两个以上函数相乘，那么特解中要用 g(t) 中每个函数对应的特解相乘来求解。","link":"/math/%E4%BA%8C%E9%98%B6%E5%B8%B8%E7%B3%BB%E6%95%B0%E7%BA%BF%E6%80%A7%E9%9D%9E%E9%BD%90%E6%AC%A1%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E7%9A%84%E9%80%9A%E8%A7%A3%E5%92%8C%E7%89%B9%E8%A7%A3.html"},{"title":"常见泰勒展开式","text":"常见泰勒展开式详细：","link":"/math/%E5%B8%B8%E8%A7%81%E6%B3%B0%E5%8B%92%E5%B1%95%E5%BC%80%E5%BC%8F.html"},{"title":"内网穿透","text":"很多时候，我们在本地完成的一些项目是别人不可见的，开通内网穿透就可以在任何地方给客户展示，同时也免去了部署的麻烦，没准可以少加一会班儿呢！ 关于内网穿透 内网穿透,又叫NAT穿透，是计算机用语，翻译过来就是 你的电脑可以直接被你朋友访问。 通常实现内网穿透，是通过路由器上端口映射来实现的。但是路由器通常不是每个人都有权限可以访问和设置,而且可能存在多级路由器较为复杂的网络结构。 目前内网穿透的关于软件不少：frp,nps,ngrok，花生壳，向日葵，natapp等，但收费，不收费的不好用。于是就有钉钉开放平台团队在GitHub上开源了 钉钉内网穿透，免费，开源，支持自定义子域名。 钉钉内网穿透工具配置 clone git仓库 mac用户进入mac_64，windows用户进入windows_64，Linux用户进入linux。执行以下命令： 123./ding -config=./ding.cfg -subdomain=xxxx 8080#注意xxxx是你启动命令的subdomain参数有可能被别人占用，尽量不要用常用字符，可以用自己公司名的拼音，例如：alibaba、dingding等。#xxxx直接关系到你接下来的域名地址默认会生成xxxx.vaiwan.com 测试启动完客户端后，你访问http://xxxx.vaiwan.com/xx都会映射到 http://127.0.0.1:8080/xx","link":"/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F.html"},{"title":"ADB，Fastboot，Recovery，BootLoader的区别","text":"ADBADB的全称为Android Debug Bridge，是android sdk里的工具, 可以用它对android模拟器或者安卓真机进行调试，ADB本质是一个客户端-服务器端程序，服务端为安卓手机，客户端为电脑，使用电脑客户端输入命令来操控手机服务端。 adb命令在安卓手机开机状态连接电脑进行使用 Fastbootfastboot为线刷命令行工具，对应手机的bootloader模式，在手机进入bootloader后连接电脑进行使用。可以对手机进行刷机，刷recovery，分区，上锁解锁等操作。 使用adb或者fastboot命令需要电脑安装相应的adb/fastboot驱动。 Recoveryrecovery模式刷机称为卡刷，是存在于安卓系统recovery分区的一个微型系统，类似于电脑的微型pe系统，用于卡刷ROM升级包，清除数据，恢复出厂设置，备份数据等。 一些第三方recovery(TWRP)拥有更加强大的功能，比如卡刷第三方rom，卡刷supersu进行root等。 BootLoaderbootloader类似于电脑的BIOS，用于救砖，刷recovery，刷分区等，需要配合电脑端的fastboot工具进行操作。","link":"/%E5%AE%89%E5%8D%93%E7%9F%A5%E8%AF%86/ADB%EF%BC%8CFastboot%EF%BC%8CRecovery%EF%BC%8CBootLoader%E7%9A%84%E5%8C%BA%E5%88%AB.html"},{"title":"Xposed框架本地安装","text":"当进行联网安装时出现以下问题 查了下原因应该是网络的关系（不是我们自己的网络，而是无法连接官方获取安装文件），这就说明其实只要能连接，不管是官方也好、神盾也罢，都是可以安装成功的。 既然自动方式行不通，我们就手动解决这个问题。 以下步骤我是在雷电模拟器上实现的，不管是真机还是其它模拟器，实现方式都一样。 先把Xposed安装器安装好（随便你用官方的还是神盾的），然后回到主界面，打开系统应用中的文件管理器。 按此顺序进入文件夹：storage &gt; emulated &gt; 0 &gt; Android &gt; data &gt; de.robv.android.xposed.installer &gt; cache。 注1：在最外层直接点击 sdcard 也能进入到 Android 那一层。注2：有些版本或设备 Android 直接就在最外层。 通过上图可看到目前cache文件夹里面是空的，我们点击左下角的三个点，然后点击新建文件夹，先创建一个【downloads】文件夹，接着进入这个新建的【downloads】文件夹里面，再创建一个【framework】文件夹。 我们把下载好的安装器zip文件直接从桌面拖入到模拟器里面来，我这里用的是【xposed-v88-sdk25-x86.zip】，根据安卓的版本来。 通过上图可以发现文件拖进来后自动跳到了【Pictures】文件下，没关系，我们先选中这个文件，然后直接返回到之前创建的【framework】文件夹下面，点击左下角的三个点，选择移动选择项，这个zip文件就会移到这里来了。 直接重启模拟器，然后打开Xposed安装器，点击右上角的三个点，选中【Show outdated versions】，点击【安装/更新】，选择安装。 关闭模拟器重启以后发现已激活。","link":"/%E5%AE%89%E5%8D%93%E7%9F%A5%E8%AF%86/Xposed%E6%A1%86%E6%9E%B6%E6%9C%AC%E5%9C%B0%E5%AE%89%E8%A3%85.html"},{"title":"e.currentTarget.dataset和e.target.dataset","text":"target：事件源组件对象(事件冒泡源头) currentTarget：当前组件对象(就是当前对象) 123456789&lt;view id=&quot;outter&quot; bindtap=&quot;tap1&quot;&gt; outer view &lt;view id=&quot;middle&quot; bindtap=&quot;tap2&quot;&gt; middle view &lt;view id=&quot;inner&quot; bindtap=&quot;tap3&quot;&gt; inner view &lt;/view&gt; &lt;/view&gt;&lt;/view&gt; 123456789tap1: function (e) { console.log(1, e)},tap2: function (e) { console.log(2, e)},tap3: function (e) { console.log(3, e)} 结果如下： 点击子元素inner，但由于事件冒泡父元素middle和outter都触发，从上图中我们可以看出区别： 父元素middle和outter，target的id都是等于inner(子元素的id)； middle的currentTarget的id是middle，outter的currentTarget的id是outter； 总结： target：事件源组件对象(事件冒泡源头) currentTarget：当前组件对象(就是当前对象)","link":"/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/e.currentTarget.dataset%E5%92%8Ce.target.dataset.html"},{"title":"二叉排序树的插入与删除","text":"二叉排序树的概念二叉排序树又被成为二叉搜索树、二叉查找树，简称 BST（Binary Search/Sort Tree）树。满足以下性质的二叉树就是二叉排序树： 若左子树不为空，则左子树上左右节点的值都小于根节点的值 若它的右子树不为空，则它的右子树上所有的节点的值都大于根节点的值 它的左右子树也要分别是二叉搜索树 二叉排序树的插入 如果二叉树为空，则直接插入。 如果要插入的元素已经存在，则不再进行插入。 如果能找到合适的位置，则插入成为叶子结点： 二叉排序树的删除 如果要删除的结点没有子结点，则直接删除。 如果要删除的结点只有一个子结点，则直接用孩子结点代替删除的结点。 如果要删除的结点有两个子结点： 1）中序遍历要删除的结点。 2）用前驱或后继直接替换掉要删除的结点。（前驱和后继都可以）","link":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5%E4%B8%8E%E5%88%A0%E9%99%A4.html"},{"title":"头插法和尾插法建立单链表","text":"线性表结点结构1234typedef struct LNode { //定义单链表结构类型 ElemType data; //数据域 struct LNode *next; //指针域}LNode, *LinkList; 头插法 核心：新结点的指针域指向头结点下一个结点的数据域。头结点的指针域指向新结点的数据域。 s-&gt;next = L-&gt;next; L-&gt;next = s; 算法如下： 12345678910111213141516LinkList List_HeadInsert(LinkList &amp;L){ LNode *s; int x; L = (LInkList)malloc(sizeof(LNode)); //创建头结点 L-&gt;next = NULL; //初始为空链表 scanf(&quot;%d&quot;, &amp;x); //输入结点的值 while(x != 9999) //输入9999表示结束 { s = (LNode*)malloc(sizeof(LNode)); //创建新结点 s-&gt;data = x; //新结点赋值 s-&gt;next = L-&gt;next; //将新结点指向头结点的下一个结点 L-&gt;next = s; //将新结点插入表中，L为头指针 scanf(&quot;%d&quot;, &amp;x); } //while结束 return L;} 尾插法 核心：尾结点的指针域指向新结点的数据域。尾结点指向新结点的数据域。尾结点（此时为新结点）的指针域指向空。 r-&gt;next = s; r = s; r-&gt;next = NULL; 算法如下： 1234567891011121314151617LinkList CreatList2(LinkList &amp;L){ int x; //设元素类型为整型 L = (LinlList)malloc(sizeof(LNode)); LNode *s, *r = L; //r为表尾指针 scanf(&quot;%d&quot;, &amp;x); //输入结点的值 while(x != 9999) //输入9999表示结束 { s = (LNode *)malloc(sizeof(LNode)); s-&gt;data = x; //新结点赋值 r-&gt;next = s; //将尾结点指向新结点 r = s; //将r指向新的表尾结点 scanf(&quot;%d&quot;, &amp;x); } r-&gt;next = NULL; //尾结点指针置空 return L;}","link":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A4%B4%E6%8F%92%E6%B3%95%E5%92%8C%E5%B0%BE%E6%8F%92%E6%B3%95%E5%BB%BA%E7%AB%8B%E5%8D%95%E9%93%BE%E8%A1%A8.html"},{"title":"森林、树与二叉树相互转换","text":"转换原则：左孩子右兄弟 树转换为二叉树 加线。在所有兄弟结点之间加一条连线。 去线。树中的每个结点，只保留它与第一个孩子结点的连线，删除它与其它孩子结点之间的连线。 层次调整。以树的根节点为轴心，将整棵树顺时针旋转一定角度，使之结构层次分明。（注意第一个孩子是结点的左孩子，兄弟转换过来的孩子是结点的右孩子） 森林转换为二叉树 把每棵树转换为二叉树。 第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连接起来。 二叉树转换为树是树转换为二叉树的逆过程。 加线。若某结点X的左孩子结点存在，则将这个左孩子的右孩子结点、右孩子的右孩子结点、右孩子的右孩子的右孩子结点…，都作为结点X的孩子。将结点X与这些右孩子结点用线连接起来。 去线。删除原二叉树中所有结点与其右孩子结点的连线。 层次调整。 二叉树转换为森林假如一棵二叉树的根节点有右孩子，则这棵二叉树能够转换为森林，否则将转换为一棵树。 从根节点开始，若右孩子存在，则把与右孩子结点的连线删除。再查看分离后的二叉树，若其根节点的右孩子存在，则连线删除…。直到所有这些根节点与右孩子的连线都删除为止。 将每棵分离后的二叉树转换为树。","link":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A3%AE%E6%9E%97%E3%80%81%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2.html"},{"title":"稀疏矩阵转置算法","text":"三元组一般来说，对于稀疏矩阵，我们使用三元组来存储。也就是将矩阵的所有非零元素用三元组顺序表的形式表示。每个三元组包括的信息有： i非零元素的行下标，三元组的行标。j非零元素的列下标，三元组的列标。v元素值。mu矩阵的行数，三元组的最大行标。nu矩阵的列数，三元组的最大列标。tu矩阵非零元素的总个数，三元组的总行数。 三元组顺序表的定义： 123456789# define MAXSIZE 12500 // 最大的非零元素个数typedef struct{ int i,j; // 分别表示非零元素的行下标和列下标 ElemType v; // 元素值}Triple;typedef struct{ Triple data[MAXSIZE + 1]; // 所有的非零元素， data[0]未用，data表示三元组 int mu, nu, tu; // 矩阵的行数、列数和总共的非零元素个数}TSMatrix; 转置转置需要经历以下三个步骤： 将矩阵的行列值相互交换； 将每个三元组中的 i 和 j 相互调换； 重排三元组之间的次序便可实现矩阵的转置。 普通转置算法思想： 行列数先互换，将M的元素数赋值给T的元素数。 按三元组的方式扫描：每个列标需要扫描所有的三元组，如果原矩阵的三元组列标等于设置递增的列标，则为扫描到一条，将原三元组的列值赋值给转置后三元组的行值，原三元组的行值赋值给转置后三元组的列值，原三元组的元素值赋值给转置后三元组的元素值。 123456789101112131415Status TransposeSMatrix(TSMatrix M, TSMatrix &amp;T){ //采用三元组表存储表示，求稀疏矩阵M的转置矩阵T，算法时间复杂度为O(nu * tu) T.mu = M.nu; T.nu = M.mu; T.tu = M.tu; if(T.tu){ q = 1; for(col=1; col&lt;=M.nu; col++)//n是列数 for(p=1; p&lt;=M.tu; p++) if(M.data[p].j == col){ T.data[q].i = M.data[p].j; T.data[q].j = M.data[p].i; T.data[q].v = M.data[p].v; q++; } }} 快速转置算法思想： 要想扫描一次 M 就能得到 T，必须每次扫描到一个三元组就直接将其放到转置三元组中相应的位置上。num 和cpot，分别用于存储矩阵 M 中每一列的非零元素个数和矩阵 M 中每一列第一个非零元素在 T 中的存储位置。有如下公式成立： cpot[1] = 1cpot[col] = cpot[col - 1] + num[col - 1], 2 &lt;= col &lt;= M.nu 行列数先互换，将M的元素数赋值给T的元素数。 计算每列非零元的个数：先将num数组初始化为0，然后扫描一遍三元组，将三元组列标对应的num数组作加一处理，这样就能得到M中的每一列含有非零元个数。 求第col列中第一个非零元在转置后三元组中的序号：从第二列开始，每列的copt等于前一列的copt加上前一列的num。第一列的 cpot[1] = 1。 遍历一遍三元组，取出原矩阵三元组的列标和在转置后三元组中的位置，将原三元组的列值赋值给转置后三元组的行值，将原三元组的行值赋值给转置后三元组的列值，将原三元组的元素值赋值给转置后三元组的元素值。每次赋值完以后要将对应列的copt值加1。 12345678910111213141516171819202122Status FastTransposeSMatrix(TSMatrix M, TSMatrix &amp;T){ //采用三元组表存储表示，求稀疏矩阵M的转置矩阵T，算法时间复杂度为O(nu + tu) T.mu = M.nu; T.nu = M.mu; T.tu = M.tu; if(T.tu){ for(col=1; col&lt;= M.nu; col++) num[col] = 0; for(t=1; t&lt;=M.tu; t++) num[M.data[t].j]++; //求M中每一列含非零元个数 cpot[1] = 1; //求第col列中第一个非零元在b.data中的序号 for(col=2; col&lt;=M.nu; col++) cpot[col] = cpot[col-1] + num[col-1]; for(p=1; p&lt;=M.tu; p++){ col = M.data[p].j; //col是原矩阵三元组的列标 q = cpot[col]; //q是在转置后三元组第一个非零元的位置 T.data[q].i = M.data[p].j; T.data[q].j = M.data[p].i; T.data[q].v = M.data[p].v; cpot[col]++; } }}","link":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E8%BD%AC%E7%BD%AE%E7%AE%97%E6%B3%95.html"},{"title":"红黑树","text":"红黑树红黑树（英语：Red–black tree）是一种自平衡二叉查找树，红黑树相对于AVL树来说，牺牲了部分平衡性以换取插入/删除操作时少量的旋转操作，整体来说性能要优于AVL树。红黑树具有以下性质: 节点是红色或黑色。 根是黑色。 所有叶子都是黑色（叶子是NIL节点）。 每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。） 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。 旋转和变色由于插入或者旋转会打破红黑树的性质，所以需要变色和旋转来维持红黑树的性质和平衡。变色只需将黑色结点变为红色或将红色结点变为黑色。旋转操作分为左旋和右旋。 插入 插入结点是根节点（插入前是一棵空树）：直接把插入结点涂为黑色。 插入结点的父结点是黑色的：直接插入。 插入结点的父结点是红色的： 1）插入结点Z的叔结点是红色：将父结点和叔结点设为黑色，祖父结点设为红色。将祖父结点设为当前红色结点继续操作。2）插入结点Z的叔结点是黑色且当前结点是父亲结点的右孩子：将父亲结点作为新的当前结点并以新的当前结点为支点进行左旋，将插入结点Z原来的父亲结点和祖父结点变色。3)插入结点Z的叔结点是黑色且当前结点是父亲结点的左孩子：以插入结点Z的父节点为支点向右旋转，会得到情况2)，再进行2)的操作即可。 删除红黑树的删除基于二叉搜索树的性质。 删除的是红色结点：不会破坏红黑树的性质，直接删除。 删除的是黑色结点：1）待删除结点(X)的兄弟结点是黑色，且其(W)子结点都是黑色：将待删除结点的兄弟结点变为红色，再以待删除结点的父结点开始作为迭代对象继续进行修复操作，直到迭代对象成为根节点或为红色时为止，最后再把迭代对象变为黑色来保证不会出现相邻的红色结点。2）待删除结点(X)的兄弟结点是黑色，其(W)右子结点是红色：将待删除结点的兄弟结点变色为和待删除结点的父结点同色，再将待删除结点的兄弟结点的父结点和右子结点变为黑色，最后把待删除结点的父结点进行左旋。 3）待删除结点(X)的兄弟结点是黑色，其(W)子结点左红右黑：先交换待删除结点的兄弟结点和其左子结点的颜色，再以待删除结点的兄弟结点为支点进行右旋，这时会变成情况2）。 4）待删除结点(X)的兄弟结点是红色：交换待删除结点的兄弟结点和待删除结点的父结点的颜色，再以待删除结点的父结点为支点进行左旋，这样就转化为以上三种情况之一。","link":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91.html"},{"title":"结构体和指针详解","text":"结构型和指针型：结构型​ 结构型可以理解为用户用基本类型为原料制作的数据类型，比如数组是由多个相同数据类型的变量组合起来的。但是如果要用到不同的数据类型该怎么办呢？这时候就用到结构体了。结构体可以制作新的数据类型，即可以用系统已经有的不同的基本数据类型或用户定义的结构型来组合成用户需要的复杂数据类型。 指针型​ 指针型变量里装的是变量的地址，通过指针可以找出这个变量在内存中的位置。指针型变量的定义是在变量名之前加了一个 *。*a是取变量a的内容，&amp;a是取变量a的地址。语句a = &amp;b是将变量b的地址存于变量a中，即我们常说的指针a指向b。 结点的构造 ​ 指针型用的最多的就是和结构型结合起来构造节点（如链表的结点、二叉树的结点等）。 链表结点的定义 ​ 链表的结点有两个域：一个是数据域，用来存放数据；另一个是指针域，用来存放下一个结点的位置。 ​ 链表结点的结构型定义如下： 12345typedef struct Node{ int data; struct Node *next; //指向Node型变量的指针}Node; 结构体名字为Node，结构体成员有一个是用自己来定义的和自己类型相同的变量的指针（struct Node *next）。 二叉树结点的定义 ​ 在链表结点结构型的基础上，再加上一个指向自己同一类型变量的指针域，即二叉树结点结构型。 123456typedef struct BTNode { int data; struct BTNode *lchild; //指向左孩子结点指针 struct BTNode *rchild; //指向右孩子结点指针}BTNode; 利用空间申请函数申请一个结点空间：BT = (BTNode*)malloc(sizeof(BTNode)); 一般来说，用结构体变量直接取分量，其操作用“.”；用指针结构体变量的指针来去分量，其操作用“-&gt;”，-&gt;是结构体指针运算符。 关于 typedef 和 #define typedef ​ typedef可以理解为给现有的数据类型起一个新名字。如typedef struct{...} TypeA即给struct{...}起了一个新名字TypeA。 #define ​ #define定义常量，以达到更人性化、更容易理解的目的。如： 1234#define ERROR 1#define OK 0#define bool STATUS#define int ELEMTYPE","link":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3.html"},{"title":"显卡知识","text":"“显卡”英文全称为Video card，Graphics card，又称显示接口卡或显示适配器，是计算机最基本配置、最重要、也是必备的配件之一。而平时我们说的显卡，就有集成显卡、核心显卡、独立显卡、双显卡（双卡交火）之分，虽然他们都可以统称为显卡，但是对应的含义或者存在的形式也有所不同，下面我们分别来介绍下。 集显（集成显卡，价格便宜）集成显卡，指的是集成在主板上面的显卡，集成显卡有价格低、兼容性好和升级成本低等优点。 集成显卡（部分老式主板才有，如今已淘汰） 不过，集成显卡没有独立的显存，它要占用系统内存，使CPU可用的物理内存减少，在与系统内存的交互过程中它会占用总线周期和CPU周期，所以会在某些方面影响电脑性能；其次，集成显卡虽然升级成本低，但是麻烦，要升级必须更新主板BIOS；最后，集成显卡性能一般都很低，在个人PC中，如今基本被淘汰，已被核心显卡取代。 核心显卡：（低能耗，价格相对便宜）核心显卡，也属于集成显卡的一种，可以看作是特殊的集成显卡，它不像集成显卡那样集成在主板上面，而是集成在CPU当中，带来比集成显卡更好的性能。 核心显卡（CPU自带，其实目前的智能手机也都是CPU内置GPU，也就是核心显卡方案） 目前，Intel的酷睿处理器，AMD的APU处理器都内置了核心显卡，并且性能在不断增强,档次高的CPU内置的核心显卡已经可以媲美一些入门独立显卡了。因此，选择一款内置好一些的核心显卡电脑，无需搭配独立显卡即可满足不少网络游戏需求，像APU电脑一般定位入门游戏用户，无需搭配独立显卡，依靠CPU内置核心显卡即可满足大众用户需求。 独立显卡（高性价比，价格贵）集成显卡与核心显卡基本是买主板或处理器自带了显卡，相当于送的，价格相对便宜。而独立显卡则不同，它需要单独购买。需要插在主板的PCI显卡插槽，由于体积大，配备单独的散热风扇，性能自然比集显与核显出众。 独立显卡优点在于：它本身带有独立显存，不会占用系统内存。现在，一般游戏电脑都是采用独立显卡。而且独显可在电脑内部组成多显卡，拥有强大的图像处理能力。但独立显卡价格贵一些，要升级一般都是购买显存更大的显卡，升级方便但成本高，更适合主流游戏用户推荐。 双显卡（目前也普遍存在）双显卡是指一台电脑包含了2块显卡，目前也比较常见。比如，CPU既内置了核心显卡，用户又单独购买了独立显卡，这样的电脑就配备了双显卡，目前大多数独显电脑其实都是配备了双显卡，电脑会根据需求，智能进行切换使用。 双独显交火（一般常见于高端发烧游戏电脑配置中）高端游戏玩家可能会配备2块高端独立显卡进行组合使用，这种情况称之为双卡交火，如果再结合CPU内置的核心点卡，基本也可以看做是三显卡了。 显卡选购建议对于非游戏玩家的普通大众用户而言，如今的电脑集成显卡已经被淘汰，入门或者对游戏要求不高的用户来说，稍微好一些的核心显卡，就能够满足日常需求，无需购买独立显卡。但如果是游戏玩家，想要畅玩各类主流游戏，一块主流独立显卡还是必不可少，当然这种情况，多数用户的电脑其实都是配备了核心显卡+独显双显卡。 总结 如果是日常上网浏览网页、玩玩网页游戏，或者办公的话，一般核心显卡就可以满足需求，完全可以节省购买独立显卡的预算。 如果是游戏用户，尤其3D游戏爱好者，那么独立显卡是必不可少的，当然好一些的CPU，如旗舰APU、Intel六代i3以上处理器本身内置了性能不错的核心显卡，满足CF、lol等游戏无压力，并且后期还可以增加显卡升级，这部分用户预算有限，开始可以不买独立显卡，后期可以单独购买显卡升级。 如果是要玩大型单机游戏或者中大型网络游戏的话，一定需要购买中主流以上的独立显卡，以满足需求。 对于一些特殊用户群体，如设计、3D渲染、建模的专业用户，需要购买专门的工作站设计显卡，普通的游戏显卡不太适用。 最后只得一提的是，显卡是电脑必备硬件，任何电脑没有显卡，显示器都不会有画面显示，因此一台电脑必须至少包含一种显卡，包括集显、核显、独显、双显卡，像AMD速龙系列处理器、FX推土机系列处理器以及Intel至强E系列处理器，由于CPU中屏蔽了和信息点卡，因此这部分电脑，必须搭配独立显卡。","link":"/%E7%94%B5%E8%84%91%E7%9F%A5%E8%AF%86/%E6%98%BE%E5%8D%A1%E7%9F%A5%E8%AF%86.html"},{"title":"电脑CPU天梯图","text":"本文是电脑CPU天梯图、排行榜，CPU是电脑最重要的一部分。 目前CPU主要有两大厂商，AMD 和 Intel（英特尔）。AMD好还是英特尔好呢？现在，AMD的7nm制程技术，直接对Intel进行降维打击。同级别的笔记本，AMD的性价比更为出色，价格更便宜！所以追求性价比，建议买AMD的笔记本。","link":"/%E7%94%B5%E8%84%91%E7%9F%A5%E8%AF%86/%E7%94%B5%E8%84%91CPU%E5%A4%A9%E6%A2%AF%E5%9B%BE.html"},{"title":"KMP算法","text":"求得模式串中相等的前缀和后缀的最大长度，前缀是除了最后一个字符外的全部头部组合，后缀是除了第一个字符外的全部尾部组合 根据最大长度去求 next 数组，next数组相当于最大长度值整体向右移动一位，然后初始值赋为 -1。 开始将模式串P和文本串的字母一个个进行匹配，第 1 个匹配成功，第二个没有匹配成功，将模式串索引值为当前 next 数组值的元素移动到失配位置。 移动以后该位置仍然不匹配 再将模式串索引值为当前 next 数组值的元素移动到失配位置。这里next值为 -1。移动以后发现匹配。 再将模式串索引值为当前 next 数组值的元素移动到失配位置。这里next值为 2。移动以后发现匹配。 一直到最后匹配成功。 注：next[j] 的含义是：在子串的第 j 个字符与主串发生失配时，则跳到主串的 next[j] 位置重新与主串当前失配位置进行比较。","link":"/%E7%AE%97%E6%B3%95/KMP%E7%AE%97%E6%B3%95.html"},{"title":"最大值","text":"给定一组非负整数 nums，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。 注意：输出结果可能非常大，所以你需要返回一个字符串而不是整数。 示例1： 输入：nums = [10,2]输出：”210” 示例2： 输入：nums = [3,30,34,5,9]输出：”9534330” 实现思路 使用排序方法进行比较时，比较两个字符串（设为A和B），以先后顺序拼接而成的两个字符串A+B和B+A，如果A+B更大，则A在前B在后，否则A在后B在前。由于int型数组没有自定义排序的功能，字符串有自定义的排序，那么我们首先将原数组转化为字符串数组。采用外部排序接口Comparator，对compare方法传入(a, b)，返回(b+a).compareTo(a+b)。若b+a &gt; a+b结果为1，并排序交换a和b的位置；若b+a &lt; a+b则不交换。 代码实现 123456789101112131415161718192021222324public String largestNumber(int[] nums) { String[] strArr = new String[nums.length]; //数字数组转为字符串数组 for (int i = 0; i &lt; nums.length; i++) { strArr[i] = String.valueOf(nums[i]); } //自定义两个相连的字符串排序 Arrays.sort(strArr, new Comparator&lt;String&gt;() { @Override public int compare(String o1, String o2) { return (o2 + o1).compareTo(o1 + o2); } }); StringBuilder sb = new StringBuilder(); //防止出现了[0,0]的情况，此时返回&quot;0&quot; if (strArr[0].equals(&quot;0&quot;)) { return &quot;0&quot;; } //字符数组转为字符串 for (String temp : strArr) { sb.append(temp); } return sb.toString(); } 注： compare用来比较排序两个参数，如果比较结果为1进行交换，其他不进行交换。当后一个对象比当前对象大（o2.compareTo(o1) &gt;0），返回结果值为1时，前后交换，说明是降序排列。当后一个对象比当前对象小（o1.compareTo(o2) &gt; 0），返回结果值为1时，前后交换，说明是升序排列。","link":"/%E7%AE%97%E6%B3%95/%E6%9C%80%E5%A4%A7%E5%80%BC.html"},{"title":"按字编址与按字节编址","text":"在计算机系统中，总线以固定大小的一块数据进行传输，这一块的数据也称为字(word)，如今的计算机一般是32位和64位的，这里的位数则是指总线进行数据传输时一块数据的内存大小，也就是字的大小。 32位的计算机中：32位(bit)=4字节(byte)=1字(word)64位的计算机中：64位(bit)=8字节(byte)=1字(word) 由此可见，在不同位数的计算机中，一个字的大小也是不同的，所以一个字等于多少字节，是多少位，与计算机的系统硬件有关,不可以错误的对一个字是几字节下固定的判断。 某存储器按字节编址，容量为1MB，求主存地址位数。 答：1MB=2的20次方个字节，主存地址位数为20。 某存储器按字编址，容量为1MB，一个字为4个字节，求主存地址位数。 答：1MB=2的20次方个字节，1字=4B=2的2次方个字节。 主存地址数=2的20次方B/2的2次方B=2的19次方B，即地址位数为19。","link":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E6%8C%89%E5%AD%97%E7%BC%96%E5%9D%80%E4%B8%8E%E6%8C%89%E5%AD%97%E8%8A%82%E7%BC%96%E5%9D%80.html"},{"title":"TCP的三次握手和四次挥手","text":"TCP协议是7层⽹络协议中的传输层协议，负责数据的可靠传输。 在建⽴TCP连接时，需要通过三次握⼿来建⽴，过程是： 客户端向服务端发送⼀个SYN 服务端接收到SYN后，给客户端发送⼀个SYN_ACK 客户端接收到SYN_ACK后，再给服务端发送⼀个ACK 在断开TCP连接时，需要通过四次挥⼿来断开，过程是： 1. 客户端向服务端发送FIN 2. 服务端接收FIN后，向客户端发送ACK，表示我接收到了断开连接的请求，客户端你可以不发数据了， 不过服务端这边可能还有数据正在处理 3. 服务端处理完所有数据后，向客户端发送FIN，表示服务端现在可以断开连接 4. 客户端收到服务端的FIN，向服务端发送ACK，表示客户端也会断开连接了","link":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.html"},{"title":"Spring","text":"SpringSpring简介Spring是一个轻量级的控制反转（IOC）和面向切面编程（AOP）的框架 Spring组成 Spring Boot 一个快速开发的脚手架。 基于SpringBoot可以快速开发单个微服务。 SpringCloud SpringCloud基于SpringBoot实现的。 现在大多数公司都在使用SpringBoot进行快速开发，学习SpringBoot的前提，需要完全掌握Spring及SpringMVC。 IOCIOC理论控制反转 IOC 是一种设计思想，个人认为所谓控制反转就是获取依赖对象的方式反转了。 控制：谁来控制对象的创建。传统的应用程序是由程序本身控制创建的，使用Spring后，对象是由Spring来创建的。 反转：程序本身不创建对象，而变成被动的接收对象。 比如通过set接口使得程序不再具有主动性，而是变成了被动的接受对象。控制器不再是在程序猿手上，而是在用户手上，程序猿不用在去管理对象的创建了，系统的耦合性大大降低~ UserDao123456private UserDao userDao;//利用set进行动态实现对象的注入public void setUserDao(userDao userDao) { this.userDao = userDao;} 解耦过程： IOC本质控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IOC容器，其实现方法是依赖注入（Dependency Injection，DI）。依赖注入：就是利用set方法来实现注入的。 配置文件12345678910&lt;!--使用Spring来创建对象，在Spring中对象成为Bean--&gt;&lt;!--传统式声明：类型 变量名 = new 类型(); Hello hello = new Hello(); 在bean中，id相当于变量名，name是给bean取的别名，class相当于new的对象(类)：包名+类。 property相当于给对象(类)中的属性设置一个值，调用的是对象中的set方法。其中value是基本数据类型赋值，ref是对象赋值。 ref：引用在Spring容器中创建好的对象。--&gt;&lt;bean id=&quot;hello&quot; class=&quot;com.lvjie.pojo.Hello&quot; name=&quot;hello1&quot;&gt; &lt;property name=&quot;str&quot; value=&quot;Spring&quot; ref=&quot;hello&quot;/&gt;&lt;/bean&gt; 使用Spring容器获取对象： MyTest12345//获取Spring的上下文对象ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);//我们的对象都在Spring中管理了，要使用的话直接取出来就可以Hello hello = (hello) context.getBean(&quot;hello&quot;);System.out.println(hello.toString()); IOC创建对象的方式 使用无参构造创建对象，默认！ 使用有参构造创建对象(假设构造方法含有一个参数) 下标赋值 下标赋值123&lt;bean id=&quot;user&quot; class=&quot;com.lvjie.pojo.User&quot;&gt; &lt;constructor-arg index=&quot;0&quot; value=&quot;lvjie&quot;/&gt;&lt;/bean&gt; 类型(不推荐，可能类型重复) 类型123&lt;bean id=&quot;user&quot; class=&quot;com.lvjie.pojo.User&quot;&gt; &lt;constructor-arg type=&quot;java.lan.String&quot; value=&quot;lvjie&quot;/&gt;&lt;/bean&gt; 参数名 参数名123&lt;bean id=&quot;user&quot; class=&quot;com.lvjie.pojo.User&quot;&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;lvjie&quot;/&gt;&lt;/bean&gt; Spring配置导入jar包依赖123456&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.3.0&lt;/version&gt;&lt;/dependency&gt; 别名alis可以给bean取一对一别名，name可以bean取多个名字 importimport一般用于团队开发使用，可以将多个配置文件导入合并为一个总的，使用的时候直接使用总的配置就可以了。 依赖注入（DI)构造器注入见IOC创建对象的方式 Set注入【重点】 依赖注入本质是Set注入,包括有： bean | ref | list | set | map | props | value p/c命名空间注入123&lt;!--需要线引入第三方约束--&gt;xmlns:p=&quot;http://www.springframework.org/schema/p&quot;xmlns:c=&quot;http://www.springframework.org/schema/c&quot; P/C命名空间1234&lt;!--p命名空间注入可以直接注入属性的值--&gt;&lt;bean id=&quot;user&quot; class=&quot;com.lvjie.pojo.User&quot; p:name=&quot;lvjie&quot; p:age=&quot;18&quot;/&gt;&lt;!--c命名空间注入需要先有参构造器，通过构造器注入：construct-args--&gt;&lt;bean id=&quot;user2&quot; class=&quot;com.lvjie.pojo.User&quot; c:name=&quot;lvjie&quot; c:age=&quot;18&quot;/&gt; bean的作用域 单例模式（Spring默认模式）：每次从容器中get的对象是同一个。 单例模式1&lt;bean id=&quot;user&quot; class=&quot;com.lvjie.pojo.User&quot; scope=&quot;singleton&quot;/&gt; 原型模式：每次从容器中get的时候，都会产生一个新对象。 原型模式1&lt;bean id=&quot;user&quot; class=&quot;com.lvjie.pojo.User&quot; scope=&quot;prototype&quot;/&gt; 其余的request、session、application、这些只能在 web开发中使用到。 Bean的自动装配自动装配是Spring满足bean依赖的一种方式，Spring会在上下文中自动寻找，并给bean装配属性。在Spring中有三种装配的方式： 在xml中显示的配置 在Java中显示的配置 隐式的自动装配bean【重要】 byName/byType自动装配byName1234&lt;!--byName: 会自动在容器上下文中查找，和自己对象set方法里面的值对应的beanid!--&gt;&lt;bean id=&quot;people&quot; class=&quot;com.lvjie.pojo.People&quot; autowire=&quot;byName&quot; &lt;proprerty name=&quot;name&quot; value=&quot;lvjie&quot;/&gt;&lt;/bean&gt; byType1234&lt;!--byType: 会自动在容器上下文中查找，和自己对象属性类型相同的bean!--&gt;&lt;bean id=&quot;people&quot; class=&quot;com.lvjie.pojo.People&quot; autowire=&quot;byType&quot; &lt;proprerty name=&quot;name&quot; value=&quot;lvjie&quot;/&gt;&lt;/bean&gt; 小结：byName的时候，需要保证所有的bean的id唯一，并且这个bean需要和自动注入的属性的set方法里面的值一致。byType的时候，需要保证所有的bean的class唯一，并且这个bean需要和自动注入的属性的类型一致。 使用注解自动装配要使用注解需要：导入约束（context）、配置注解的支持（context:annotati on-config）、在对象属性前或set方法前加入@Autowired。 配置文件12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/springcontext.xsd&quot; &lt;context:annotation-config&gt;&lt;/beans&gt; 实体类12345678public class People { @Autowired private Cat cat; //@Autowired //public Cat setCate(){ // return cat; //}} 注解是用反射来实现的。使用Autowired我们可以不用编写Set方法了。 @Autowired默认通过byType方式实现，而且必须要求这个对象存在。【常用】 如果Autowired不唯一自动装配属性(当有多个对象时），则需要通过@Qualifier(value=“xxx”) @Resource默认通过byName方式实现，如果找不到名字，则通过byType实现。如果两个都找不到的情况下就报错。 @Autowired(required = false) 字段标记了注解说明这个对象可以为null。@Nullable 字段标记这个字段可以为null。 使用注解开发bean要使用注解开发，必须要保证aop的包导入了使用注解需要导入context约束，增加注解的支持。 spring配置文件123456789101112&lt;?xml version=”1.O” encoding=”UTF-8”?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;f xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--指定要扫描的包，这个包下的注解就会生效--&gt; &lt;context:component-scan base-package=&quot;com.lvjie.pojo&quot;/&gt; &lt;context:annotation-config/&gt;&lt;/beans&gt; @Component注解等价于&lt;bean id=&quot;user&quot; class=&quot;com.lvjie.pojo.Uer&quot;/&gt; 属性注入@Value(&quot;lvjie&quot;)注解相当于&lt;property name=&quot;name&quot; value=&quot;lvjie&quot;/&gt; 实体类123456789@Componentpublic class User { public String name; @Value(&quot;lvjie&quot;) public void setName(String name) { this.name = name; }} 衍生注解@Component 有几个衍生注解：但功能都相当于@Component，都代表将某个类注册到Spring中，对应分层对应注解名称使用。 dao层注解【@Repository】 service层注解【@Service】 controller层注解 【@Controller】 作用域@Scope(&quot;xxx&quot;)注解使用在类前相当于bean的作用域。 小结xml 适用于任何场合，维护简单方便。注解 不是自己的类不能使用。 xml 与注解 最佳实践： xml用来管理bean 注解只负责完成属性的注入 使用Java的方式配置Spring实体类12345678910111213141516171819//这里这个注解的意思，就是说明这个类被Spring接管了，注册到了容器中@Componentpublic class User { private string name; public string getName (){ return name; } @Value(&quot;lvjie&quot;) //属性注入值 public void setName(String name) { this.name = name; } @override pub1ic string toString() f return &quot;User{&quot; + &quot;name='&quot; + name + '\\' +'}'; }} 配置文件1234567891011121314151617181920package com.lvjie.config;import com.lvjie.pojo.User;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Import;// 这个也会Spring容器托管，注册到容器中，因为他本来就是一个@Component// @Configuration代表这是一个配置类，就和我们之前看的beans.xm1@Configuration@ComponentScan(&quot;com.lvjie.pojo&quot;) @Import(lvjieConfig2.class)pub1ic class KuangConfig { //注册一个bean，就相当于我们之前写的一个bean标签 //这个方法的名字，就相当于bean标签中的id属性 //这个方法的返回值，就相当于bean标签中的class属性 @Bean pub1ic User user(){ return new user(); //就 是返回要注入到bean的对象! }} MyTest12345678public class MyTest {public static void main(String[] args) { //如果完全使用了配置类方式去做，我们就只能通过AnnotationConfig上下文来获取容器，通过配置类的class对象加载! Applicationcontext context = new AnnotationConfigApplicationContext (lvjieConfig.class); User getUser = (User) context. getBean(&quot;user&quot;); System.out.println(getUser.getName()); }} 这种纯Java的配置方式，在SpringBoot中随处可见！ 代理模式静态代理 代理模式的好处： 可以使真实角色的操作更加纯粹，不用取关注一些公共的业务 公共业务就交给代理角色，实现了业务的分工 公共业务发生扩展时，方便集中管理 缺点： 一个真实角色就会产生一个代理角色，代码量会翻倍，开发效率会变低~ 动态代理可以解决以上缺点。 动态代理 动态代理和静态代理角色一样 动态代理的代理类是动态生成的，不是我们直接写好的 动态代理分为两大类:基于接口的动态代理和基于类的动态代理 基于接口 ——— JDK动态代理 基于类 ——— cglib Java字节码实现 ——— javasist 需要了解两个类：Proxy：代理；InvocationHandler：调用处理程序。 ProxyInvocationHandler12345678910111213141516171819202122232425//等我们会用这个类，自动生成代理类!public class ProxyInvocationHandler implements InvocationHandler { //被代理的接口 private Object target; public void setTarget(Object target) { this. target = target; } //生成得到代理类 public Object getProxy(){ return Proxy.newProxyInstance(this.getClass().getClassLoader(), target.getClass().getInterfaces(), this); } //处理代理实例，并返回结果: public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { log(method.getName()); object result = method.invoke(target, args); return result; } public void log(String msg){ System.out.print1n(&quot;执行了&quot;+msg+&quot;方法&quot;); }} Client123456789101112public class Client { public static void main(String[] args) { //真实角色 UserServiceImpl userService = new UserServiceImpl(); //代理角色，不存在 ProxyInvocationHandler pih = new ProxyInvocationHandler(); pih.setTarget(userService); // 设置要代理的对象 //动态生成代理类 UserService proxy = (UserService) pih.getProxy(); proxy.query(); }} 动态代理的好处： 可以使真实角色的操作更加纯粹，不用取关注一些公共的业务 公共业务就交给代理角色，实现了业务的分工 公共业务发生扩展时，方便集中管理 一个动态代理类代理的是一个接口，一般就是对应的一类业务 一个动态代理类可以代理多个类，只要是实现了同一个接口即可 AOPAOP简介AOP（Aspect Oriented Programming）：面向切面编程。底层是动态代理。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 AOP在Spring中的作用==提供声明式事务：允许用户自定义切面== 使用Spring实现AOP使用Spring API接口使用AOP，需要导入一个依赖包 maven依赖123456&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj &lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.4&lt;/version&gt;&lt;/ dependency&gt; Log123456789public class Log implements MethodBeforeAdvice { //method: 要执行的目标对象的方法 //args: 参数 //target: 目标对象 public void before(Method method, Object[] args, Object target) throws Throwable { System.out.println(target.getClass().getName()+&quot;的&quot;+method.getName()+&quot;被执行了&quot;); }} AfterLog1234567public class AfterLog implements AfterReturningAdvice { //returnValue: 返回值 public void afterReturning(Object returnValue, Method method, Object[] args, object target) throws Throwable { System.out.printin(&quot;执行了&quot; + method.getName() + &quot;方法，返回结果为：&quot; + returnValue); }} ApplicatinContext.xml12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns= &quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!--注册bean--&gt; &lt;bean id-&quot;userService&quot; class=&quot; com.lvjie.service.UserServiceImpl&quot;/&gt; &lt;bean id=&quot;log&quot; class=&quot;com.lvjie.log.Log&quot;/&gt; &lt;bean id=&quot;afterLog&quot; class-&quot;com.lvjie.log.AfterLog&quot;/&gt; &lt;!--方式一:使用原生Spring API接口--ン &lt;!--配置aop:需要导入aop的约束--〉 &lt;aop:config&gt; &lt;!--切入点: expression: 表达式，execution( 要执行的位置! *****)--&gt; &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.lvjie.service.UserServiceImpl.*(..))&quot;/&gt; &lt;!--执行环绕増加! --&gt; &lt;aop:advisor advice-ref&quot;log&quot; pointcut-ref=&quot;pointcut&quot;/&gt; &lt;aop:advisor advice-ref=&quot;afterLog&quot; pointcut-ref=&quot;pointcut&quot;/&gt; &lt;/aop:config&gt;&lt;/beans&gt; MyTest12345678public class MyTest { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //动态代理代理的是接口:注意点 UserService userService = (UserService)context.getBean(&quot;userService&quot;); userService.select(); }} 自定义类ApplicationContext.xml123456789101112&lt;!--方式二:自定义类--&gt;&lt;bean id=&quot;diy&quot; class=&quot;com.lvjie.diy.DiyPointCut&quot;/&gt; &lt;aoр:config&gt; &lt;!--自定义切面, ref要引用的类--&gt; &lt;aop:aspect ref=&quot;diy&quot;&gt; &lt;!--切入点--&gt; &lt;aop:pointcut id=&quot;point&quot; expression=&quot;execution(* com.lvjie.service.UserServiceImpl.*(..))&quot;/&gt; &lt;!--通知--&gt; &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;point&quot;/&gt; &lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;point&quot;/&gt; &lt;/aop: aspect&gt;&lt;/aop: config&gt; 使用注解实现ApplicationContext.xml1234&lt;!--方式三--&gt;&lt;bean id=&quot;annotationPointCut&quot; class=&quot;com.lvjie.diy.AnnotationPointCut&quot;/&gt;&lt;!--开启注解支持 JDK( #i proxy-target-class= &quot;false &quot;) cglib (proxy- target-class=&quot;true&quot;) --&gt;&lt;aop:aspectj-autoproxy/&gt; AnnotationPointCut1234567891011121314151617181920212223242526@Aspect //标注这个类是一 个切面public class AnnotationPointCut { @Before(&quot;executipn(* com.lvjie.service.UserServiceImpl.*(..))&quot;) public void before(){ System.out.println(&quot;=====方法执行前=====&quot;); } @After(&quot;execution(*com.lvjie.service.UserServiceImpl.*(..))&quot;) public void after(){ System. out. println(&quot;=====方法执行后=====&quot;); } //在环绕增强中，我们可以给定一个参数，代表我们要获取处理切入的点; @Around(&quot;execution(* com.lvjie.service.UserServiceImpl.*(..))&quot;) public void around(ProceedingJoinPoint jp) throws Throwable { System.out.println(&quot;环绕前&quot;); Signature signature = jp.getSignature();//获得签名 System.out.println(&quot;signature :&quot;+signature); Object proceed = jp.proceed(); //执行方法 System.out.println(&quot;环绕后&quot;); System.out.println(proceed); }} 整合MybatisMybatis-spring 编写数据源 sqlSessionFactory sqlSessionTemplate 需要给接口加实现类 将自己写的实现类注入到Spring中 测试 MyTest12345678public class MyTest { @Test public void test() throws IOException { ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); UserMapper userMapper = context.getBean(&quot;userMapper&quot;, UserMapper .class); for(User user : userMapper.selectUser()) { System.out.println(user);} spring-dao.xml12345678910111213141516171819202122232425&lt;!--DataSource: 使用Spring的数据源替换Mybatis的配置 我们这里使用Spring提供的JDBC：org.springframework.jdbc.datasource--&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;&lt;/bean&gt;&lt;!--sqLSessionFactory--&gt;&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;!--绑定Mabatis配置文件--&gt; &lt;property name=&quot;configuration&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:com/lvjie/mapper/*.xml&quot;/&gt;&lt;/bean&gt;&lt;!--SqLSessionTemplate: 就是我们使用的sqlSession--&gt;&lt;bean id=&quot;sqlSession&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt; &lt;!-- 只能使用构造器注入SessionFactory, 因为它没有set方法--&gt; &lt;constructor-arg index=&quot;0&quot; ref=&quot; sqlSessionFactory&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;userMapper&quot; class=&quot;com.lvjie.mapper.UserMapperImpl&quot;&gt; &lt;property name=&quot;sqlSession&quot; ref=&quot;sqlSession&quot;/&gt;&lt;/bean&gt; UserMapperImpl123456789101112public class UserMapperImpl implements UserMapper { //在原来我们的所有操作，都使用sqlSession来执行，现在都使sqlSessionTemplate; private SqlSessionTemplate sqlSession; public void setSqlSession(SqlSessionTemplate sqlSession) { this.sqlSession = sqlSession; } public List&lt;User&gt; selectUser() { UserMapper mapper = sqlSession.getMapper(UserMapper.class); return mapper.selectUser(); }} 声明式事务事务 把一组业务当成一个业务来做；要么都成功，要么都失败! 确保完整性和一致性; 事务ACID原则: 原子性 一致性 隔离性 多个业务可能操作同一个资源，防止数据损坏 持久性 事务一旦提交,无论系统发生什么问题，结果都不会再被影响，被持久化的写到存储器中! Spring中的事务管理spring-dao.xml123456789101112131415161718&lt;!--配置声明式事务--&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;&lt;/bean&gt;&lt;!--结合AOP实现事务的织入--&gt;&lt;!--配置事务通知; --&gt;&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager= &quot;transactionManager&quot;&gt; &lt;!--给那些方法配置事务--&gt; &lt;!--配置事务的传播特性: new propagation= --&gt; &lt;tx : attributes&gt; &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;!--配置事务切入--&gt;&lt;aop:config&gt; &lt;aop:pointcut id= &quot;txPointCut&quot; expression=&quot;execution(* com.lvjie.mapper.*.*(..))&quot;/&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txPointCut&quot; /&gt;&lt;/aop:config&gt;","link":"/Spring/Spring.html"},{"title":"Mybatis","text":"Mybatis环境： Jdk1.8 Mysql 5.7 Maven 3.6.1 idea 简介 MyBatis 是一款优秀的持久层框架 它支持自定义 SQL、存储过程以及高级映射 MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作 MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录 maven仓库123456&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;arti factId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.6&lt;/version&gt;&lt;/dependency&gt; 持久化持久化就是将程序的数据在持久状态和瞬时状态转化的过程 持久层 完成持久化工作的代码块 层界限十分明显 为什么需要Mybatis 帮助程序猿将数据存入到数据库 方便 传统的jdbc代码太复杂了。简化。框架。自动化。 第一个Mybatis程序思路：搭建环境—&gt;导入Mybatis—&gt;编写代码—&gt;测试 搭建环境搭建数据库 搭建数据库1234567891011121314CREATE DATABASE `mybatis`;USE `mybatis`;CREATE TABLE `user` ( `id` INT(20) NOT NULL PRIMARY KEY, `name` VARCHAR(30) DEFAULT NULL, `pwd` VARCHAR(30) DEFAULT NULL) ENGINE= INNODB DEFAULT CHARSET=utf8;INSERT INTO `user`(`id`, `name`, `pwd`)VALUES(1,'lvjie','123456'),(2, '张三', '123456'),(3, '李四', '123890') 新建maven项目，导入maven依赖 导入maven依赖12345678910111213141516171819202122&lt;!--导入依赖--&gt;&lt;dependencies&gt; &lt;!--mysql驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;!--mybatis--&gt; &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建一个模块 编写mybatis的核心配置文件 在resources目录下 Mybatis核心配置文件123456789101112131415161718192021222324&lt;?xml version=&quot;1.O&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;!--configuration核心配置文件--&gt;&lt;configuration&gt; &lt;environments defau1t=&quot; devel opment&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot; /&gt; &lt;dataSource type=&quot;POOLED&quot; &gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;ur1&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUni code=true&amp;amp;characterEncoding=UTF-8&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--每一个Mapper.XML都需要在Mybatis核心配置文件中注册! --&gt; &lt;mappers&gt; &lt;!--resource路径必须是斜杠，不是点--&gt; &lt;mapper resource= &quot;com/lvjie/dao/UserMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 编写mybatis工具类 MybatisUtils.java SqlSession相当于preparestatement，执行sql语句，SqlSession需要通过工厂创建 MybatisUtils.java12345678910111213141516171819202122//sqLSessionFactory --&gt; sqlSessionpublic class MybatisUtils { private static SqlSessionFactory sqlSessionFactory; static{ try { //使用Mybatis第-步:获取sqlSessionFactory对象 String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream( resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); } catch ( IOException e) { e.printStackTrace(); } } // 既然有了SqlSessionFactory, 顾名思义，我们就可以从中获得SqlSession的实例了。 // SqlSession 完全包含了面向数据库执行SQL命令所需的所有方法。 public static SqlSession getSqlSession(){ return sqlSessionFactory.openSession(); }} 编写代码实体类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class User { private int id; private String name; private String pwd; public User() { } public User(int id, String name, String pwd) { this.id = id; this.name = name; this.pwd = pwd; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getPwd() { return pwd; } public void setPwd(String pwd) { this.pwd = pwd; } @java.lang.Override public java.lang.String toString() { return &quot;User{&quot; + &quot;id=&quot; + id + &quot;, name='&quot; + name + '\\'' + &quot;, pwd='&quot; + pwd + '\\'' + '}'; } } Dao接口123public interface UserDao { List&lt;User&gt; getUerList();} 接口实现类由原来的UserDaoImpl转变为一个Mapper配置文件 Mapper配置文件1234567891011&lt;?xml version=&quot;1.0&quot; encoding-&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--namespace=绑定一个对应的Dao/Mapper接口--&gt;&lt;mapper namespace=&quot;com.lvjie.dao.UserDao&quot;&gt;&lt;!--select査詢語句--&gt;&lt;select id-&quot;getUserList&quot; resu1tType-&quot;com.lvjie.pojo.User&quot;&gt; select * from mybatis.user&lt;/select&gt;&lt;/mapper&gt; 测试核心配置文件中注册mappers junit测试 test123456789101112131415public class UserDaoTest{ @Test public void test(){ //第一步:获得SqlSession对象 SqlSession sqlSession = MybatisUtils.getSqlSession(); //方式一: getMapper UserDao userDao = sqlSession.getMapper(UserDao.class); List&lt;User&gt; userList = userDao.getUserList(); for (User user : userList) { System.out.println(user); } //关闭SqlSession sqlSession.close(); }} 添加maven依赖防止配置无法加载 maven123456789101112131415161718192021&lt;!-- #buіld #rіс. rеѕоurсеѕ, ЖjL:#іІ]В-іі #Ш#УÉJjF]/f--&gt;&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/ main/ resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/ include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; CRUDnamespacenamespace中的包名要和 Dao/mapper 接口的包名一致! Select选择，查询语句; .●id: 就是对应的namespace中的方法名;●resultType: Sq|语句执行的返回值!●parameterType :参数类型! 编写接口UserMapper UserMapper接口12345//查询全部用户List&lt;User&gt; getUserList();//根据 ID 查询用户User getUserById(int id); 编写对应的mapper中的sql语句 UserMapper.xml12345678&lt;!--查询全部用户--&gt;&lt;select id=&quot;getUserList&quot; resultType=&quot;com.lvjie.pojo.User&quot;&gt; select * from mybatis.user&lt;/select&gt;&lt;!--根据id查询用户--&gt;&lt;select id=&quot;getUserById&quot; resultType=&quot;com.lvjie.pojo.User&quot; parameterType=&quot;int&quot;&gt; select * from mybatis.user where id = #{id}&lt;/select&gt; 测试 test123456789101112131415161718192021222324@testpublic void getUserById() { SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sql.Session.getMapper(UserMapper.class); List&lt;User&gt; userList = mapper.getUserList(); for (User user : userList) { System.out.println(user) } sqlSession.close();}@testpublic void getUserById() { SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sql.Session.getMapper(UserMapper.class); User user = mappper.getUserById(1); System.out.println(user); sqlSession.close();} Insert 编写接口UserMapper UserMapper接口12//增加一个用户int addUser(User user); 编写对应的mapper中的sql语句 UserMapper.xml123&lt;insert id=&quot;addUser&quot; parameterType=&quot;com.lvjie.pojo.User&quot; &gt; insert into mybatis.user (id, name, pwd) values (#{id}, #{name}, #{pwd});&lt;/insert&gt; 测试 test123456789101112@testpublic void addUser() { SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sql.Session.getMapper(UserMapper.class); mappper.addUser(new User(4, &quot;lvjie&quot;, &quot;111111&quot;)); //增删改需要提交事务 sqlSession.commit(); sqlSession.close();} Update 编写接口UserMapper UserMapper接口12//修改用户int updateUser(User user); 编写对应的mapper中的sql语句 UserMapper.xml123&lt;update id=&quot;updateUser&quot; parameterType=&quot;com.lvjie.pojo.User&quot;&gt; update mybatis.user set name = #{name}, pwd = #{pwd} where id = #{id};&lt;/update&gt; 测试 test123456789101112@testpublic void updateUser() { SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sql.Session.getMapper(UserMapper.class); mappper.updateUser(new User(4, &quot;lvjie&quot;, &quot;123456&quot;)); //增删改需要提交事务 sqlSession.commit(); sqlSession.close();} Delete 编写接口UserMapper UserMapper接口12//删除一个用户int deleteUser(int id); 编写对应的mapper中的sql语句 UserMapper.xml123&lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt; delete from mybatis.user where id = #{id};&lt;/delete&gt; 测试 test123456789101112@testpublic void deleteUser() { SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sql.Session.getMapper(UserMapper.class); mappper.deleteUser(4); //增删改需要提交事务 sqlSession.commit(); sqlSession.close();} 万能Map假设我们的实体类或数据库中的表，字段或者参数过多，我们应当考虑使用Map！ UserMapper接口12// 万能的mapint addUser2(Map&lt;String, Object&gt; map); UserMapper.xml1234&lt;!--对象中的属性，可以直接取出来，传递map的key--&gt;&lt;insert id=&quot;addUser&quot; parameterType=&quot;map&quot;&gt; insert into mybatis.user(id, pwd) values (#{userid}, #{password});&lt;/insert&gt; test123456789101112131415@testpublic void addUser2() { SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); map.put(&quot;userid&quot;, 5); map.put(&quot;password&quot;, &quot;22222&quot;); map.addUser(map); //增删改需要提交事务 sqlSession.commit(); sqlSession.close();} Map传递参数，直接在sql中去除key即可 对象传递参数，直接在sql中取对象的属性即可 多个参数用map，或者注解。 模糊查询在sql中陪你姐中使用通配符 1select * from mybatis.user where name like &quot;%&quot;#{value}&quot;%&quot; 配置解析核心配置文件 mybatis-config.xml MyBatis 的配置文件包含了会深深影呵MyBatis行为的设置和属性信息。 配置文件12345678configuration (配置) properties (属性)settings (没置)typeAliases (炎型別名)environments (坏境配置)environment (坏境変量)transactionManager (事努管理器)mappers (映射器) 环境配置（environments)Mybatis默认的事务管理器是JDBC，连接池：POOLED 属性（Properties）我们可以通过properties属性来实现引用配置文件编写一个配置文件 db.properties1234driver=com.mysql.jdbc.Driverur1=jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;useUnicode=true&amp;characterEncoding=UTF-8username=rootpassword=123456 在核心配置文件中引入 配置文件1234&lt;!--引入配置文件--&gt;&lt;properties resource=&quot;db.properties&quot;&gt;&lt;!-- &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; --&gt;&lt;/properties&gt; 可以直接引用外部文件，如果两个文件由同一个字段，有先使用外部配置文件的。 类型别名(typeAliases) 类型别名是为Java类型设置一个短的名字。 存在的意义仅在于用来减少类完全限定名的冗余。 typeAlias1234&lt;!--可以给实体类起别名--&gt;&lt;typeAliases&gt; &lt;typeAlias type=&quot;com.lvjie.pojo.User&quot; alias=&quot;User&quot;/&gt;&lt;/typeAliases&gt; 也可以指定一个包名， MyBatis 会在包名下面搜索需要的Java Bean，比如:扫描实体类的包，它的默认别名就为这个类的类名的首字母小写! typeAlias1234&lt;!--可以给实体类起别名--&gt;&lt;typeAliases&gt; &lt;package name=&quot;com.lvjie.pojo&quot;/&gt;&lt;/typeAliases&gt; 在实体类比较少的时候，使用第一种方式如果实体类十分多，建议使用第二种。第一中可以DIY别名，第二种则不行，如果非要改，需要在实体上增加注解 注解12@Alias(&quot;user&quot;)public class User {} 映射器（mapper)MapperRegitry:注册绑定我们的Mapper文件;方式一：【推荐使用】 Mapper.XML1234&lt;!--每一个Mapper.XML都需要在Mybatis核心配置文件中注册--&gt;&lt;mappers&gt; &lt;mapper resource=&quot;com/lvjie/dao/userMapper.xml&quot;/&gt;&lt;/mappers&gt; 方式二: 使用Class文件绑定注册 Mapper.XML1234&lt;!--每一个Mapper.XML都需要在Mybatis核心配置文件中注册--&gt;&lt;mappers&gt; &lt;mapper class=&quot;com.lvjie.dao.userMapper&quot;/&gt;&lt;/mappers&gt; 注意点: 接口和他的Mapper配置文件必须同名! 接口和他的Mapper配置文件必须在同一个包下! 方式三:使用扫描包进行注入绑定 Mapper.XML1234&lt;!--每一个Mapper.XML都需要在Mybatis核心配置文件中注册! --&gt;&lt;mappers&gt; &lt;package name=&quot;com.lvjie.dao&quot;/&gt;&lt;/mappers&gt; 注意点: 接口和他的Mapper配置文件必须同名! 接口和他的Mapper配置文件必须在同一个包下! 生命周期和作用域 生命周期和作用域，是至关重要的，因为错误的使用会导致非常严重的并发问题。SqISessionFactoryBuilder:（建造工厂） 一旦创建了SqlSessionFactory, 就不再需要它了 SqlSessionFactory:（工厂） 说白了就是可以想象为:数据库连接池 SqISessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。 因此SqlSessionFactory的最佳作用域是应用作用域。 最简单的就是使用单例模式或者静态单例模式。 SqlSession（一个请求） 连接到连接池的一个请求! SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。 用完之后需要赶紧关闭，否则资源被占用! 这里面每一个Mapper，就代表一个具体的业务。 解决属性名和字段名不一致的问题当数据库中的字段和我们的实体类字段不一致时会出现结果不能正确显示，比如 实体类12345public class User { private int id; private String name; private String password;} 解决方法： 起别名 123&lt;select id=&quot;getUserById&quot; resultType=&quot;com.lvjie.pojo.User&quot;&gt; select id,name,pwd as password from mybatis.user where id = #{id}&lt;/select&gt; 结果集映射 resultMap 12345678&lt;!--结果集映射--&gt;&lt;resultMap id=&quot;UserMap&quot; type=&quot;User&quot;&gt; &lt;!--column数据库中的字段，property实体类中的属性--&gt; &lt;result column=&quot;pwd&quot; property=&quot;password&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;getUserById&quot; resultMap=&quot;UserMap&quot;&gt; select * from mybatis.user where id = #{id}&lt;/select&gt; 日志日志工厂如果一个数据库操作出现了异常，我们需要排错，日志就是最好的助手。 在Mybatis核心配置文件中配置我们的日志。 STDOUT_LOGGING标准日志输出 STDOUT_LOGGING123&lt;settings&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;&lt;/settings&gt; Log4j什么是Log4j? Log4j是Apache的一个开源项目,通过使用Log4j, 我们可以控制日志信息输送的目的地是控制台、文件、GUI组件。 我们也可以控制每-条日志的输出格式; 通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。 通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。 先导入log4j的包 maven123456&lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt;&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/ groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt; Log4j.properties Log4j.properties123456789101112131415161718192021222324#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码log4j.rootLogger=DEBUG, console, file#控制台输出的相关设置log4j.appender.console = org.apache.log4j.ConsoleAppenderlog4j.appender.console.Target = System.outlog4j.appender.console.Threshold = DEBUGlog4j.appender.console.layout = org.apache.log4j.PatternLayoutlog4j.appender.console.layout.ConversionPattern = [%c]-%m%n#文件输出的相关设置log4j.appender.file = org.apache.log4j.RollingFileAppenderlog4j.appender.file.File=./log/lvjie.loglpg4j.appender.file.MaxFileSize=10mblog4j.appender.file.Threshold=DEBUGlog4j.appender.file.layout=org.apache.log4j.PatternLayoutlog4j.appender.file.layout.ConversionPattern=[%p][%d(yy-MM-dd]] [%c]%m%n#日志输出级别log4j.logger.org.mybatis=DEBUGlog4j.logger.java.sql=DEBUGlog4j.logger.java.sql.Statement=DEBUGlog4j.logger.java.sql.ResultSet=DEBUGlog4j.logger.java.sql.PreparedStatement=DEBUG 配置log4j为日志的实现 123&lt;settings&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J&quot;/&gt;&lt;/settings&gt; 简单使用 在要使用Log4j的类中，导入包import org.apache.log4j.Logger; 日志对象，参数为当前类的class 1static Logger logger = Logger.getLogger(UserDaoTest.class); 使用Limit分页12# 语法 select * from user limit startIndex,pageSize;select * from user limit 3,5; 使用Mybatis实现分页 接口 接口12//分页List&lt;User&gt; getUserByLimit(Map&lt;String,Integer&gt; map); Mapper.xml Mapper.xml1234&lt;!--分页--&gt; &lt;select id=&quot;getuserByLimit&quot; parameterType=&quot;map&quot; resu1tMap=&quot;userMap &quot;&gt; select * from mybatis.user limit #{startIndex}, #{pagesize}&lt;/select&gt; 测试 test12345678910111213@Testpublic void getUserByLimit() { sqlsession sqlsession = MybatisUtils.getsqlsession(); UserMapper mapper = sqlsession.getMapper(userMapper.class); HashMap&lt;String, Integer&gt; map = new HashMap&lt;string, Integer&gt;(); map.put(&quot;startIndex&quot;, 1); map.put(&quot;pageSize&quot;, 2); List&lt;User&gt; userList = mapper.getUserByLimit(map); for (User user : userList) { System.out.println(user); } sqlsession.close();} 注解使用注解开发 注解在接口上实现 接口12@Select(&quot;select * from user&quot;)List&lt;User&gt; getUsers(); 需要在核心配置文件中绑定接口! 核心配置文件1234&lt;!--绑定接口--&gt;&lt;mappers&gt; &lt;mapper class=&quot;com.lvjie.dao.UserMapper&quot;/&gt;&lt;/mappers&gt; 本质: 反射机制实现底层: 动态代理 CRUD我们可以在工具类创建的时候实现自动提交事务! 123public static SqlSession getsqlSession(){ return sqlSessionFactory.openSession(true);} 编写接口，增加注解 UserMapper1234567891011121314151617181920public interface UserMapper { @Select(&quot;select * from user&quot;) List&lt;User&gt; getUsers(); //方法存在多个基本类型参数或String类型，所有的参数前而必须加上@Param( &quot;id&quot;)注解 @Select(&quot;select * from user where id = #{id}&quot; ) User getUserById(@Param(&quot;id&quot;) int id); //方法存在引用类型参数，不用加Param()注解 @Insert(&quot;insert into user(id, name, pwd) values (#{id}, #{name}, #{password})&quot;) int addUser(User user); @Update(&quot;update user set name=#{name}, pwd=#{password} where id = #{id}&quot;) int updateUser(User user); //在SQL中引用的是我在@Param()中设定的属性名 @Delete(&quot;delete from user where id = #{uid}&quot;) int deleteUser(@Param(&quot;uid&quot;) int id);} Lombok使用步骤:1.在IDEA中安装Lombok插件!2.在项目中导入lombok的jar包 maven12345&lt;dependency&gt; &lt;groupId&gt;org.projectlombok &lt;/groupId&gt; &lt;artifactId&gt;lombok &lt;/artifactId&gt; &lt;version&gt;1.18.10&lt;/version&gt;&lt;/dependency&gt; 3.在实体类上加注解即可! 注解类型123456@Data //get和set和toString方法，不包括有参和无参构造方法@Al1ArgsConstructor //有参构造方法@NoArgsConstructo //无参构造方法@ToString //toString方法@Getter //get方法@Setter //set方法 多对一处理一个老师对应多个学生 实体类 实体类1234567@Datapublic class Student { private int id; private String name; //学生需要关联一个老师 private Teacher teacher;} 实体类12345@Datapublic class Teacher { private int id; private String name;} SQL 12345678910111213141516171819202122ECREATE TABLE `teacher` { `id` INT (10) NOT NULL, `name` VARCHAR (30 ) DEFAULT NULL, PRIMARY KEY (`id`)} ENGINE=INNODB DEFAULT CHARSET=utf8INSERT INTO `teacher`(`id`, `name`) VALUES (1, 'lvjie') ;ECREATE TABLE `student` { `id` INT (10) NOT NULL, `name` VARCHAR (30) DEFAULT NULL, `tid` INT(10) DEFAULT NULL, PRIMARY KEY (`id`) , KEY `fktid` (`tid`) , CONSTRAINT `fktid` FOREIGN KEY (`tid`) REFERENCES `teacher` (`id`)} ENGINE= INNODB DEFAULT CHARSET=utf8INSERT INTO `student` (`id`, `name`, `tid`) VALUES ('1', '小明', '1');INSERT INTO `student` (`id`, `name`, `tid`) VALUES ('2', '小红', '1');INSERT INTO `student` (`id`, `name`, `tid`) VALUES ('3', '小张', '1');INSERT INTO `student` (`id`, `name`, `tid`) VALUES ('4', '小李', '1');INSERT INTO `student` (`id`, `name`, `tid`) VALUES ('5', '小王', '1'); 测试环境搭建 导入lombok 新建实体类Teacher, Student 建立Mapper接口 建立Mapper.XML文件 在核心配置文件中绑定注册我们的Mapper接口或者文件! [方式很多， 随心选] 测试查询是否能够成功! 按照结果嵌套处理（联表查询）联表查询1234567891011121314&lt;!--按照结果嵌套处理--&gt;&lt;select id=&quot; getStudent2&quot; resultMap=&quot; StudentTeacher2&quot; &gt; select s.id sid, s.name sname, t.name tname from student s, teacher t where s.tid = t.id;&lt;/select&gt;&lt;resultMap id=&quot;StudentTeacher&quot; type=&quot;Student&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;sid&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;sname&quot;/&gt; &lt;association property=&quot;teacher&quot; javaType=&quot;Teacher&quot;&gt; &lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt; &lt;/association&gt;&lt;/resultMap&gt; 按照查询嵌套处理（子查询）子查询1234567891011121314151617181920&lt;!--思路: 1.查询所有的学生信息 2.根据查询出来的学生的tid, 寻找对应的老师!--&gt;&lt;select id=&quot;getStudent&quot; resultMap=&quot;StudentTeacher&quot;&gt; select * from student&lt;/select&gt;&lt;resultMap id=&quot;StudentTeacher&quot; type=&quot;Student&quot; &gt; &lt;result property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property- &quot;name&quot; column=&quot;name&quot; /&gt; &lt;!-- 复杂的属性，我们需要单独处理 association 对象 collection 集合 --&gt; &lt;association property=&quot;teacher&quot; column=&quot;tid&quot; javaType=&quot;Teacher&quot; select=&quot;getTeacher&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;getTeacher&quot; resultType=&quot;Teacher&quot; &gt; select * from teacher where id = #{id}&lt;/select&gt; 一对多处理一个老师拥有多个学生1.环境搭建，和刚才一样实体类 实体类1234567@Datapublic class Student { private int id; private String name; private int tid;} 实体类12345678@Datapublic class Teacher { private int id; private String name; //一个老师拥有多个学生 private List&lt;student&gt; students;} 按照结果嵌套处理（联表查询）联表查询1234567891011121314151617181920&lt;!--按结果嵌套查询--&gt;&lt;select id=&quot;getTeacher&quot; resultMap-&quot;TeacherStudent&quot;&gt; select s.id sid, s.name sname, t.name tname, t.id tid from student s, teacher t where s.tid = t.id and t.id = #{tid}&lt;/select&gt;&lt;resultMap id=&quot; TeacherStudent&quot; type=&quot;Teacher&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;tid&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt; &lt;!--复杂的属性，我们需要单独处理 对象: association 集合: collection javaType 指定属性的类型! 集合中的泛型信息，我们使用ofType 获取 --&gt; &lt;collection property= &quot; students&quot; ofType=&quot;Student&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;sid&quot;/&gt; &lt;result property= &quot;name&quot; column=&quot;sname&quot;/&gt; &lt;result property=&quot;tid&quot; column=&quot;tid&quot;/&gt; &lt;/collection&gt;&lt;/resultMap&gt; 按照查询嵌套处理（子查询）子查询123456789&lt;select id=&quot;getTeacher&quot; resultMap=&quot;TeacherStudent&quot;&gt; select * from mybatis.teacher where id = #{tid}&lt;/select&gt;&lt;resultMap id=&quot;TeacherStudent&quot; type=&quot;Teacher&quot;&gt; &lt;collection property=&quot;students&quot; javaType=&quot;ArrayList&quot; ofType=&quot;Student&quot; select=&quot;getStudentByTeacherId&quot; column=&quot;id&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;getStudentByTeacherId&quot; resultType=&quot;Student&quot;&gt; select * from mybatis.student where tid = #{tid}&lt;/select&gt; 小结 关联 - association [多对一 ] 集合 - collection [一对多] javaType &amp; ofType JavaType用来指定实体类中属性的类型 ofType用来指定映射到List或者集合中的pojo类型，泛型中的约束类型! 动态SQL动态SQL就是根据不同的条件生成不同的SQL语句。所谓的动态SQL，本质上还是SQL语句，只是我们可以在SQL层面去执行一个逻辑代码。动态SQL就是在拼接SQL语句，我们只要保证SQL的正确性，按照SQL的格式，去排列组合就可以了。 搭建环境1234567CREATE TABLE blog (id varchar(50) NOT NULL COMMENT '博客id',title varchar (100) NOT NULL COMMENT '博客标题'，author varchar(30) NOT NULL COMMENT ' 博客作者'，create_time datetime NOT NULL COMMENT '创建时间' ,views int(30) NOT NULL COMMENT '浏览量') ENGINE=InnoDB DEFAULT CHARSET=utf8 创建一个基础工程 导包 编写配置文件 编写实体类 实体类12345678@Datapublic class Blog { private int id; private String title; private String author; private Date createTime; private int views;} 编写实体类对应Mapper接口和Mapper.xml文件 IFMapper.xml123456789&lt;select id=&quot;queryBlogIF&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt; select from mybatis.blog where 1=1 &lt;if test=&quot;title != null&quot;&gt; and title = #{title} &lt;/if&gt; &lt;if test=&quot;author != null&quot;&gt; and author = #{author} &lt;/if&gt;&lt;/select&gt; WhereMapper.xml1234567891011&lt;select id=&quot;queryBlogWhere&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt; select * from mybatis.blog &lt;where&gt; &lt;if test=&quot;title != null&quot;&gt; title = #{title} &lt;/if&gt; &lt;if test=&quot;author != null&quot;&gt; and author = #{author} &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; ChooseMapper.xml12345678910111213141516&lt;select id-&quot;queryBlogChoose&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt; select * from mybatis.blog &lt;where&gt; &lt;choose&gt; &lt;when test=&quot;title != null&quot;&gt; title = #{title} &lt;/when&gt; &lt;when test=&quot;author != null&quot;&gt; and author = #{author} &lt;/when&gt; &lt;otherwise&gt; and views = #{views} &lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt;&lt;/select&gt; SetMapper.xml123456789101112&lt;update id=&quot;updateBlog&quot; parameterType=&quot;map&quot;&gt; update mybatis.blog &lt;set&gt; &lt;if test=&quot;title != null&quot;&gt; title = #{title}, &lt;/if&gt; &lt;if test &quot;author != null&quot;&gt; author = #{author} &lt;/if&gt; &lt;/set&gt; where id = #{id} &lt;/update&gt; SQL片段有的时候，我们可能会将一些功能的一部分抽取出来，方便复用。 使用SQL标签抽取公共的部分 Mapper.xml12345678&lt;sql id=&quot;if-title-author&quot;&gt; &lt;if test=&quot;title != null&quot;&gt; title = #{title} &lt;/if&gt; &lt;if test=&quot;author != null&quot;&gt; and author = #{author} &lt;/if&gt;&lt;/sql&gt; 注意事项 最好基于单表来定义SQL片段 不要存在where标签 在需要使用的地方使用Include标签引用即可 Mapper.xml123456&lt;select id=&quot;queryBlogIF&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt; select * from mybatis.blog &lt;where&gt; &lt;include refid &quot;if-title-author&quot;&gt;&lt;/include&gt; &lt;/where&gt;&lt;/select&gt; ForeachMapper.xml123456789101112&lt;!-- select * from mybatis.blog where 1=1 and (id=1 or id=2 or id=3) 我们现在传递一个万能的map，这map中可以存在一个集合!--&gt;&lt;select id=&quot;queryBlogForeach&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt; select * from mybatis.blog &lt;where&gt; &lt;foreach collection=&quot;ids&quot; item=&quot;id&quot; open=&quot;and (&quot; close=&quot;)&quot; separator=&quot;or&quot;&gt; id = #{id} &lt;/foreach&gt; &lt;/where&gt;&lt;/select&gt; 缓存简介 什么是缓存[ Cache ]? 存在内存中的临时数据。 将用户经常查询的数据放在缓存(内存)中，用户去查询数据就不用从磁盘上(关系型数据库数据文件)查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。 为什么使用缓存? 减少和数据库的交互次数，减少系统开销，提高系统效率。 什么样的数据能使用缓存? 经常查询并且不经常改变的数据。 Mybatis缓存 MyBatis包含一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大的提升查询效率。 MyBatis系统中默认定义了两级缓存: 一级缓存和二级缓存 默认情况下，只有一级缓存开启。(SqISession级别的缓存， 也称为本地缓存) 二级缓存需要手动开启和配置，他是基于namespace级别的缓存。 为了提高扩展性，MyBatis定义了缓存接口Cache. 我们可以通过实现Cache接口来自定义二级缓存 一级缓存 一级缓存也叫本地缓存: SqlSession 与数据库同-次会话期间查询到的数据会放在本地缓存中。 以后如果需要获取相同的数据，直接从缓存中拿，没必须再去查询数据库; 缓存失效的情况: 查询不同的东西 增删改操作，可能会改变原来的数据，所以必定会刷新缓存! 查询不同的Mapper.xml 手动清理缓存! 1sqlSession.clearCache();//手动清理缓存 小结：一级缓存默认是开启的，只在一次SqISession中有效， 也就是拿到连接到关闭连接这个区间段!一级缓存就是一个Map。 二级缓存 二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存 基于namespace级别的缓存，一个名称空间，对应一个二级缓存; 工作机制 一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中; 如果当前会话关闭了，这个会话对应的一级缓存就没了；但是我们想要的是，会话关闭了，一级缓存中的数据被保存到二级缓存中; 新的会话查询信息，就可以从二级缓存中获取内容; 不同的mapper查出的数据会放在自己对应的缓存(map) 中; 步骤: 开启全局缓存 Mapper.xml12&lt;!--显示的开启全局缓存--&gt;&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt; 在要使用二级缓存的Mapper中开启 Mapper.xml12&lt;!--在当前Mapper.xml中使用二级缓存--&gt;&lt;cache/&gt; 也可以自定义参数 Mapper.xml12345&lt;!--在当前Mapper.xml中使用二级缓存--&gt;&lt;cache eviction=&quot;FIFO&quot; flushInterval=&quot;60000&quot; size=&quot;512&quot; readonly=&quot;true&quot;/&gt; 小结: 只要开启了二级缓存，在同一个Mapper下就有效 所有的数据都会先放在一级缓存中 只有当会话提交，或者关闭的时候，才会提交到二级缓冲中","link":"/Spring/Mybatis.html"}],"tags":[{"name":"absolute","slug":"absolute","link":"/tags/absolute/"},{"name":"relative","slug":"relative","link":"/tags/relative/"},{"name":"table-cell","slug":"table-cell","link":"/tags/table-cell/"},{"name":"两列布局","slug":"两列布局","link":"/tags/%E4%B8%A4%E5%88%97%E5%B8%83%E5%B1%80/"},{"name":"host","slug":"host","link":"/tags/host/"},{"name":"Collection","slug":"Collection","link":"/tags/Collection/"},{"name":"Map","slug":"Map","link":"/tags/Map/"},{"name":"JDK","slug":"JDK","link":"/tags/JDK/"},{"name":"JRE","slug":"JRE","link":"/tags/JRE/"},{"name":"JVM","slug":"JVM","link":"/tags/JVM/"},{"name":"面向对象三大特征","slug":"面向对象三大特征","link":"/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81/"},{"name":"List","slug":"List","link":"/tags/List/"},{"name":"cookie","slug":"cookie","link":"/tags/cookie/"},{"name":"session","slug":"session","link":"/tags/session/"},{"name":"token","slug":"token","link":"/tags/token/"},{"name":"equals","slug":"equals","link":"/tags/equals/"},{"name":"泛型","slug":"泛型","link":"/tags/%E6%B3%9B%E5%9E%8B/"},{"name":"注解","slug":"注解","link":"/tags/%E6%B3%A8%E8%A7%A3/"},{"name":"PageHelper","slug":"PageHelper","link":"/tags/PageHelper/"},{"name":"文件上传下载","slug":"文件上传下载","link":"/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD/"},{"name":"请求拦截器","slug":"请求拦截器","link":"/tags/%E8%AF%B7%E6%B1%82%E6%8B%A6%E6%88%AA%E5%99%A8/"},{"name":"响应拦截器","slug":"响应拦截器","link":"/tags/%E5%93%8D%E5%BA%94%E6%8B%A6%E6%88%AA%E5%99%A8/"},{"name":"UML类图","slug":"UML类图","link":"/tags/UML%E7%B1%BB%E5%9B%BE/"},{"name":"callback回调函数","slug":"callback回调函数","link":"/tags/callback%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/"},{"name":"slot","slug":"slot","link":"/tags/slot/"},{"name":"Vue登录验证码","slug":"Vue登录验证码","link":"/tags/Vue%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81%E7%A0%81/"},{"name":"ref","slug":"ref","link":"/tags/ref/"},{"name":"props","slug":"props","link":"/tags/props/"},{"name":"git命令","slug":"git命令","link":"/tags/git%E5%91%BD%E4%BB%A4/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"不定积分","slug":"不定积分","link":"/tags/%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86/"},{"name":"齐次","slug":"齐次","link":"/tags/%E9%BD%90%E6%AC%A1/"},{"name":"特解","slug":"特解","link":"/tags/%E7%89%B9%E8%A7%A3/"},{"name":"泰勒展开式","slug":"泰勒展开式","link":"/tags/%E6%B3%B0%E5%8B%92%E5%B1%95%E5%BC%80%E5%BC%8F/"},{"name":"NAT","slug":"NAT","link":"/tags/NAT/"},{"name":"ADB","slug":"ADB","link":"/tags/ADB/"},{"name":"Fastboot","slug":"Fastboot","link":"/tags/Fastboot/"},{"name":"Recovery","slug":"Recovery","link":"/tags/Recovery/"},{"name":"BootLoader","slug":"BootLoader","link":"/tags/BootLoader/"},{"name":"e.currentTarget.dataset","slug":"e-currentTarget-dataset","link":"/tags/e-currentTarget-dataset/"},{"name":"e.target.dataset","slug":"e-target-dataset","link":"/tags/e-target-dataset/"},{"name":"二叉排序树","slug":"二叉排序树","link":"/tags/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/"},{"name":"线性表","slug":"线性表","link":"/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"},{"name":"森林","slug":"森林","link":"/tags/%E6%A3%AE%E6%9E%97/"},{"name":"树","slug":"树","link":"/tags/%E6%A0%91/"},{"name":"二叉树","slug":"二叉树","link":"/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"快速转置","slug":"快速转置","link":"/tags/%E5%BF%AB%E9%80%9F%E8%BD%AC%E7%BD%AE/"},{"name":"三元组","slug":"三元组","link":"/tags/%E4%B8%89%E5%85%83%E7%BB%84/"},{"name":"红黑树","slug":"红黑树","link":"/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"},{"name":"结构体","slug":"结构体","link":"/tags/%E7%BB%93%E6%9E%84%E4%BD%93/"},{"name":"指针","slug":"指针","link":"/tags/%E6%8C%87%E9%92%88/"},{"name":"显卡","slug":"显卡","link":"/tags/%E6%98%BE%E5%8D%A1/"},{"name":"电脑CPU","slug":"电脑CPU","link":"/tags/%E7%94%B5%E8%84%91CPU/"},{"name":"KMP","slug":"KMP","link":"/tags/KMP/"},{"name":"LeetCode","slug":"LeetCode","link":"/tags/LeetCode/"},{"name":"编址方式","slug":"编址方式","link":"/tags/%E7%BC%96%E5%9D%80%E6%96%B9%E5%BC%8F/"},{"name":"TCP","slug":"TCP","link":"/tags/TCP/"},{"name":"Spring","slug":"Spring","link":"/tags/Spring/"},{"name":"Mybatis","slug":"Mybatis","link":"/tags/Mybatis/"}],"categories":[{"name":"CSS","slug":"CSS","link":"/categories/CSS/"},{"name":"Github","slug":"Github","link":"/categories/Github/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"Spring","slug":"Spring","link":"/categories/Spring/"},{"name":"SSM","slug":"SSM","link":"/categories/SSM/"},{"name":"UML","slug":"UML","link":"/categories/UML/"},{"name":"Vue","slug":"Vue","link":"/categories/Vue/"},{"name":"Git","slug":"Git","link":"/categories/Git/"},{"name":"Math","slug":"Math","link":"/categories/Math/"},{"name":"内网穿透","slug":"内网穿透","link":"/categories/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"},{"name":"安卓知识","slug":"安卓知识","link":"/categories/%E5%AE%89%E5%8D%93%E7%9F%A5%E8%AF%86/"},{"name":"微信小程序","slug":"微信小程序","link":"/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"数据结构","slug":"数据结构","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"电脑知识","slug":"电脑知识","link":"/categories/%E7%94%B5%E8%84%91%E7%9F%A5%E8%AF%86/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"计算机组成原理","slug":"计算机组成原理","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"name":"计算机网络","slug":"计算机网络","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]}